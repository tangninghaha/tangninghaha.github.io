<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="msvalidate.01" content="7197295068F5C122E84D3763FE74EC8A">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://lib.baomitu.com/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://lib.baomitu.com/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://lib.baomitu.com/pace/1.2.4/themes/silver/pace-theme-fill-left.css">
  <script src="https://lib.baomitu.com/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"tangninghaha.netlify.app","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.19.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="三尺微命，一介书生">
<meta property="og:type" content="website">
<meta property="og:title" content="Tangninghaha">
<meta property="og:url" content="https://tangninghaha.netlify.app/page/2/index.html">
<meta property="og:site_name" content="Tangninghaha">
<meta property="og:description" content="三尺微命，一介书生">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tangninghaha">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tangninghaha.netlify.app/page/2/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Tangninghaha</title>
  




  <script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "knozjnw3d2");
</script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Tangninghaha</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Number 10, Tangning Street</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tangninghaha"
      src="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
  <p class="site-author-name" itemprop="name">Tangninghaha</p>
  <div class="site-description" itemprop="description">三尺微命，一介书生</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RhbmduaW5naGFoYQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tangninghaha"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnRhbmduaW5naGFoYUBvdXRsb29rLmNvbQ==" title="E-Mail → mailto:tangninghaha@outlook.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="https://lib.baomitu.com/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>
<div class="cc-license animated" itemprop="sponsor">
  <a href="https://www.netlify.com" class="cc-opacity" title="Deploy with Netlify → https://www.netlify.com" target="_blank"><img height="20" src="https://api.netlify.com/api/v1/badges/098df643-d737-4e3a-8b6d-024ce59dedab/deploy-status" alt="Deploy Status"></a>
</div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9kYW5pZWxxZi5uZXRsaWZ5LmFwcC8=" title="https:&#x2F;&#x2F;danielqf.netlify.app&#x2F;">Danielqf</span>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/kinetic-tournament-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/kinetic-tournament-tree/" class="post-title-link" itemprop="url">Kinetic Tournament Tree</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-21 17:04:20" itemprop="dateCreated datePublished" datetime="2023-12-21T17:04:20+00:00">2023-12-21</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Kinetic Tournament Tree，简称 KTT，是一种动态维护函数最值的线段树。</p>
<h1 id="p5693-ei-的第六分块"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU2OTM=">P5693 EI 的第六分块</span></h1>
<p>模板题。</p>
<h2 id="题意">题意</h2>
<p>区间加正数，询问区间最大子段和。</p>
<p><span class="math inline">\(1\le n,q\le 10^{5}\)</span></p>
<h2 id="做法">做法</h2>
<p>由一种简单的求区间最值的方法拓展而来。</p>
<p>考虑维护区间的信息：从最左边开始连续一段的最大值 <span class="math inline">\(lmax\)</span>，从最右边连续一段的最大值 <span class="math inline">\(rmax\)</span>，区间的和 <span class="math inline">\(sum\)</span>，区间的答案 <span class="math inline">\(max\)</span>。</p>
<p>那么合并比较容易（假设要合并的两个区间为 <span class="math inline">\(a,b\)</span>）： <span class="math display">\[
\begin{aligned}
lmax&amp;=\max(a.lmax,a.sum+b.lmax)\\
rmax&amp;=\max(b.rmax,a.rmax+b.sum)\\
max&amp;=\max(a.max,b.max,a.rmax+b.lmax)
\end{aligned}
\]</span> 接下来考虑如何动态修改。</p>
<p>我们发现，每一个值的变化是一个一次函数的形式。具体地，当前的某一个值，例如 lmax，我们可以用这样一个函数来刻画它未来的值。 <span class="math inline">\(lmax=kx+b\)</span>，其中 <span class="math inline">\(k\)</span>是区间长度，<span class="math inline">\(b\)</span> 是当前的值，<span class="math inline">\(x\)</span> 是加的值。通过这个式子可以求出 <span class="math inline">\(lmax\)</span> 变化后的值。其它几个值是同理的。</p>
<p>但是，我们注意到 <span class="math inline">\(lmax\)</span> 可能原本取了 <span class="math inline">\(a.lmax\)</span>，但是随着区间加法的进行，<span class="math inline">\(a.sum+b.lmax&gt;a.lmax\)</span>，那么这时它的取值就变成了 <span class="math inline">\(a.sum+b.lmax\)</span>。这时候用上面的式子求出的就是错误的。</p>
<p>这该怎么办呢？我们维护一个 <span class="math inline">\(x\)</span>，表示这种变化是，这个区间的值再加 <span class="math inline">\(x\)</span> 次后，取值会发生上述变化。</p>
<p>那么我们如果发现当前区间加的数超过了 <span class="math inline">\(x\)</span>，我们就暴力重构这个区间，即将满足这个条件的全部重新计算。</p>
<p>这样做的复杂度是正确的，具体证明我也不会，可以参考 <span class="exturl" data-url="aHR0cHM6Ly9lbnRyb3B5aW5jcmVhc2VyLmJsb2cudW9qLmFjL2Jsb2cvNTIxNw==">EI的论文</span> 。</p>
<p>计算 <span class="math inline">\(x\)</span> 只需要将两个子区间的 <span class="math inline">\(x\)</span> 取 min，再看 <span class="math inline">\(lmax\)</span>，<span class="math inline">\(rmax\)</span>，<span class="math inline">\(max\)</span> 的值何时会修改，这个只要求一求一次函数的交点即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e18</span>,N=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">  ll k,b;</span><br><span class="line">  <span class="built_in">Line</span>(ll x,ll y)&#123;k=x;b=y;&#125;</span><br><span class="line">  <span class="built_in">Line</span>(<span class="type">int</span> x)&#123;k=<span class="number">1</span>;b=x;&#125;</span><br><span class="line">  <span class="built_in">Line</span>()&#123;k=<span class="number">0</span>;b=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(ll val)</span></span>&#123;</span><br><span class="line">    b+=k*val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Line <span class="keyword">operator</span>+(<span class="type">const</span> Line&amp; a,<span class="type">const</span> Line&amp; b)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;a.k+b.k,a.b+b.b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  Line l,r,mx,sum;</span><br><span class="line">  ll to;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll tag[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">inter</span><span class="params">(<span class="type">const</span> Line&amp; x,<span class="type">const</span> Line&amp; y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x.k==y.k)<span class="keyword">return</span> INF;</span><br><span class="line">  <span class="keyword">if</span>(y.b==x.b)<span class="keyword">return</span> INF;</span><br><span class="line">  ll tmp=(y.b-x.b)/(x.k-y.k);</span><br><span class="line">  <span class="keyword">return</span> tmp&lt;<span class="number">0</span>?INF:tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Line&amp; a,<span class="type">const</span> Line&amp; b)&#123;</span><br><span class="line">  <span class="keyword">return</span> a.b==b.b?a.k&lt;b.k:a.b&lt;b.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Line <span class="title">max</span><span class="params">(<span class="type">const</span> Line&amp; a,<span class="type">const</span> Line&amp; b,ll&amp; v)</span></span>&#123;</span><br><span class="line">  v=<span class="built_in">min</span>(v,<span class="built_in">inter</span>(a,b));</span><br><span class="line">  <span class="keyword">return</span> a.b==b.b?(a.k&gt;b.k?a:b):(a.b&gt;b.b?a:b);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>+(<span class="type">const</span> node&amp; a,<span class="type">const</span> node&amp; b)&#123;</span><br><span class="line">  node res;</span><br><span class="line">  res.sum=a.sum+b.sum;</span><br><span class="line">  res.to=<span class="built_in">min</span>(a.to,b.to);</span><br><span class="line">  res.l=<span class="built_in">max</span>(a.l,a.sum+b.l,res.to);</span><br><span class="line">  res.r=<span class="built_in">max</span>(b.r,a.r+b.sum,res.to);</span><br><span class="line">  res.mx=<span class="built_in">max</span>(a.r+b.l,<span class="built_in">max</span>(a.mx,b.mx,res.to),res.to);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(<span class="type">int</span> x,ll val)</span></span>&#123;</span><br><span class="line">  node&amp; cur=tr[x];</span><br><span class="line">  tag[x]+=val;cur.to-=val;</span><br><span class="line">  cur.l.<span class="built_in">upd</span>(val);cur.r.<span class="built_in">upd</span>(val);cur.mx.<span class="built_in">upd</span>(val);cur.sum.<span class="built_in">upd</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,ll val)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(val&gt;tr[k].to)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> v=val+tag[k];</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rebuild</span>(l,mid,k&lt;&lt;<span class="number">1</span>,v);<span class="built_in">rebuild</span>(mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,v);</span><br><span class="line">    tr[k]=tr[k&lt;&lt;<span class="number">1</span>]+tr[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];tag[k]=<span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">pushUp</span>(k,val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downLazy</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="built_in">pushUp</span>(k&lt;&lt;<span class="number">1</span>,tag[k]);</span><br><span class="line">  <span class="built_in">pushUp</span>(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tag[k]);</span><br><span class="line">  tag[k]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">    tr[k]=&#123;a[l],a[l],a[l],a[l],INF&#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(l,mid,k&lt;&lt;<span class="number">1</span>);<span class="built_in">build</span>(mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">  tr[k]=tr[k&lt;&lt;<span class="number">1</span>]+tr[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> val,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s&lt;=l&amp;&amp;r&lt;=t)&#123;</span><br><span class="line">    <span class="built_in">rebuild</span>(l,r,k,val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(tag[k])<span class="built_in">downLazy</span>(k);</span><br><span class="line">  <span class="keyword">if</span>(s&lt;=mid)<span class="built_in">upd</span>(l,mid,s,t,val,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(t&gt;mid)<span class="built_in">upd</span>(mid+<span class="number">1</span>,r,s,t,val,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">  tr[k]=tr[k&lt;&lt;<span class="number">1</span>]+tr[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">qry</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s&lt;=l&amp;&amp;r&lt;=t)&#123;</span><br><span class="line">    <span class="keyword">return</span> tr[k];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(tag[k])<span class="built_in">downLazy</span>(k);</span><br><span class="line">  <span class="keyword">if</span>(t&lt;=mid)<span class="keyword">return</span> <span class="built_in">qry</span>(l,mid,s,t,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(s&gt;mid)<span class="keyword">return</span> <span class="built_in">qry</span>(mid+<span class="number">1</span>,r,s,t,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">qry</span>(l,mid,s,t,k&lt;&lt;<span class="number">1</span>)+<span class="built_in">qry</span>(mid+<span class="number">1</span>,r,s,t,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="type">int</span> r=<span class="number">0</span>,neg=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>((c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&amp;&amp;(c!=<span class="string">&#x27;-&#x27;</span>))c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)neg*=<span class="number">-1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)r=(r&lt;&lt;<span class="number">1</span>)+(r&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> r*neg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,q;</span><br><span class="line">  n=<span class="built_in">read</span>();q=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i]=<span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">    <span class="type">int</span> tp,l,r,x;</span><br><span class="line">    tp=<span class="built_in">read</span>();l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(tp==<span class="number">1</span>)x=<span class="built_in">read</span>(),<span class="built_in">upd</span>(<span class="number">1</span>,n,l,r,x,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(tp==<span class="number">2</span>)&#123;</span><br><span class="line">      node res=<span class="built_in">qry</span>(<span class="number">1</span>,n,l,r,<span class="number">1</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">max</span>(<span class="number">0ll</span>,res.mx.b));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">数论函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-18 18:56:58" itemprop="dateCreated datePublished" datetime="2023-12-18T18:56:58+00:00">2023-12-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 11:13:52" itemprop="dateModified" datetime="2024-03-23T11:13:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文简单介绍了数论函数与莫比乌斯反演。</p>
<h1 id="数论函数与积性函数">数论函数与积性函数</h1>
<h2 id="数论函数">数论函数</h2>
<p>定义域为整数集，陪域为复数集的函数。</p>
<h3 id="狄利克雷函数">狄利克雷函数</h3>
<p>定义两个函数 <span class="math inline">\(f(n)\)</span> 和 <span class="math inline">\(g(n)\)</span> 的狄利克雷函数为 <span class="math inline">\((f*g)(n)=\sum_{d\vert n}f(d)g(\frac{n}{d})\)</span> 。</p>
<blockquote>
<p>如何求狄利克雷函数</p>
<h4 id="最朴素的暴力">最朴素的暴力</h4>
<p>枚举 <span class="math inline">\([1,n]\)</span> 范围内的每一个数，直接判断其是否为 <span class="math inline">\(n\)</span> 的约数。复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h4 id="稍好的暴力">稍好的暴力</h4>
<p>我们知道，枚举约数不是这样枚举的。直接枚举到 <span class="math inline">\(\sqrt{n}\)</span> 即可。复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>。</p>
<h4 id="优美的做法">优美的做法</h4>
<p>我们考虑换一个角度，枚举 <span class="math inline">\(d\)</span> ，考虑贡献到 <span class="math inline">\(d\)</span> 的倍数。因为调和级数，所以复杂度是 <span class="math inline">\(O(n\ln{n})\)</span> 的。</p>
</blockquote>
<h3 id="其它数论函数">其它数论函数</h3>
<p><span class="math inline">\(I(n)\)</span> 是一个值恒等于 1 的函数，称为恒等函数。</p>
<p><span class="math inline">\(\epsilon(n)\)</span>，也被称作 <span class="math inline">\(e(n)\)</span>，又被称为 <strong>元函数</strong> ，因为它是卷积的单位元，<span class="math inline">\(\epsilon*f=f\)</span> 。</p>
<p><span class="math inline">\(id(n)=n\)</span>，被称作单位函数。</p>
<h2 id="积性函数">积性函数</h2>
<h3 id="定义">定义</h3>
<ul>
<li>积性函数：如果对于所有 <span class="math inline">\(\gcd(a,b)=1\)</span>，有 <span class="math inline">\(f(a)f(b)=f(ab)\)</span> ，那么 <span class="math inline">\(f\)</span> 是积性函数。</li>
<li>完全积性函数：如果有 <span class="math inline">\(f(a)f(b)=f(ab)\)</span> ，那么 <span class="math inline">\(f\)</span> 是完全积性函数。</li>
</ul>
<h3 id="性质">性质</h3>
<ol type="1">
<li><p>对于积性函数 <span class="math inline">\(f\)</span> ，有 <span class="math inline">\(f(1)=1\)</span> 。</p>
<p>略证：<span class="math inline">\(f(1)=f(1)f(1)\)</span> ，得到 <span class="math inline">\(f(1)=1\)</span>。</p></li>
<li><p>若 <span class="math inline">\(x=\prod_{i=1}^{m}p_{i}^{q_{i}}\)</span>，则 <span class="math inline">\(f(x)=\prod_{i=1}^{m}f(p_{i}^{q_{i}})\)</span>。</p>
<p>根据积性函数的定义可以得到。</p></li>
<li><p>两积性函数 <span class="math inline">\(F_{1}(n)\)</span> 与 <span class="math inline">\(F_{2}(n)\)</span> 的狄利克雷卷积 <span class="math inline">\(G(n)=\sum_{d\vert n}F_{1}(n)\times F_{2}(\frac{n}{d})\)</span> 也为积性函数。</p>
<p>假设 <span class="math inline">\(a,b\)</span> 互质， <span class="math display">\[
\begin{aligned}
G(a)*G(b)&amp;=\sum_{d\vert a}F_{1}(d)F_{2}(\frac{a}{d})*\sum_{t\vert b}F_{1}(t)F_{2}(\frac{b}{t}) \\
&amp;=\sum_{d\vert a}\sum_{t\vert b}F_{1}(d)F_{1}(t)F_{2}(\frac{a}{d})F_{2}(\frac{b}{t})
\end{aligned}
\]</span> 由于 <span class="math inline">\(\gcd(a,b)=1\)</span> ，所以它们的约数 <span class="math inline">\(\gcd(d,t)=1\)</span> ，<span class="math inline">\(\gcd(\frac{a}{d},\frac{b}{t})=1\)</span> 。</p>
<p>所以有 <span class="math display">\[
\begin{aligned}
=&amp;\sum_{d\vert a}\sum_{t\vert b}F_{1}(dt)F_{2}(\frac{ab}{dt})\\
=&amp;\sum_{dt\vert ab}F_{1}(dt)F_{2}(\frac{ab}{dt})\\
=&amp;G(ab)
\end{aligned}
\]</span></p></li>
<li><p>积性函数的逆也是积性函数</p>
<p>还不不知道什么是逆。</p></li>
<li><p><span class="math inline">\(\epsilon=g*f\)</span> 时，<span class="math inline">\(g\)</span> 和 <span class="math inline">\(f\)</span> 互逆。</p>
<p>类比逆元理解。具体证明的话，参见 <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvY29tbWFuZC1ibG9jay9tdS1iaS13dS1zaS1mYW4teWFuLWppLWppLXlpbmcteW9uZw==">Command-Block 大佬的博客</span>。</p></li>
</ol>
<h1 id="莫比乌斯反演">莫比乌斯反演</h1>
<p>如果我们知道从 <span class="math inline">\(f\)</span> 到 <span class="math inline">\(g\)</span> 的关系式，这一过程称作变换；从此出发，推出了 <span class="math inline">\(g\)</span> 到 <span class="math inline">\(f\)</span> 的关系式，这一过程就叫作 <strong>反演</strong> ，也叫逆变换。</p>
<h2 id="莫比乌斯函数">莫比乌斯函数</h2>
<p>定义 <span class="math inline">\(\mu\)</span> 为莫比乌斯函数，定义为：</p>
<p>唯一分解 <span class="math inline">\(n\)</span> ，<span class="math inline">\(n=\prod_{i=1}^{k}p_{i}^{q_{i}}\)</span> <span class="math display">\[
\mu(n)=
\begin{cases}
1&amp;n=1\\
(-1)^k&amp;\max(q_{i})=1\\
0&amp;\max(q_{i})&gt;1\\
\end{cases}
\]</span></p>
<h3 id="起源">起源</h3>
<p>莫比乌斯函数的本质是 <span class="math inline">\(\mu\)</span>。</p>
<p>假设我们不知道任何关于这个函数的信息，我们考虑如何得到这个函数的表达式。</p>
<blockquote>
<p>小技巧：研究一个积性函数，<strong>先研究其在质数的幂时的表现</strong>。</p>
</blockquote>
<p>考虑当 <span class="math inline">\(n=1\)</span> 时，<span class="math inline">\(e(1)=I(1)\times 1\)</span>，所以 <span class="math inline">\(\mu(1)=1\)</span>。</p>
<p>接下来呢？积性函数在 <span class="math inline">\(n\)</span> 为质数的时候比较特殊，所以我们来研究这个函数在质数时的表现。</p>
<p>假设 <span class="math inline">\(p\)</span> 为一个质数，由于 <span class="math inline">\(e(p)=I(p)\mu(1)+I(1)\mu(p)\)</span>，由于 <span class="math inline">\(I(p)\mu(1)=1\)</span>，<span class="math inline">\(e(p)=0\)</span>，所以 <span class="math inline">\(I(1)\mu(p)\)</span> 为-1，又因为 <span class="math inline">\(I(1)=1\)</span>，所以 <span class="math inline">\(\mu(p)=-1\)</span>。</p>
<p>接下来研究 <span class="math inline">\(n\)</span> 为质数的幂时，这个函数的表现。</p>
<p><span class="math inline">\(e(p^{k})=I(p^{k})\mu(1)+I(p^{k-1})\mu(p)+\cdots+I(1)\mu(p^{k})\)</span>，即</p>
<p><span class="math inline">\(e(p^{k})=\mu(1)+\mu(p)+\cdots+\mu(p^{k})\)</span>，由于刚刚推导出 <span class="math inline">\(\mu(1)=1\)</span>，<span class="math inline">\(\mu(p)=-1\)</span>，且 <span class="math inline">\(e(p^{k})=0\)</span>，所以 <span class="math inline">\(\mu(p^{2})+\mu(p^{3})+\cdots+\mu(p^{k})=0\)</span>。</p>
<p>容易发现并证明 <span class="math inline">\(\mu(p^{k})\)</span> 在 <span class="math inline">\(k\ge 2\)</span> 时都为0。</p>
<p>如果 <span class="math inline">\(n\)</span> 唯一分解后，<span class="math inline">\(n=\prod_{i=1}^{k}p_{i}^{q_{i}}\)</span>，那么 <span class="math inline">\(\mu(n)=\prod_{i=1}^{k}\mu(p_{i}^{q_{i}})\)</span>。</p>
<p>最高的指数大于1，那么就会有一项为 <span class="math inline">\(0\)</span>，乘积就是0。</p>
<p>否则，相当于每一次乘上一个 -1，得到的结果自然就是 <span class="math inline">\((-1)^{k}\)</span> 了。</p>
<h3 id="性质-1">性质</h3>
<ol type="1">
<li><p>这是一个积性函数。</p>
<p>假设 <span class="math inline">\(\gcd(a,b)=1\)</span> 。</p>
<p>如果 <span class="math inline">\(a,b\)</span> 中的一个为 1，那么显然成立。</p>
<p>如果 <span class="math inline">\(a,b\)</span> 中的一个具有平方因子，那么乘积中必定具有平方因子。</p>
<p>如果 <span class="math inline">\(a,b\)</span> 中两者都不具有平方因子且都不为 1，又因为两者 <span class="math inline">\(\gcd\)</span> 为 1，所以乘积的本质不同质因子个数，等于两者本质不同的质因子个数相加。</p></li>
<li><p><span class="math display">\[
\sum_{d\mid n}\mu(d)=
\begin{cases}
1&amp;n=1\\
0&amp;n\neq 1\\
\end{cases}
=\epsilon(n)
\]</span></p>
<p>按照刚刚逆的定义，可以发现，<span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(I\)</span> 的逆。</p>
<p>首先 <span class="math inline">\(n=1\)</span> 时根据定义可以得到。</p>
<p><span class="math inline">\(n\not =1\)</span> 时，将 <span class="math inline">\(n\)</span> 进行唯一分解。一个约数 <span class="math inline">\(d\)</span> 相当于在 <span class="math inline">\(n\)</span> 的质因子中选择若干。</p>
<ul>
<li><p>如果选择出的存在次数大于等于2的，<span class="math inline">\(\mu(d)=0\)</span> 。</p></li>
<li><p>否则，选出的次数均为1次。假设总共有 <span class="math inline">\(m\)</span> 个本质不同质因子，选择了 <span class="math inline">\(k\)</span> 个质因子，那么总贡献就是： <span class="math display">\[
\sum_{i=0}^{m}(-1)^{i}\binom{m}{i}
\]</span> 注意到这个式子和二项式定理相似。 <span class="math display">\[
[1+(-1)]^{m}=\sum_{i=1}^{m}1^{(n-i)}(-1)^i\binom{m}{i}
\]</span> Q.E.D.</p></li>
</ul></li>
<li><p><span class="math display">\[
[\gcd(a,b)=1]=\sum_{d\vert \gcd(a,b)}\mu(d)
\]</span></p>
<p>根据性质2可以得出。</p></li>
</ol>
<h2 id="莫比乌斯变换与反演">莫比乌斯变换与反演</h2>
<p>设 <span class="math inline">\(f\)</span> 与 <span class="math inline">\(g\)</span> 为两个数论函数，如果有： <span class="math display">\[
f(n)=\sum_{d\vert n}g(d)
\]</span> 那么 <span class="math inline">\(g(n)=\sum_{d\vert n}f(\frac{n}{d})\mu(d)\)</span> ，这是一个狄利克雷卷积的形式。</p>
<p>下面的图片展示了如何手动反演找规律。</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/pfv2639c.png" alt="举例反演过程" /><figcaption aria-hidden="true">举例反演过程</figcaption>
</figure>
<p>想要证明 <span class="math inline">\(g(n)=\sum_{d\vert n}\mu(d)f(\frac{n}{d})\)</span> 。</p>
<p>按照证明反演的套路，我们将 <span class="math inline">\(f\)</span> 换成 <span class="math inline">\(g\)</span> ，就得到了： <span class="math display">\[
\sum_{d\vert n}\mu(d)\sum_{t\vert \frac{n}{d}}g(t)
\]</span> 观察这个式子，<span class="math inline">\(d\times t\)</span> 仍然是 <span class="math inline">\(n\)</span> 的约数。</p>
<p>这个式子相当于对于每一个质因数，决定是乘入 <span class="math inline">\(d\)</span> ，还是 <span class="math inline">\(t\)</span> ，亦或是两者都不乘。</p>
<p>而且 <span class="math inline">\(\mu\)</span> 的取值只与 <span class="math inline">\(d\)</span> 有关，<span class="math inline">\(g\)</span> 的取值只与 <span class="math inline">\(t\)</span> 有关。</p>
<p>所以我们发现先枚举 <span class="math inline">\(d\)</span> 还是先枚举 <span class="math inline">\(t\)</span> 对枚举的结果没有影响。</p>
<p>所以可以交换求和号。 <span class="math display">\[
\sum_{t\vert n}g(t)\sum_{d\vert \frac{n}{t}}\mu(d)
\]</span> 其中，<span class="math inline">\(\sum_{d\vert \frac{n}{t}}\mu(\frac{n}{d})=[\frac{n}{d}=1]\)</span> ，仅在 <span class="math inline">\(d=n\)</span> 时，该式为 1；</p>
<p>仅当 <span class="math inline">\(t\)</span> 为 <span class="math inline">\(n\)</span> 时，<span class="math inline">\(d\)</span> 能取到 <span class="math inline">\(n\)</span> ，所以该式等于 <span class="math inline">\(g(n)\)</span> 。<span class="math inline">\(\square\)</span></p>
<p>我们发现 <span class="math inline">\(f\)</span> 函数是 <span class="math inline">\(g\)</span> 函数与 <span class="math inline">\(I\)</span> 的狄利克雷卷积形式，即 <span class="math inline">\(f=gI\)</span>，那么可以得到 <span class="math inline">\(g=fI^{-1}=f\mu\)</span>。所以有了上面的式子。</p>
<h3 id="其它形式">其它形式</h3>
<p>莫比乌斯反演具有几种形式：</p>
<h4 id="约数式">约数式</h4>
<p><span class="math display">\[
g(n)=\sum_{d\vert n}f(d)\Rightarrow f(n)=\sum_{d\vert n}g(d)\mu(\frac{d}{n})
\]</span></p>
<h4 id="倍数式">倍数式</h4>
<p><span class="math display">\[
g(n)=\sum_{n\vert d}f(d)\Rightarrow f(n)=\sum_{n\vert d}\mu(\frac{d}{n})g(d)
\]</span></p>
<h2 id="例题">例题</h2>
<h3 id="p3455-poi2007-zap-queries"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM0NTU=">P3455 [POI2007] ZAP-Queries</span></h3>
<h4 id="题意">题意</h4>
<p><span class="math inline">\(n(1\le n\le 5\times 10^{4})\)</span> 次询问，每次给定 <span class="math inline">\(a,b,c\)</span> 满足 <span class="math inline">\(1\le d\le a,b\le 5\times 10^{4}\)</span>。求满足 <span class="math inline">\(\gcd(x,y)=d\)</span>，其中 <span class="math inline">\(1\le x\le a,1\le y\le b\)</span> 的二元组 <span class="math inline">\((x,y)\)</span> 数量。</p>
<h4 id="解法">解法</h4>
<p>首先我们可以将 <span class="math inline">\(d\)</span> 的限制去掉。</p>
<p>具体地，这题相当于是要求 <span class="math inline">\(\gcd(x,y)=1\)</span>，其中 <span class="math inline">\(1\le x\le \frac{a}{d}\)</span> 且 <span class="math inline">\(q\le y\le \frac{b}{d}\)</span> 的个数，因为这样的二元组 <span class="math inline">\((x,y)\)</span> 同时乘上 <span class="math inline">\(d\)</span> 之后得到的二元组 <span class="math inline">\((xd,yd)\)</span> 的 gcd 为 <span class="math inline">\(d\)</span>。</p>
<p>接下来考虑如何解决 <span class="math inline">\(\gcd(x,y)=1\)</span> 的问题。为了方便，我们记 <span class="math inline">\(\gcd(a,b)\)</span> 为 <span class="math inline">\((a,b)\)</span>，记 <span class="math inline">\(a\)</span> 为原来的 <span class="math inline">\(a\)</span> 除以 <span class="math inline">\(d\)</span> 向下取整的结果，<span class="math inline">\(b\)</span> 同理，并令 <span class="math inline">\(a\ge b\)</span>。</p>
<p>由于 <span class="math inline">\([\gcd(x,y)=1]=\sum_{d\vert (x,y)}\mu(x,y)\)</span>，这可以根据 <a href="#性质">上面提到的性质</a> 得到。</p>
<p><span class="math inline">\(\sum_{d\vert (x,y)}\mu(x,y)=\sum_{d\vert x,d\vert y}\mu(x,y)\)</span>，因为 <span class="math inline">\(d\)</span> 是 <span class="math inline">\((x,y)\)</span> 的约数的充要条件是 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(d\)</span> 的倍数且 <span class="math inline">\(y\)</span> 是 <span class="math inline">\(d\)</span> 的倍数。 <span class="math display">\[
\sum_{x=1}^{a}\sum_{y=1}^{b}\sum_{d\vert x,d\vert y}\mu(x,y)
\]</span> 我们发现其实有一些 <span class="math inline">\(x,y\)</span> 的 <span class="math inline">\(\gcd\)</span> 是相同的，我们考虑将它们一起计算。</p>
<p>于是我们交换求和号，用我们 OI 的话来说，就是先枚举 <span class="math inline">\(d\)</span>。那么有多少 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(d\)</span> 的倍数呢？显然是 <span class="math inline">\(\lfloor \frac{a}{d}\rfloor\)</span> 了。那么有多少 <span class="math inline">\(y\)</span> 是 <span class="math inline">\(d\)</span> 的倍数呢？显然是 <span class="math inline">\(\lfloor \frac{b}{d}\rfloor\)</span> 了。那么有多少 <span class="math inline">\(x,y\)</span> 都是 <span class="math inline">\(d\)</span> 的倍数呢？显然是 <span class="math inline">\(\lfloor \frac{a}{d}\rfloor \lfloor \frac{b}{d}\rfloor\)</span> 个了。</p>
<p>于是： <span class="math display">\[
\sum_{d=1}^{b}\mu(d)\lfloor \frac{a}{d}\rfloor \lfloor \frac{b}{d}\rfloor
\]</span> 这样子可以做到 <span class="math inline">\(O(b)\)</span> 计算。</p>
<p>我们可以预处理 <span class="math inline">\(\mu\)</span> 并使用 <a href="..\整除分块">整除分块</a> 技巧来在 <span class="math inline">\(O(\sqrt{b})\)</span> 的复杂度内完成计算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> mu[N],sMu[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> pri[N],priTot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">5e4</span>;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;pri[++priTot]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=priTot;++j)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i*pri[j]&gt;<span class="number">5e4</span>)<span class="keyword">break</span>;</span><br><span class="line">      vis[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;mu[i*pri[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">      mu[i*pri[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5e4</span>;++i)sMu[i]=sMu[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;y)<span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="type">int</span> l=<span class="number">1</span>,r;</span><br><span class="line">  <span class="keyword">while</span>(l&lt;=y)&#123;</span><br><span class="line">    r=<span class="built_in">min</span>(x/(x/l),y/(y/l));</span><br><span class="line">    ans+=<span class="number">1ll</span>*(sMu[r]-sMu[l<span class="number">-1</span>])*(x/l)*(y/l);</span><br><span class="line">    l=r+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b,d;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(a/d,b/d));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8EDFS%E5%BA%8F%E4%B8%8ERMQ%E7%9A%84LCA%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8EDFS%E5%BA%8F%E4%B8%8ERMQ%E7%9A%84LCA%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">一种基于DFS序与RMQ的LCA算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-17 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-17T00:00:00+00:00">2023-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 11:13:52" itemprop="dateModified" datetime="2024-03-23T11:13:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>325</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>[非原创] 本文将介绍一种基于预处理DFS序，做到在线 <span class="math inline">\(O(1)\)</span> 回答询问的 LCA 算法。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvQWxleFdlaS9sZW5nLW1lbi1rZS1qaS1kZnMteHUtcWl1LWxjYQ==">参考</span></p>
<p>该算法实现简洁，常数小，速度快；但是维护的信息较少，例如：求到 LCA 路径上除 LCA 外深度最小的节点。</p>
<p>算法流程：首先处理出节点的 dfn 序。假设 <span class="math inline">\(dfn[u]&lt;dfn[v]\)</span>，下面分类讨论：</p>
<ol type="1">
<li><p>u 和 v 之间不存在祖先关系。那么必然是先遍历到 LCA，再到 u，最后到 v。</p>
<p>并且在 <span class="math inline">\(dfn[u]\)</span> 到 <span class="math inline">\(dfn[v]\)</span> 这段区间中，深度最小的点就是 LCA 的某一个儿子。只要求该点父亲即可。</p>
<p>考虑遍历的过程，容易发现其正确性。</p></li>
<li><p>u 和 v 之间一个是另一个的祖先。那么显然是 dfn 序较小的那一个。</p>
<p>但是我们不能知道什么时候是第一种情况，什么时候是第二种情况。</p>
<p>我们考虑，如果出现了第二种情况，求 <span class="math inline">\(dfn[u]\)</span> 到 <span class="math inline">\(dfn[v]\)</span> 之间的深度最小的点，当然是 u ，如果我们求 <span class="math inline">\(dfn[u]+1\)</span> 到 <span class="math inline">\(dfn[v]\)</span> 之间的深度最小点，必然是 u 的某个儿子；同时，如果是第一种情况，这样求也是对的。</p></li>
</ol>
<p>唯一注意 <span class="math inline">\(u=v\)</span> 时要特判。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">前缀函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-16 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-16T00:00:00+00:00">2023-12-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 11:13:52" itemprop="dateModified" datetime="2024-03-23T11:13:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>844</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>对前缀函数的简单介绍。</p>
<p>约定：字符串下标从 1 开始。</p>
<p>前缀函数是是 <span class="math inline">\(\pi\)</span> 数组，<span class="math inline">\(\pi_{i}\)</span> 表示字符串 <span class="math inline">\(s\)</span> 的前缀 <span class="math inline">\(s[1...i]\)</span> 的最长公共 <strong>真</strong> 前后缀（border）长度。</p>
<h1 id="kmp-算法">KMP 算法</h1>
<p>KMP 算法通过预处理前缀函数，加速字符串匹配过程。做到均摊 <span class="math inline">\(O(\lvert S\rvert+\lvert T\rvert)\)</span> 的时间复杂度。</p>
<h1 id="border-的理论">border 的理论</h1>
<p>border 的 border 仍然是 border，正确性显然。</p>
<h2 id="border-与周期">border 与周期</h2>
<p>形式化定义周期：对字符串 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(0 &lt; p \le \lvert S\rvert\)</span> ，有 <span class="math inline">\(s[i]=s[i+p]\)</span> 对所有 <span class="math inline">\(i \in [1,\lvert S\rvert - p]\)</span> 成立，则称 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(S\)</span> 的一个周期。</p>
<p>感性理解：用前 <span class="math inline">\(p\)</span> 个字符向后不断复制，能得到 <span class="math inline">\(s\)</span>，最后一次可以只复制一部分。</p>
<p>如果字符串 <span class="math inline">\(s\)</span> 有长度为 <span class="math inline">\(r\)</span> 的 border ，并且 <span class="math inline">\(r\ge \vert n \rvert /2\)</span> ，那么 <span class="math inline">\(s\)</span> 有周期长度就是 <span class="math inline">\(s-r\)</span> 。这两个条件应该是等价的。</p>
<p>证明：记 <span class="math inline">\(n=\lvert s\rvert\)</span> ，考虑 border ，是由前缀 <span class="math inline">\(s[1...r]\)</span> 和后缀 <span class="math inline">\(s[n-r+1,n]\)</span> 组成的。对于 <span class="math inline">\(i \in [1,r]\)</span> ，都有 <span class="math inline">\(s[i]=s[i+n-r]\)</span> 。由周期的定义可以得证。</p>
<p>最小的周期就是 <span class="math inline">\(s-\pi_{s}\)</span> 。</p>
<hr />
<ol type="1">
<li><p>Periodicity Lemma 周期性引理</p>
<ul>
<li><p>Weak: 若 <span class="math inline">\(p,q\)</span> 为 <span class="math inline">\(s\)</span> 的一个周期，并且 <span class="math inline">\(p+q\le n\)</span> ，那么 <span class="math inline">\(\gcd(p,q)\)</span> 也是一个周期。</p>
<p>证明：假设 <span class="math inline">\(p&gt;q\)</span> ，设 <span class="math inline">\(d=p-q\)</span> ，那么分类讨论：</p>
<ul>
<li><span class="math inline">\(i \le q\)</span> ，此时 <span class="math inline">\(s[i]=s[i+p]=s[i+p-q]=s[i+d]\)</span></li>
</ul></li>
<li><p><span class="math inline">\(i&gt;q\)</span> ，此时 <span class="math inline">\(s[i]=s[i-q]=s[i+p-q]=s[i+d]\)</span></p>
<p>注意到两种情况均可以导出 <span class="math inline">\(s[i]=s[i+d]\)</span> ，即 <span class="math inline">\(d\)</span> 也是周期。 更相减损即可得到 <span class="math inline">\(\gcd(p,q)\)</span> 是周期。 <span class="math inline">\(\square\)</span></p>
<p>回顾一下证明过程，之所以要求 <span class="math inline">\(p+q\le n\)</span> ，是在第一类中，<span class="math inline">\(s[i]=s[i+p]\)</span> 一步，如果 <span class="math inline">\(p+q&gt;n\)</span> ，就不满足周期的性质。</p>
<p>证明的核心围绕着周期的定义 <span class="math inline">\(s[i]=s[i+r]\)</span> 进行，目标是导出 <span class="math inline">\(s[i+d]\)</span> ，最后使用更相减损完成证明，巧妙。</p></li>
<li><p>Strong: 若 <span class="math inline">\(p,q\)</span> 为 <span class="math inline">\(s\)</span> 的一个周期，并且 <span class="math inline">\(p+q\le n+\gcd(p,q)\)</span> ，那么 <span class="math inline">\(\gcd(p,q)\)</span> 也是一个周期。</p>
<p>发现上面的证明此时会出现问题，因为 <span class="math inline">\(s[i+p]\)</span> 可能超过 <span class="math inline">\(n\)</span> 。</p>
<p><del>参考</del> 照搬 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84OTM4NTM2MA==">Periodicity Lemma - 知乎</span></p>
<ol type="1">
<li>按照上面的方法证明对于长度是 <span class="math inline">\(n-q\)</span> 的前缀/后缀均是循环节。因为注意到 <span class="math inline">\(\gcd(p,q)\le q\)</span> ，必然满足上述证明过程。</li>
<li>可以证明 <span class="math inline">\(q\le n-q\)</span> （这是怎么证明的呢？），所以 <span class="math inline">\(s\)</span> 的前 <span class="math inline">\(q\)</span> 个字符中，<span class="math inline">\(\gcd(p,q)\)</span> 仍然是其循环节。因为 <span class="math inline">\(\gcd(p,q)\)</span> 是 <span class="math inline">\(q\)</span> 的约数，所以前缀 <span class="math inline">\(q\)</span> 是由若干个完整的循环节拼成的。</li>
<li>因为可以将 <span class="math inline">\(s\)</span> 拆分成 <span class="math inline">\(q\)</span> 的前缀和 <span class="math inline">\(n-q\)</span> 的后缀，前缀是由若干段完整循环节构成的，而后半段也是周期。所以 <span class="math inline">\(\gcd(p,q)\)</span> 也是一个周期。</li>
</ol>
<p>这个证明过程的严谨推理仍然有待分析。</p></li>
</ul></li>
<li><p>字符串 <span class="math inline">\(s\)</span> 所有长度超过 <span class="math inline">\(\lvert s\rvert / 2\)</span> 的 border 的长度是等差数列。</p>
<p>假设有一个长度为 <span class="math inline">\(n-p\)</span> 的 border 和一个长度为 <span class="math inline">\(n-q\)</span> 的 border ，其中 <span class="math inline">\(p,q \le n/2\)</span> ，那么根据弱周期性引理，可以得到 <span class="math inline">\(\gcd(p,q)\)</span> 是一个周期，那么 <span class="math inline">\(n-\gcd(p,q)\)</span> 是一个 border。</p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/Multiplicative_Functions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/Multiplicative_Functions/" class="post-title-link" itemprop="url">Multiplicative Functions</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-15 00:00:00" itemprop="dateCreated datePublished" datetime="2023-12-15T00:00:00+00:00">2023-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 11:13:52" itemprop="dateModified" datetime="2024-03-23T11:13:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>351</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Introduction about multiplicative functions.</p>
<h1 id="multiplicative-functions">Multiplicative Functions</h1>
<p>Function <span class="math inline">\(f(x)\)</span> satisfied <span class="math inline">\(f(xy)=f(x)\cdot f(y), \gcd(x,y)=1\)</span> , then we call <span class="math inline">\(f(x)\)</span> a multiplicative function.</p>
<ol type="1">
<li><p><span class="math display">\[
d(n)=\sum_{y|n}y,\forall n\in \mathbb{N}
\]</span></p>
<p><span class="math inline">\(d(n)\)</span> is a multiplicative function.</p>
<p>Proof</p>
<p>Constant function <span class="math inline">\(f(x)=x\)</span> is clearly a multiplicative function.</p>
<p>Consider n,m satisfied <span class="math inline">\(\gcd(n,m)=1\)</span> , then we have:</p>
<p><span class="math display">\[
\begin{aligned}
d(nm)&amp;=\sum_{x|nm}f(x)\\
&amp;=\sum_{x|n}f(x)\sum_{x|m}f(x)\\
&amp;=d(n)\cdot d(m)
\end{aligned}
\]</span></p>
<p>But <span class="math inline">\(f(x)\)</span> is not a complete multiplicative function, since <span class="math inline">\(f(2)=3\)</span>, <span class="math inline">\(f(4)=7\)</span>, but <span class="math inline">\(f(8)\not =21\)</span> .</p></li>
<li><p>Euler function <span class="math display">\[
\varphi(n)=\sum_{\gcd(d,n)=1,1\le d\le n} 1,\forall n\in \mathbb{Z}
\]</span> is a multiplicative function.</p>
<p>Proof</p>
<p>We know if <span class="math inline">\(\gcd(t,nm)=1\)</span>, then <span class="math inline">\(\gcd(t,n)=1,\gcd(t,m)=1\)</span>.</p>
<p>And if <span class="math inline">\(\gcd(t,n)=1,\gcd(t,m)=1\)</span>, then <span class="math inline">\(\gcd(t,nm)=1\)</span>.</p>
<p>So let us construct a matrix with n lines m rows, like this <span class="math display">\[
\begin{matrix}
1&amp;2&amp;3&amp;\cdots&amp;r&amp;\cdots&amp;m\\
m+1&amp;m+1&amp;m+3&amp;\cdots&amp;m+r&amp;\cdots&amp;2m\\
2m+1&amp;2m+2&amp;2m+3&amp;\cdots&amp;2m+r&amp;\cdots&amp;3m\\
\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;&amp;\vdots\\
(n-1)m+1&amp;(n-1)m+2&amp;(n-1)m+3&amp;\cdots&amp;(n-1)m+r&amp;\cdots&amp;nm\\
\end{matrix}
\]</span> In line 1, we can find exactly <span class="math inline">\(\varphi(m)\)</span> numbers r satisfied <span class="math inline">\(\gcd(r,m)=1\)</span> .</p>
<p>In row r, we have <span class="math inline">\(r,m+r,2m+r,\cdots,(n-1)m+r\)</span> , they constitute a complete system of residues. So there are exactly <span class="math inline">\(\varphi(n)\)</span> numbers satisfied <span class="math inline">\(gcd(r,n)=1\)</span>.</p>
<p>So there are <span class="math inline">\(nm\)</span> numbers satisfied <span class="math inline">\(\gcd(r,nm)=1\)</span>.</p>
<p>And this is the meaning of <span class="math inline">\(\varphi(n)\)</span>.</p></li>
<li><p>Legendre symbol, define as <span class="math display">\[
\left(\frac{a}{p}\right)=\begin{cases}
    0,  &amp; p\mid a,\\
    1,  &amp; \text{a is a quadratic residuce modulo p} \\
    -1, &amp; \text{a is a quadratic nonresiduce modulo p}.\\
\end{cases}
\]</span> p is an odd prime.</p></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%A7%91%E6%8A%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%A7%91%E6%8A%80/" class="post-title-link" itemprop="url">多项式科技</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-26 00:00:00" itemprop="dateCreated datePublished" datetime="2023-10-26T00:00:00+00:00">2023-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 11:13:52" itemprop="dateModified" datetime="2024-03-23T11:13:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文介绍了一些多项式算法。</p>
<h1 id="快速傅里叶变换">快速傅里叶变换</h1>
<h2 id="简单理解">简单理解</h2>
<p>快速解决多项式乘法的算法。</p>
<h2 id="从系数表示到点值表示">从系数表示到点值表示</h2>
<h3 id="系数表示法">系数表示法</h3>
<p>表示一个多项式 F(x) 有两种方法，一种是系数表示，即 <span class="math inline">\(F(x)=\sum_{i=0}^{k}a_{k}\cdot x^{k}\)</span> ，其中的 <span class="math inline">\(a_{i}\)</span> 即为次数为 <span class="math inline">\(i\)</span> 的项的系数。</p>
<p>我们计算多项式乘法， <span class="math inline">\(A(x)\times B(x)\)</span> ，记结果为 <span class="math inline">\(C\)</span> ，那么 <span class="math inline">\(C\)</span> 可以这么算： <span class="math display">\[
C[k]=\sum_{i+j=k}{A[i]B[j]}
\]</span> 其中 <span class="math inline">\(A[i]\)</span> 表示多项式 <span class="math inline">\(A(x)\)</span> 的第 <span class="math inline">\(i\)</span> 项。</p>
<p>这称为加法卷积。</p>
<blockquote>
<p>如果有 <span class="math display">\[
C[k]=\sum_{i\oplus j=k}{A[i]B[j]}
\]</span> 其中 <span class="math inline">\(\oplus\)</span> 为一种运算，那么称这个操作为卷积。</p>
</blockquote>
<p>不难发现，这样运算的复杂度为 <span class="math inline">\(O(n^2)\)</span> 的，其中 <span class="math inline">\(n\)</span> 为多项式的次数。</p>
<h3 id="点值表示法">点值表示法</h3>
<p>我们都知道，两点确定一条直线，所以如果知道两个点的坐标就可以确定一个一次函数，也能确定这个一次函数的系数。</p>
<p>有一个推论：平面上的 <span class="math inline">\(n+1\)</span> 个点可以确定一个 <span class="math inline">\(n\)</span> 次的多项式。</p>
<p>那么我们发现，如果我们给出 <span class="math inline">\(x\)</span> 坐标，那么根据多项式就可以求出 <span class="math inline">\(y\)</span> 坐标了。</p>
<p>如果对于一个多项式，我们得到了一些点值 <span class="math inline">\((x_0,A(x_0)),(x_1,A(x_1)),(x_2,A(x_2)),\cdots\)</span> ，与另一个多项式的点值 <span class="math inline">\((x_0,B(x_0)),(x_1,B(x_1)),(x_2,B(x_2)),\cdots\)</span> ，现在我们想要得到这两个多项式的乘积 <span class="math inline">\(C(x)\)</span> ，就可以知道乘积的点值表示为 <span class="math inline">\((x_0,A(x_0)\times B(x_0)),(x_1,A(x_1)\times B(x_1)),(x_2,A(x_2) \times B(x_2)),\cdots\)</span> 。也就是说，乘积多项式的点值表示可以由这两个多项式相乘得到。</p>
<p>但是有个小问题，乘积多项式最高是 2n 次的，需要 2n+1 个点，那就多带入几个点值就可以了。</p>
<p>这样计算乘法就可以在 <span class="math inline">\(O(n)\)</span> 的时间复杂度内完成。</p>
<h3 id="总结">总结</h3>
<p>如果我们能够知道如何将点值表示快速转换成系数表示，就可以快速完成多项式乘法了。</p>
<h2 id="复数前置知识">复数前置知识</h2>
<p><a href="..%20/数学基础#复数">见数学中复数部分</a></p>
<h2 id="dft">DFT</h2>
<p>将系数表达转换成点值表达。</p>
<p>由于我们可以任意代入 x 的值，为了使得性质更强，我们代入 <span class="math inline">\(\omega_{n}^{k}\)</span> 。</p>
<p>我们要同时计算代入 <span class="math inline">\(n\)</span> 个单位根的值，直接做是 <span class="math inline">\(O(n^2)\)</span> 的。</p>
<p>下面分治计算 <span class="math inline">\(F(\omega_{n}^{k})\)</span> 的值。要求 n 必须为 2 的整数次幂，如果不够就补充系数为 0 的项。</p>
<p>建立两个多项式 <span class="math inline">\(F_{odd}\)</span> 与 <span class="math inline">\(F_{even}\)</span> ，其系数分别为 <span class="math inline">\(F\)</span> 的奇数项与偶数项的系数。（定义第 i 项是第 i-1 次项）</p>
<p>那么容易发现有 <span class="math inline">\(F(x)=F_{odd}(x^2)+xF_{even}(x^2)\)</span> 。</p>
<p>对于多项式的前 n/2 项， <span class="math inline">\(0 \le k &lt; n/2\)</span> ，我们对于第 <span class="math inline">\(k\)</span> 项代入 <span class="math inline">\(x=\omega_{n}^{k}\)</span> ： <span class="math display">\[
F(\omega_{n}^{k})=F_{odd}((\omega_{n}^{k})^2)+\omega_{n}^{k}F_{even}((\omega_{n}^{k})^2)
\]</span> 对于多项式的后 n/2 项， <span class="math inline">\(0 \le k &lt; n/2\)</span> ，我们对于第 <span class="math inline">\(n/2+k\)</span> 项代入 <span class="math inline">\(x=\omega_{n}^{n/2+k}\)</span> ： <span class="math display">\[
F(\omega_{n}^{n/2+k})=F_{odd}((\omega_{n}^{n/2+k})^2)+\omega_{n}^{n/2+k}F_{even}((\omega_{n}^{n/2+k})^2)
\]</span> 这两个式子囊括了式子的所有项。</p>
<p>对于前一个式子，我们有： <span class="math display">\[
\begin{aligned}
F(\omega_{n}^{k})&amp;=F_{odd}((\omega_{n}^{k})^2)+\omega_{n}^{k}F_{even}((\omega_{n}^{k})^2)\\
&amp;=F_{odd}(\omega_{n}^{2k})+\omega_{n}^{k}F_{even}(\omega_{n}^{2k}) \\
&amp;=F_{odd}(\omega_{n/2}^{k})+\omega_{n}^{k}F_{even}(\omega_{n/2}^{k}) \\
\end{aligned}
\]</span> 对于后一个式子，我们有： <span class="math display">\[
\begin{aligned}
F(\omega_{n}^{n/2+k})&amp;=F_{odd}((\omega_{n}^{n/2+k})^2)+\omega_{n}^{n/2+k}F_{even}((\omega_{n}^{n/2+k})^2) \\
&amp;=F_{odd}(\omega_{n}^{n+2k})+\omega_{n}^{n/2+k}F_{even}(\omega_{n}^{n+2k}) \\
&amp;=F_{odd}(\omega_{n}^{2k})+\omega_{n}^{n/2+k}F_{even}(\omega_{n}^{2k})\\
&amp;=F_{odd}(\omega_{n/2}^{k})+\omega_{n}^{n/2+k}F_{even}(\omega_{n/2}^{k})\\
&amp;=F_{odd}(\omega_{n/2}^{k})-\omega_{n}^{k}F_{even}(\omega_{n/2}^{k})
\end{aligned}
\]</span> 由此可以发现两个式子中，<span class="math inline">\(F_{odd}\)</span> 与 <span class="math inline">\(F_{even}\)</span> 需要代入的 x 都是同一个值，只需要求一次。并且对于 <span class="math inline">\(F_{odd}\)</span> 与 <span class="math inline">\(F_{even}\)</span> 来说，计算它们的点值表达的过程与计算 <span class="math inline">\(F\)</span> 的本质相同，所以可以分治计算。</p>
<p>而且当多项式只有一个项时，<span class="math inline">\(\omega_{1}^{0}=1\)</span> 。所以很容易合并。</p>
<h2 id="idft">IDFT</h2>
<p>如果知道了点值表示的序列 <span class="math inline">\(G\)</span> ，如何将其转换为系数表示法。</p>
<p>此章节中 <span class="math inline">\(A(i)\)</span> 表示多项式 <span class="math inline">\(A\)</span> 第 <span class="math inline">\(i\)</span> 项的系数。</p>
<p>结论：如果有 <span class="math display">\[
G(k)=\sum_{i=0}^{n-1}(\omega_{n}^{k})^{i}F(i)
\]</span> 那么 <span class="math display">\[
n\times F(k)=\sum_{i=0}^{n-1}(\omega_{n}^{-i})^{k}G(i)
\]</span> 其实等式右边和 DFT 的过程挺像，只不过是将 <span class="math inline">\(\omega_{n}^{i}\)</span> 换成了 <span class="math inline">\(\omega_{n}^{-i}\)</span> 。</p>
<p>证明： <span class="math display">\[
\begin{aligned}
\sum_{i=0}^{n-1}(\omega_{n}^{-i})^{k}G(i)&amp;=\sum_{i=0}^{n-1}[\sum_{j=0}^{n-1}(\omega_{n}^{i})^jF(j)(\omega_{n}^{-i})^{k}] \\
&amp;=\sum_{i=0}^{n-1}[\sum_{j=0}^{n-1}\omega_{n}^{i(j-k)}F(j)]
\end{aligned}
\]</span> 其中第一步是将 G(i) 直接代入用 F 表达。</p>
<p>考虑化简这个式子。</p>
<p>考虑对于其中一个 <span class="math inline">\(j\)</span> ， <span class="math display">\[
\sum_{i=0}^{n-1}\omega_{n}^{i(j-k)}F(j)=F(j)\sum_{i=0}^{n-1}(\omega_{n}^{j-k})^{i}
\]</span> 我们记 <span class="math inline">\(a=j-k\)</span> ， <span class="math inline">\(t=\omega_{n}^{a}\)</span> ， <span class="math inline">\(s=\sum_{i=0}^{n-1}t^i\)</span></p>
<p>当 <span class="math inline">\(j = k\)</span> 时，容易发现 s=n 。</p>
<p>当 <span class="math inline">\(j \not =k\)</span> 时，有 <span class="math inline">\(ts-s=t^{n}-t^{0}\)</span> （错位相减）。即 <span class="math inline">\(s=\frac{t^{n}-t^{0}}{t-1}\)</span> ，由于 <span class="math inline">\(t^{n}=t^{0}=1\)</span> ，所以 <span class="math inline">\(s=0\)</span> 。</p>
<p>综上所述，整个式子的总和为 <span class="math inline">\(n\times F(k)\)</span> 。</p>
<p>于是，我们完成了证明，类似 DFT 的做法，我们只需要将单位根换一换，就可以完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> doub=<span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e6</span>;</span><br><span class="line"><span class="type">const</span> doub PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cpl</span>&#123;</span><br><span class="line">  doub x,y;</span><br><span class="line">  <span class="built_in">Cpl</span>(doub _x=<span class="number">0</span>,doub _y=<span class="number">0</span>)&#123;x=_x;y=_y;&#125;</span><br><span class="line">  Cpl <span class="keyword">operator</span>+(Cpl a)&#123;Cpl res;res.x=x+a.x;res.y=y+a.y;<span class="keyword">return</span> res;&#125;</span><br><span class="line">  Cpl <span class="keyword">operator</span>-(Cpl a)&#123;Cpl res;res.x=x-a.x;res.y=y-a.y;<span class="keyword">return</span> res;&#125;</span><br><span class="line">  Cpl <span class="keyword">operator</span>*(Cpl a)&#123;<span class="keyword">return</span> &#123;x*a.x-y*a.y,x*a.y+y*a.x&#125;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> id_all[N],tmp[N]; <span class="comment">//记录编号对应原来的第几位</span></span><br><span class="line">Cpl newg[N]; <span class="comment">//临时数组，记录合并后当前的点值表示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(<span class="type">int</span>* id,Cpl* f,Cpl* g,<span class="type">int</span> len,<span class="type">bool</span> op)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;g[<span class="number">0</span>]=f[id[<span class="number">0</span>]];<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="number">2</span>)tmp[cnt++]=id[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i+=<span class="number">2</span>)tmp[cnt++]=id[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)id[i]=tmp[i];</span><br><span class="line">  <span class="type">int</span> half=len/<span class="number">2</span>;<span class="built_in">FFT</span>(id,f,g,half,op);<span class="built_in">FFT</span>(id+half,f,g+half,half,op);</span><br><span class="line">  Cpl w_mul=&#123;<span class="built_in">cos</span>(<span class="number">2</span>*PI/len),<span class="built_in">sin</span>(<span class="number">2</span>*PI/len)*(op?<span class="number">-1</span>:<span class="number">1</span>)&#125;,w=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">  Cpl* gl=g;Cpl* gr=g+half;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;half;++i)&#123;</span><br><span class="line">    newg[i]=gl[i]+gr[i]*w;</span><br><span class="line">    newg[i+half]=gl[i]-gr[i]*w;</span><br><span class="line">    w=w*w_mul;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)g[i]=newg[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="number">2</span>)tmp[i]=id[i/<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i+=<span class="number">2</span>)tmp[i]=id[i/<span class="number">2</span>+half];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)id[i]=tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">Cpl G[N]; <span class="comment">//乘积多项式的系数表示</span></span><br><span class="line">Cpl Gs[<span class="number">2</span>][N]; <span class="comment">//两个原多项式的系数表示</span></span><br><span class="line">Cpl f[<span class="number">2</span>][N]; <span class="comment">//多项式的系数</span></span><br><span class="line">Cpl g[N]; <span class="comment">//得到的系数表示 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,m,orin,orim,z;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  ++n;++m;</span><br><span class="line">  orin=n;orim=m;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t),f[<span class="number">0</span>][i].x=t;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t),f[<span class="number">1</span>][i].x=t;</span><br><span class="line">  z=<span class="number">1</span>&lt;&lt;(<span class="type">int</span>)(<span class="built_in">log2</span>(n+m<span class="number">-1</span>)+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;z;++i)id_all[i]=i;</span><br><span class="line">  <span class="built_in">FFT</span>(id_all,f[<span class="number">0</span>],g,z,<span class="number">0</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;z;++i)Gs[<span class="number">0</span>][i]=g[i];</span><br><span class="line">  <span class="built_in">FFT</span>(id_all,f[<span class="number">1</span>],g,z,<span class="number">0</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;z;++i)Gs[<span class="number">1</span>][i]=g[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;z;++i)G[i]=Gs[<span class="number">0</span>][i]*Gs[<span class="number">1</span>][i];</span><br><span class="line">  <span class="built_in">FFT</span>(id_all,G,g,z,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,y=orin+orim<span class="number">-1</span>;i&lt;y;++i)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,(<span class="type">int</span>)(g[i].x/z+<span class="number">0.5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种简单的实现方式。</p>
<h2 id="优化">优化</h2>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/%E6%9D%82%E9%A2%98%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E6%9D%82%E9%A2%98%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">杂题总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-10-01 00:00:00" itemprop="dateCreated datePublished" datetime="2023-10-01T00:00:00+00:00">2023-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 11:13:52" itemprop="dateModified" datetime="2024-03-23T11:13:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>做过的一些杂题的总结。</p>
<h1 id="luogu-p2824-排序"><span class="exturl" data-url="aHR0cHM6Ly92anVkZ2UubmV0L3Byb2JsZW0v5rSb6LC3LVAyODI0">Luogu-P2824 排序</span></h1>
<h2 id="solution">Solution</h2>
<p>观察可以发现我们最后只需要知道位置 q 上的值即可。但是如果暴力做是 n 方级别的。</p>
<p>可以二分最后位置上 q 是多少，那么将排列中小于 q 的值设为 0 ，大于等于 q 的设为 1 。此时就将升序降序排序转换成了区间覆盖问题。</p>
<h1 id="cf149d---coloring-brackets"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vMTQ5L0Q=">CF149D - Coloring Brackets</span></h1>
<h2 id="题意">题意</h2>
<p>给出一个合法括号序列，要求给 <strong>其中一些</strong> 括号染上 <code>Red / Blue</code> 两种颜色之一，满足</p>
<ol type="1">
<li>每一对括号中恰好一个染色了。</li>
<li>相邻的两个括号不能同色，可以都不染色。</li>
</ol>
<p>求染色方案数。<span class="math inline">\(\lvert S \rvert \le 700\)</span> 。</p>
<h2 id="解法">解法</h2>
<p>我太菜了，绿的区间DP都不会了。</p>
<p>可以设 <span class="math inline">\(f[l][r]\)</span> 表示染色在 <span class="math inline">\([l,r]\)</span> 中的括号的方案数，要求 <span class="math inline">\(s[l,r]\)</span> 是合法括号序列。但是由于染色的限制条件，这样设计状态难以转移。</p>
<p>我们发现当合并两个区间时，我们只需要考虑左右两端的颜色。所以可以增加两维，表示左右两端染了什么颜色。</p>
<p>转移时考虑与 <span class="math inline">\(l\)</span> 匹配的右括号在哪。</p>
<p>如果恰好是 <span class="math inline">\(r\)</span> ，那么就可以从 <span class="math inline">\(f[l+1][r-1]\)</span> 转移而来。</p>
<p>否则假如在 <span class="math inline">\(k\)</span> ，那么就可以从 <span class="math inline">\(f[l][k]\times f[k+1][r]\)</span> 转移而来。</p>
<p>使用记忆化搜索会更为方便，能够保证每次搜索的区间合法。</p>
<h2 id="总结">总结</h2>
<p>思考这道题时只是很板地想设 <span class="math inline">\(f[l][r]\)</span> ，于是不知道如何转移颜色。没有想到增加维度的操作。</p>
<p>另外，设计状态时，没有考虑在一个合法的括号序中，当时想的是任意区间。</p>
<h1 id="cf1025d---recovering-bst"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vMTAyNS9E">CF1025D - Recovering BST</span></h1>
<h2 id="tag">Tag</h2>
<p>*2100, DP, 紫</p>
<h2 id="题意-1">题意</h2>
<p>给出一个升序序列，问这个序列能否建出一棵二叉搜索树，满足任意一条边的两个点的值GCD大于一。<span class="math inline">\(n\le 700\)</span> 。</p>
<h2 id="解法-1">解法</h2>
<p>二叉搜索树的中序遍历就是升序序列，所以我们可以将这个问题转换成序列上的问题。一个子树就是一个区间。</p>
<p>可以设 <span class="math inline">\(f[l][r][k]\)</span> 表示区间 <span class="math inline">\([l,r]\)</span> ，根是 <span class="math inline">\(k\)</span> ，能不能建出一棵 BST 。</p>
<p>不难发现这样做是 <span class="math inline">\(O(n^4)\)</span> 的，感觉常数小很可以过。但是没过。</p>
<p>考虑优化。我们发现一个子树的根的父亲节点必定是这个区间 <span class="math inline">\([l,r]\)</span> 的 <span class="math inline">\(l-1\)</span> 或 <span class="math inline">\(r+1\)</span> 。</p>
<blockquote>
<p>为什么？考虑一个区间的一个位置，如果这个位置是根，那么区间左半部分就是左子树，右半部分就是右子树。如果 <span class="math inline">\([l,r]\)</span> 为区间的左半子树，那么父亲节点就是 <span class="math inline">\(r+1\)</span> ，否则就是 <span class="math inline">\(l-1\)</span> 。</p>
</blockquote>
<p>于是我们可以设 <span class="math inline">\(f[l][r][0/1]\)</span> 表示区间 <span class="math inline">\([l,r]\)</span> 能否作为父亲节点的左/右子树，也就是子树 <span class="math inline">\([l,r]\)</span> 的根的父亲节点是 <span class="math inline">\(r+1\)</span> 还是 <span class="math inline">\(l-1\)</span> 。</p>
<p>当我们计算 <span class="math inline">\(f[l][r][0/1]\)</span> 时，枚举 <span class="math inline">\([l,r]\)</span> 的根 <span class="math inline">\(k\)</span> ，那么就有左子树 <span class="math inline">\([l,k-1]\)</span> 和右子树 <span class="math inline">\([k+1,r]\)</span> 。如果 <span class="math inline">\(f[l][k-1][0]\)</span> 为真，并且 <span class="math inline">\(f[k+1][r][1]\)</span> 为真，那么说明 <span class="math inline">\(k\)</span> 可以作为这两棵子树的根，如果同时 <span class="math inline">\(k\)</span> 能够与 <span class="math inline">\(l-1\)</span> 相连，那么说明 <span class="math inline">\(f[l][r][1]\)</span> 为真了。</p>
<p>这样做状态数是 <span class="math inline">\(O(n^2)\)</span> ，转移是线性的。</p>
<h1 id="cf888f---connecting-vertices"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vODg4L0Y=">CF888F - Connecting Vertices</span></h1>
<h2 id="tag-1">Tag</h2>
<p>*2500, DP, 紫</p>
<h2 id="题意-2">题意</h2>
<p>给出一个整数 <span class="math inline">\(n\)</span> ，和一个由 01 构成的矩阵 <span class="math inline">\(a_{i,j}\)</span> 。表示有一个正 <span class="math inline">\(n\)</span> 边形，删去所有边，留下点。每一次需要连接两个点，总共连接 <span class="math inline">\(n-1\)</span> 条边，边不得交叉。使得这些点连通。如果 <span class="math inline">\(a_{i,j}\)</span> 为 1 的两个点不能直接相连，求方案总数。 <span class="math inline">\(n \le 700\)</span></p>
<h2 id="题外话">题外话</h2>
<p>想这道题的时候，把题目记错了，以为不一定要连通，寻思挺多方案，似乎难以 DP 。结果发现是要连成一棵树。</p>
<h2 id="解法-2">解法</h2>
<p>700 ，区间DP。</p>
<p>发现如果点 i 与点 j 直接或间接连接了，那么点 i 到点 j 必定连成了一棵树。</p>
<p>考虑如果没有连成一棵树，说明这或许超过了 n-1 条边，这显然会让最后没法连通。或许没有连通，那么这个点已经没法再连接起来了。</p>
<p>考虑设 <span class="math inline">\(f[i][j]\)</span> 表示点 i 与点 j 之间直接或间接连接，那么可以想到转移：</p>
<ol type="1">
<li><p>如果点 i 与点 j 直接相连，此时要求满足 <span class="math inline">\(a_{i,j}=1\)</span> ，则有： <span class="math display">\[
f[i][j]=\sum_{k=i}^{j-1}f[i][k]\times f[k+1][j]
\]</span> 意即 i 和 j 已经直接相连了，不能在另一条路连接，所以在 k 处断开。</p></li>
<li><p>如果 i 和 j 间接相连，则有： <span class="math display">\[
f[i][j]=\sum_{k=i+1}^{j-1}f[i][k]\times f[k][j]
\]</span> 意即从某一个点 k 将 i, j 连接起来。</p></li>
</ol>
<p>然而这样会算重。</p>
<p>考虑这种情况：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/83lyj5x8.png" /></p>
<p>此时按照 2 的情况转移，在 k 处会被计算一次，在 k' 处会被计算一次，那么就会重复。</p>
<p>如何避免这种情况？我们要求 i 必须与 k 直接相连，那么上述情况就只会在 i+1 处被计算一次，就不会算重了。</p>
<p>所以可以设 <span class="math inline">\(f[i][j][0/1]\)</span> 表示 i 和 j 是直接相连还是间接相连，于是就有： <span class="math display">\[
f[i][j][1]=\sum_{k=i}^{j-1}(f[i][k][0]+f[i][k][1])\times(f[k+1][j][0]+f[k+1][j][1])
\]</span> 与 <span class="math display">\[
f[i][j][0]=\sum_{k=i}^{j-1}f[i][k][1]\times(f[k+1][j][0] + f[k+1][j][1])
\]</span></p>
<h1 id="cf1889c1---doremys-drying-plan"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vMTg4OS9DMQ==">CF1889C1 - Doremy's Drying Plan</span></h1>
<h2 id="题意-3">题意</h2>
<p>给出若干个区间，要求删去这些区间任何 k 个，使得没有任何区间被覆盖的点数最多，求最多点数。</p>
<p>数据范围：点范围、区间数2e5，简单版下k=2</p>
<h2 id="解法-3">解法</h2>
<h3 id="我的解法">我的解法</h3>
<p>考虑到只有被覆盖不超过两次的点可能对答案有贡献，不妨求出这些点被哪些区间覆盖。按覆盖次数讨论：</p>
<p>0次，此时一定会对答案产生贡献。</p>
<p>1次，此时在选中这一个区间时对答案产生贡献。</p>
<p>2次，此时在两个区间都被选中时对答案产生贡献。</p>
<p>考虑将恰好被覆盖两次的点，被哪两个区间覆盖求出（利用线段树），进行双关键字排序，那么最后两个区间都被选中的情况便会相邻，只需要统计连续的点，满足覆盖它们的两个区间都相同的个数即可。再加上这两个区间覆盖1次的点的贡献，与被覆盖0次的点的贡献，取最大值即答案。</p>
<h3 id="题解做法">题解做法</h3>
<p>覆盖0次的点一定会对答案产生贡献，假设是 <span class="math inline">\(A\)</span> ，选定两个区间覆盖的点如果是 <span class="math inline">\(B\)</span> 。那么我们的目标就是求 <span class="math inline">\(A+\max{B}\)</span> 。</p>
<p>考虑两个区间的关系：</p>
<ul>
<li>如果两个区间相离，那么贡献就是被覆盖1次的点的个数。</li>
<li>如果两个区间相交，那么贡献就是被覆盖1次的点的个数减去被覆盖2次的点的个数。枚举每一个被覆盖两次的点，那么就可以得到是哪两个区间相交。即可计算答案。</li>
</ul>
<h1 id="cf1872g---replace-with-product"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE4NzIvcHJvYmxlbS9H">CF1872G - Replace With Product</span></h1>
<h2 id="题意-4">题意</h2>
<p>给出一个序列，需要将序列中的一段数字替换成它们的乘积，求操作的区间，使得能得到最后可能的最大和。</p>
<p>序列长度是 2e5，数字范围是 [1,1e9]</p>
<h2 id="做法">做法</h2>
<p>典型的程怀德题。</p>
<p>很显然是如果选择的区间，前缀为一段1，或者后缀为一段1，显然不优，所以可以按照1的位置将这些区间分出来，但是有一些区间是可以跨过中间的1合并的。直接做难以合并。</p>
<p>考虑到数字的乘积可能非常大，写高精度不现实，没法比较两个区间的大小。所以考虑从乘积上面入手。</p>
<p>如果乘积太大了，我们发现此时每当我们乘上假如一个非1的数字，那么最后的和会变大许多，这个情况下，我们就会将所有的数字乘起来，除了前缀1和后缀1。</p>
<p>如何定义“太大了”？如果有所有数字的乘积超过 <span class="math inline">\(2\times n\)</span> ，那么此时如果我们不合并其中某一个非1的数字，答案会变少至少 <span class="math inline">\(n\)</span> ，这比1的贡献加起来要多，因为1的个数不可能超过 <span class="math inline">\(n\)</span> 。</p>
<p>如果乘积没有超过 <span class="math inline">\(2\times n\)</span> ，那么就将所有非1的段弄出来，这最多只有 <span class="math inline">\(O(\log n)\)</span> 个，暴力枚举从哪个段合并到哪个段，造成的贡献谁更大，用一些前缀和，前缀积维护一下就可以了。</p>
<h1 id="cf1900d---small-gcd"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vMTkwMC9E">CF1900D - Small GCD</span></h1>
<h2 id="题外话-1">题外话</h2>
<p>这题只有2000？</p>
<h2 id="题意-5">题意</h2>
<p>定义函数 <span class="math inline">\(f(a,b,c)\)</span> 的值为 <span class="math inline">\(a,b,c\)</span> 中较小的两个数字的 <span class="math inline">\(\gcd\)</span> ，求对于给定序列，所有三元组的 <span class="math inline">\(f\)</span> 之和。</p>
<p>值域 <span class="math inline">\(10^{5}\)</span> ，<span class="math inline">\(n \le 8\times 10^4\)</span> 。</p>
<h2 id="做法-1">做法</h2>
<p>既然值域这么小那么和值域当然相关了。</p>
<p>我们发现如果我们能够计算出 <span class="math inline">\(cnt_{d}\)</span> ，表示 <span class="math inline">\(f\)</span> 函数值为 <span class="math inline">\(d\)</span> 的有多少个，那么答案就是 <span class="math inline">\(cnt_{d}\times d\)</span> 的和。</p>
<p>但是直接求 <span class="math inline">\(cnt_{d}\)</span> 不好求，这涉及到 gcd 恰好为 <span class="math inline">\(d\)</span> 。考虑转化一下：我们从大到小枚举，求 gcd 为 d 的倍数的有多少个，那么可以将这个数减去 <span class="math inline">\(cnt_{i}\)</span> ，<span class="math inline">\(i\)</span> 是 <span class="math inline">\(d\)</span> 的一个倍数，就可以得到恰好的。这个技巧很好。并且因为调和级数，复杂度是 <span class="math inline">\(O(m \log m)\)</span> 的，其中 <span class="math inline">\(m\)</span> 是值域。</p>
<p>如何求 gcd 为 d 的倍数有多少个？我们可以处理出，哪些 <span class="math inline">\(a_{i}\)</span> 有约数 <span class="math inline">\(d\)</span> ，那么我们只需要枚举三元组中的次大值，可以很快求出最小值能够选择的个数与最大值能够选择的方案数，满足 gcd 一定为 d 的倍数。</p>
<p>由于值域范围内约数最多的数字只有 128 个，不会 T。</p>
<h1 id="j---sushi-atcoder.jp"><span class="exturl" data-url="aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2RwL3Rhc2tzL2RwX2o=">J - Sushi (atcoder.jp)</span></h1>
<h2 id="题意-6">题意</h2>
<p>给定 <span class="math inline">\(n\)</span> 个盘子，每个盘子有 <span class="math inline">\(a_{i}\)</span> 个寿司，如果每一次等概率选择一个盘子，如果有寿司就吃掉，否则重新选择。求期望选择次数，使得所有寿司都被吃完。</p>
<p><span class="math inline">\(n \le 300\)</span> , <span class="math inline">\(1 \le a_{i} \le 3\)</span></p>
<h2 id="做法-2">做法</h2>
<p>既然数据范围这么小，不难想到，可以设状态 <span class="math inline">\(f_{i,j,k}\)</span> 表示盘子中有1个寿司的有 <span class="math inline">\(i\)</span> 个，2个寿司的 <span class="math inline">\(j\)</span> 个，3个寿司的 <span class="math inline">\(k\)</span> 个。</p>
<p>但是如何转移呢？可以从 <span class="math inline">\(f_{i-1,j,k}\)</span> 转移而来， 也可以从 <span class="math inline">\(f_{i+1,j-1,k}\)</span> 转移，还有 <span class="math inline">\(f_{i,j+1,k-1}\)</span> 。</p>
<p>但是似乎期望的和式的项数是无限项，因为可能随到一个空盘子，就需要不停地随机。但是这个过程可以表示为： <span class="math display">\[
f_{i,j,k}=f_{i,j,k}\times \frac{n-i-j-k}{n} +1
\]</span> 解方程可以知道， <span class="math display">\[
f_{i,j,k}=\frac{n}{i+j+k}
\]</span> 其意义就是随机到一个非空盘子的期望步数。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">数学基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-22 00:00:00" itemprop="dateCreated datePublished" datetime="2023-09-22T00:00:00+00:00">2023-09-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 11:13:52" itemprop="dateModified" datetime="2024-03-23T11:13:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文介绍了OI中的一些数学基础知识。</p>
<h1 id="向量">向量</h1>
<h2 id="基本概念及定义">基本概念及定义</h2>
<p>见OI-Wiki，此处不再赘述。</p>
<h2 id="向量的线性运算">向量的线性运算</h2>
<h3 id="加减法">加减法</h3>
<p><strong>三角形法则</strong>：若求和的向量首尾顺次连接，那么和就为第一个向量的起点指向第二个向量的终点。</p>
<p><strong>平行四边形法则</strong>：若求和的两个向量共起点，那么和就为以这两个向量为邻边的平行四边形的对角线，起点为两个向量的共起点，方向沿对角线方向。</p>
<p><strong>减法</strong>：考虑减一个向量等价于加这个向量的相反向量。</p>
<h3 id="数乘">数乘</h3>
<p>实数 <span class="math inline">\(\lambda\)</span> 与向量 <span class="math inline">\(\boldsymbol{a}\)</span> 的积为一个向量。记作<span class="math inline">\(\lambda\boldsymbol{a}\)</span>。结果的长度与方向为：</p>
<p>长度：<span class="math inline">\(|\lambda \boldsymbol a|=|\lambda||\boldsymbol a|\)</span>。</p>
<p>方向：当 $&gt; 0 $ 时，<span class="math inline">\(\lambda \boldsymbol a\)</span> 与 <span class="math inline">\(\boldsymbol a\)</span> 同向，当 <span class="math inline">\(\lambda = 0\)</span> 时，<span class="math inline">\(\lambda \boldsymbol a=0\)</span>，当 $&lt; 0 $ 时，<span class="math inline">\(\lambda \boldsymbol a\)</span> 与 <span class="math inline">\(\boldsymbol a\)</span> 方向相反。</p>
<h4 id="判断两向量共线">判断两向量共线</h4>
<p>两个非零向量 <span class="math inline">\(\boldsymbol{a}\)</span> 与 <span class="math inline">\(\boldsymbol{b}\)</span> 共线 <span class="math inline">\(\iff\)</span> 有唯一实数 <span class="math inline">\(\lambda\)</span>， 使得 <span class="math inline">\(b = \lambda\boldsymbol{a}\)</span>。</p>
<h2 id="平面向量的基本定理">平面向量的基本定理</h2>
<p>如果两个向量 <span class="math inline">\(\boldsymbol{e_1},\boldsymbol{e_2}\)</span> 不共线，那么存在唯一实数对 <span class="math inline">\((x,y)\)</span>，使得与 <span class="math inline">\(\boldsymbol{e_1},\boldsymbol{e_2}\)</span> 共面的任意向量 <span class="math inline">\(\boldsymbol{p}\)</span> 满足 <span class="math inline">\(\boldsymbol{p}=x\boldsymbol{e_1}+y\boldsymbol{e_2}\)</span>。</p>
<p>依据这个定理，我们可以用两个<strong>不共线</strong>的向量表示所有平面向量。</p>
<p>那么在同一个平面内的两个不共线的向量称为 <strong>基底</strong> 。</p>
<p>如果基底相互垂直，那么分解的时候就是对向量 <strong>正交分解</strong> 。</p>
<h2 id="平面向量的坐标">平面向量的坐标</h2>
<h3 id="坐标的表示">坐标的表示</h3>
<p>根据平面向量的基本定理，可以得知，平面内每个向量可以被两个不共线向量唯一表示。</p>
<p>那么取与横轴和纵轴方向相同的两个单位向量 <span class="math inline">\(\boldsymbol{i},\boldsymbol{j}\)</span> 作为一组基底，平面上的所有向量与有序实数对 <span class="math inline">\((x,y)\)</span> 一一对应。</p>
<p>有序数对 <span class="math inline">\((x,y)\)</span> 与平面直角坐标系上的点一一对应，那么我们作 <span class="math inline">\(\overrightarrow{OP}=\boldsymbol{p}\)</span>，那么终点 <span class="math inline">\(P(x,y)\)</span> 也唯一确定。于是乎，平面直角坐标系之内，每一个向量都可以用有序实数对唯一表示。</p>
<h3 id="坐标的运算">坐标的运算</h3>
<p>若有向量 <span class="math inline">\(\boldsymbol{a}=(m,n)\)</span>, <span class="math inline">\(\boldsymbol{b}=(p, q)\)</span>，则： <span class="math display">\[
\boldsymbol{a}+\boldsymbol{b}=(m+p,n+q)
\\ \boldsymbol{a}-\boldsymbol{b}=(m-p,n-q)
\\ k\boldsymbol{a}=(km,kn)
\]</span></p>
<h1 id="三角函数">三角函数</h1>
<h2 id="定义">定义</h2>
<p>当平面上三点A, B, C 连成一个直角三角形时. 其中 <span class="math inline">\(∠ACB\)</span> 为直角. 对于 <span class="math inline">\(∠BAC\)</span> 而言, 邻边 AC , 斜边 AB , 对边 BC 有如下定义:</p>
<p><strong>正弦函数(sine)(sin)</strong>: <span class="math inline">\(∠A\)</span> 的对边比斜边. 即 BC/AB</p>
<p><strong>余弦函数(cosine)(cos)</strong>: <span class="math inline">\(∠A\)</span> 的邻边比斜边. 即 AC/AB</p>
<p><strong>正切函数(tangent)(tan)</strong>: <span class="math inline">\(∠A\)</span> 的对边比邻边. 即 BC/AC</p>
<p><strong>余切函数(cotangent)(cot)</strong>: <span class="math inline">\(∠A\)</span> 的邻边比对边. 即 AC/BC</p>
<p><strong>正割函数(secant)(sec)</strong>: <span class="math inline">\(∠A\)</span> 的斜边比邻边. 即 AB/AC</p>
<p><strong>余割函数(cosecant)(csc)</strong>: <span class="math inline">\(∠A\)</span> 的斜边比对边. 即 AB/BC</p>
<h1 id="复数">复数</h1>
<h2 id="引入与定义">引入与定义</h2>
<p>方程 <span class="math inline">\(x^2=-1\)</span> 在实数域没有解，为了让它有根，我们进行了数系扩张，引入了 <strong>虚数单元</strong> <span class="math inline">\(\mathrm{i}\)</span> ，规定 <span class="math inline">\(\mathrm{i}^2=-1\)</span> 。</p>
<p>让这个虚数单元与实数进行运算，得到一系列的数，进行归类，发现它们都可以写成 <span class="math inline">\(a+b\mathrm{i}(a,b\in \mathbf{R})\)</span> 的形式，我们称这些数为复数。</p>
<p>其中的 <span class="math inline">\(a\)</span> 称为实部，<span class="math inline">\(b\)</span> 称为虚部。</p>
<h2 id="性质与运算">性质与运算</h2>
<h3 id="几何意义">几何意义</h3>
<p>我们发现，复数一般形式中的 <span class="math inline">\(a,b\)</span> 可以对应平面直角坐标系中的两个坐标，那么一个复数就可以对应平面直角坐标系上的一个点。我们称表示 <span class="math inline">\(a\)</span> 的数轴为实轴，而 <span class="math inline">\(b\)</span> 对应的数轴为虚轴。</p>
<p>于是复数就与平面上的点一一对应，由于向量也与平面上的点一一对应，我们认为复数 <span class="math inline">\((a,b)\)</span> 与向量 <span class="math inline">\(\overrightarrow{OZ}=(a,b)\)</span> 对应。</p>
<p><strong>复数模长</strong>：一个复数所对应的向量的模长。</p>
<h3 id="运算">运算</h3>
<p><strong>复数相等</strong>：如果两个复数 <span class="math inline">\(a+b\mathrm{i}\)</span> 和 <span class="math inline">\(c+d\mathrm{i}\)</span> 相等，当且仅当 <span class="math inline">\(a=c,b=d\)</span> 。</p>
<p><strong>复数加法</strong>：实部相加，虚部相加。</p>
<p><strong>复数减法</strong>：减法是加法的逆运算，类似于实数的运算法则，减去一个复数等于加上这个复数的相反数。</p>
<p><strong>复数乘法</strong>：直接展开即可。注意到 <span class="math inline">\(\mathrm{i}^2=-1\)</span> 。</p>
<p><strong>共轭复数</strong>：<span class="math inline">\(a+b\mathrm{i}\)</span> 与 <span class="math inline">\(a-b\mathrm{i}\)</span> 互为共轭复数，它们的乘积 <span class="math inline">\((a+b\mathrm{i})(a-b\mathrm{i})=a^2+b^2\)</span> 是一个实数。复数 <span class="math inline">\(z\)</span> 的共轭复数记作 <span class="math inline">\(\overline{z}\)</span></p>
<p><strong>复数除法</strong>：类似于多项式除法的化简，利用共轭复数实现分母实化。例如： <span class="math display">\[
\begin{aligned}
\frac{a+b\mathrm{i}}{c+d\mathrm{i}} &amp; = \frac{(a+b\mathrm{i})(c-d\mathrm{i})}{c^2+d^2} \\
&amp; = \frac{ac+bd+bci-adi}{c^2+d^2} \\
&amp; = \frac{ac+bd}{c^2+d^2}+\frac{bc-ad}{c^2+d^2}
\end{aligned}
\]</span></p>
<h3 id="辐角与单位圆">辐角与单位圆</h3>
<p>规定实数单位 1 作为水平正方向，虚数单位 <span class="math inline">\(\mathrm{i}\)</span> 作为竖直正方向，那么一个非零复数 <span class="math inline">\(z=x+y\mathrm{i}\)</span> 的 <strong>辐角<span class="math inline">\(\theta\)</span></strong> 定义为满足 <span class="math inline">\(\tan{\theta}=\frac{y}{x}\)</span> ，记作 <span class="math inline">\(\operatorname{Arg}z\)</span> 。其中满足 <span class="math inline">\(-\pi&lt;\theta\le\pi\)</span> 的辐角称为 <strong>辐角主值</strong> ，记作 <span class="math inline">\(\operatorname{arg}z\)</span> 。</p>
<p>称模长小于 1 的复数组成的图形为 <strong>单位圆</strong> ，称模等于 1 的复数称为 <strong>单位复数</strong> ，全体单位复数构成的图形称为 <strong>单位圆周</strong> 。</p>
<p>在不引起混淆的情况下单位圆周有时也称为单位圆。</p>
<p>我们可以发现，此时的复数的乘除法有了另一种计算方式。</p>
<p>复数乘法：辐角相加，模长相乘。</p>
<p>复数除法：辐角相减，模长相除。</p>
<blockquote>
<p>证明</p>
<ul>
<li><p>若有两个复数 <span class="math inline">\(z_1=a+b\mathrm{i}\)</span> 和 <span class="math inline">\(z_2=c+d\mathrm{i}\)</span> ，那么相乘的模长： <span class="math display">\[
\begin{aligned}
|z_1|\times |z_2|&amp;=\sqrt{a^2+b^2}\times \sqrt{c^2+d^2}\\
&amp;=\sqrt{(a^2+b^2) (c^2+d^2)}
\end{aligned}
\]</span> 而它们乘积的模长 <span class="math display">\[
\begin{aligned}
|z_1z_2|&amp;=|(ac-bd)+(ad+bc)\mathrm{i}| \\
&amp;=\sqrt{(ac-bd)^2+(ad+bc)^2} \\
&amp;=\sqrt{a^2c^2+b^2d^2+a^2d^2+b^2c^2-2acbd+2adbc} \\
&amp;=\sqrt{a^2c^2+b^2d^2+a^2d^2+b^2c^2} \\
&amp;=\sqrt{(a^2+b^2)(c^2+d^2)}
\end{aligned}
\]</span> 至此我们证明了模长乘积相等。</p></li>
<li><p>下面证明辐角相加相等：</p>
<p>令图中点 (1,0) 为点 <span class="math inline">\(I\)</span>。</p>
<p>考虑证明图中的三角形ABO和三角形CIO相似。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/61434.png" /></p>
<p>由于刚刚证明的模长关系，可以知道 <span class="math inline">\(OA=OB\times OC\)</span> ，可以得到一个等积式。如果能够再得到 <span class="math inline">\(AB:IC=OB:OI\)</span> ，即 <span class="math inline">\(IC^2 \times OB^2=AB^2\)</span> 即可。</p>
<p>一顿展开应该可以证明。</p>
<p>如此，那么 ∠OIC=∠BOA ，故，∠OIC+∠IOB=∠IOA</p></li>
</ul>
</blockquote>
<h2 id="单位根">单位根</h2>
<h3 id="定义-1">定义</h3>
<p><span class="math inline">\(x^{n}=1\)</span> 的复数解。</p>
<p>比较显然，解 <span class="math inline">\(x\)</span> 的模长必定为1.</p>
<p>于是我们在单位圆上考虑单位根。</p>
<p>考虑到复数乘法可以用辐角相加，<span class="math inline">\(x^{n}\)</span> 的辐角就等于 <span class="math inline">\(x\)</span> 的辐角的 <span class="math inline">\(n\)</span> 倍。很显然，只有当 <span class="math inline">\(x\)</span> 辐角为 <span class="math inline">\(\frac{1}{n}\)</span> 圆周的倍数的时候，<span class="math inline">\(x^n\)</span> 的辐角才能落在 <span class="math inline">\(x\)</span> 轴上。</p>
<p>所以 n 次单位根落在 <span class="math inline">\(0,\frac{1}{n},\frac{2}{n},\cdots,,\frac{n-1}{n}\)</span> 圆周上，共有 <span class="math inline">\(n\)</span> 个。</p>
<p>所以 <span class="math inline">\(n\)</span> 次单位根 <span class="math inline">\(n\)</span> 等分单位圆。</p>
<p>按照逆时针顺序将这些单位根，记作 <span class="math inline">\(\omega_{n}^{i}\)</span> ，其中 <span class="math inline">\(i\in [0,n-1],i\in \mathbb{Z}\)</span> 。</p>
<h3 id="性质">性质</h3>
<ol type="1">
<li><span class="math inline">\(\omega_{n}^{k}=(\omega_{n}^{1})^k\)</span> ，显然</li>
<li><span class="math inline">\(\omega_{n}^{j}+\omega_{n}^{k}=\omega_{n}^{j+k}\)</span> ，显然</li>
<li><span class="math inline">\(\omega_{2n}^{2k}=\omega_{n}^{k}\)</span> ，将一个圆等分成 <span class="math inline">\(2n\)</span> 份取第 <span class="math inline">\(2k\)</span> 份，与直接分成 <span class="math inline">\(n\)</span> 份取 <span class="math inline">\(k\)</span> 份，是一样的。</li>
<li>若 <span class="math inline">\(n\)</span> 为偶数，那么 <span class="math inline">\(\omega_{n}^{k+n/2}=-\omega_{n}^{k}\)</span> 。从 <span class="math inline">\(\omega_{n}{k}\)</span> 出发旋转半个圆周，就是关于原点对称，那么坐标互为相反数。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/GDKOI2023%E6%B8%B8%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/GDKOI2023%E6%B8%B8%E8%AE%B0/" class="post-title-link" itemprop="url">GDKOI2023游记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-03-16 00:00:00" itemprop="dateCreated datePublished" datetime="2023-03-16T00:00:00+00:00">2023-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 11:13:52" itemprop="dateModified" datetime="2024-03-23T11:13:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="day-0">Day 0</h2>
<p>去广州比赛，非常开心。看一看省行政中心是什么样子。</p>
<p>车上被 LYY 拍了一个照。快下高速的时候看到一个大铜钱样子的建筑，第一次见这么“钱”的建筑。</p>
<p>本来以为广州全都是高楼大厦，没想到很多地方其实看起来很旧，甚至看起来还比不上中山。</p>
<p>酒店居然叫 吉桔酒店 ，名字很独特啊。</p>
<p>到了酒店，开房的时候，同学们发现墙壁哪里有一个机器人，就都围着机器人转，让机器人送草稿纸，还给它拍照。</p>
<p>进了酒店，有电视，马上看电视，不知道看什么，本来想看人大的，但是太无聊了。</p>
<p>一个下午看电视过去了……</p>
<p>集合的时候见到了几位纪中的朋友， 冯D 刘瑾 都来了，他们打的是普及组，想到提高组是省选水平，就感觉似乎没有什么希望拿奖了。</p>
<p>到六中报道，发现这个学校似乎也不是很大的样子，似乎有点旧。</p>
<p>太开心了，居然送了我一个笔记本和一支笔，很有纪念意义，可以做笔记了。</p>
<p>六中的菜真的很好吃，比某学校强多了。</p>
<p>回酒店以后继续腐败，本来想刷回 B 站视频的，但是不好操作。</p>
<p>晚上 LYM 说请客，和 LYY 一起溜去喝奶茶，有点小激动，第一次和同学去逛街，想到班上的同学还在上自习。奶茶不太健康，就只点了个柠檬水。</p>
<p>回酒店后看 LYM 和 LYY 洗澡，去九楼的洗衣机把衣服洗了。</p>
<p>十点半睡觉了。</p>
<h2 id="day-1">Day 1</h2>
<p>比赛就要开始了，为什么提高组是省选的难度啊？这怎么打？</p>
<p>走进考场，决定怎么说打不出来就打暴力吧，心情躺平。开始之后，发现居然没有虚拟机（不是说要提供 NOI LINUX 吗？），又发现居然有 VIM （虽然版本只有 7.2 ）。聊胜于无，2 min 打完配置之后看题目。</p>
<h3 id="赛时">赛时</h3>
<h4 id="problem-1">Problem 1</h4>
<blockquote>
<h5 id="题目大意">题目大意：</h5>
<p>给出三个 <span class="math inline">\(n \times n\)</span> 的矩阵 <span class="math inline">\(A\)</span> 、 <span class="math inline">\(B\)</span> 、<span class="math inline">\(C\)</span> 。求 <span class="math inline">\(A \times B\)</span> 是否等于 <span class="math inline">\(C\)</span> 。有多组询问。</p>
<h5 id="数据范围">数据范围：</h5>
<p>对于 <span class="math inline">\(20\%\)</span> 的数据，<span class="math inline">\(\sum n \leq 300\)</span> 。</p>
<p>对于另外 <span class="math inline">\(20\%\)</span> 的数据， <span class="math inline">\(A_{i,j} \not= 0\)</span> 的不超过 <span class="math inline">\(n\)</span> 个。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，<span class="math inline">\(\sum n \leq 3000\)</span> 。</p>
</blockquote>
<p>T1 看起来很不错啊，题目通俗易懂，简单明了。暴力很好打，可惜只有 20 分。目光对准 20 分的性质，发现此时可以枚举有数值的 <span class="math inline">\(A_{i,j}\)</span> ，考虑它对答案的贡献。由矩阵乘法定义式：</p>
<p><span class="math display">\[
C_{i,j}=A_{i,k}\times B_{k,j}
\]</span></p>
<p>枚举 <span class="math inline">\(i, k\)</span> 。如果 <span class="math inline">\(A_{i,k}\)</span> 不为 0 ，就枚举 <span class="math inline">\(j\)</span> 来贡献，这样是 <span class="math inline">\(O(n^2)\)</span> 的。</p>
<p>最后我觉得差不多了，感觉有机会想出正解，但是感觉又不一定想出来。于是就快速把 40 分的部分分打出来了。</p>
<p>打完以后又打了一个对拍，拍了一下特殊性质和暴力，结果是对的，就决定从特殊性质出发，考虑能否想出正解。</p>
<p>考虑将 <span class="math inline">\(O(n^3)\)</span> 的算法优化一维，就考虑到题目只是问是否相同，并没有让我将结果矩阵求出来，考虑可不可以用奇妙的办法将 <span class="math inline">\(j\)</span> 优化掉。</p>
<p>于是想到似乎 <span class="math inline">\(A_{i,k}\)</span> 会乘上 <span class="math inline">\(B\)</span> 的某一行贡献到 <span class="math inline">\(C\)</span> 的某一行，一开始想的是：<span class="math inline">\(A_{i,k}\)</span> 是固定的，不如对 <span class="math inline">\(B\)</span> 整行求和，乘上 <span class="math inline">\(A_{i,k}\)</span> ，看是否等于 <span class="math inline">\(C\)</span> 的行。但是这样如果每一行和是相同的，但具体数字不一样就会出错。</p>
<p>考虑将 <span class="math inline">\(B\)</span> 不同的列乘上随机不同的数字，这样就可以将数字之间的差异放大化。打完对拍，似乎能过。</p>
<p>最后生成了大小为 3000 的一组数据，发现文件有一百多M，读入有点慢，跑了 5s 多才跑完，还开了O，有点怕 T 。</p>
<p>两个小时过去了。</p>
<h4 id="problem-2">Problem 2</h4>
<blockquote>
<h5 id="题目大意-1">题目大意</h5>
<p>求有多少个排列 <span class="math inline">\(p_i\)</span> 。对于所有 <span class="math inline">\(i \leq m\)</span> ，<span class="math inline">\(p_i &gt; m\)</span> 且 <span class="math inline">\(p_i \not= i\)</span> 。</p>
</blockquote>
<p>暴力很显然，可是只有 10 分。看到有 <span class="math inline">\(m \leq 0\)</span> 的 <span class="math inline">\(10 \%\)</span> 的数据，发现这不就是一个错排问题吗？但是式子是什么呢？</p>
<p>我记得好像当初 CSP 初赛的时候学过，但是是初一的时候学的，有点久远，记忆有点模糊。怎么办呢？我想推一下式子，奈何数学水平太差劲，没有推出来。（分数 -= 10）</p>
<h4 id="problem-3">Problem 3</h4>
<blockquote>
<h5 id="题目大意-2">题目大意</h5>
<p>给定一张 n 个点 m 条边的无向图和一个长度为 n 的数组 <span class="math inline">\(a_1,a_2,\cdots,a_n\)</span> 以及一个整数 <span class="math inline">\(C\)</span> ，你需要求出有多少个长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(b\)</span> 满足：</p>
<ol type="1">
<li><span class="math inline">\(0 \leq b_i \leq ai\)</span>， <span class="math inline">\(\forall 1 \leq i \leq n\)</span>。</li>
<li>对于每条边 <span class="math inline">\((u, v)\)</span>， <span class="math inline">\(b_u \not= bv\)</span> 。</li>
<li><span class="math inline">\(b_1 \oplus b_2 \oplus \cdots \oplus b_n\)</span> = C，其中 <span class="math inline">\(\oplus\)</span> 代表异或。</li>
</ol>
<p>答案对 998244353 取模。</p>
</blockquote>
<p>本来考虑异或的特殊性质，想到是否可以对于 <span class="math inline">\(b\)</span> 的每一位计算这一位为 C 的概率，推了一会，发现第二个限制有点难办。</p>
<p>打了暴力就算了。</p>
<p>打完三道题之后，还剩一个小时，没事干，就把 T1 的对拍运行了一下，又想了一会 T2 的式子，还是没有推出来。</p>
<p>比完赛之后听说 T1 是原题。</p>
<h3 id="讲题">讲题</h3>
<h4 id="problem-1-1">Problem 1</h4>
<p>正解很是奇怪，用一个长度为 n 的随机向量乘上矩阵 <span class="math inline">\(A\)</span> 再乘 <span class="math inline">\(B\)</span> ，判断是否跟 <span class="math inline">\(C\)</span> 相同。这样子本质上是和我的做法差不多的，只是这样讲比较高级。</p>
<h4 id="problem-2-1">Problem 2</h4>
<p>T2 没有认真听，感觉很难，好像是生成函数，很奇怪啊。</p>
<h4 id="problem-3-1">Problem 3</h4>
<p>T3 听了一会，没听懂，一脸懵逼。</p>
<h3 id="讲座">讲座</h3>
<h4 id="罗国杰教授的讲座">罗国杰教授的讲座</h4>
<p>教授太奇怪了，头像就是一个建模建歪了的卡通大叔。</p>
<p>一直在讲北大的计算机学科体系，感觉没有什么有意思的内容。</p>
<h4 id="小马智行">小马智行</h4>
<p>莫璐怡副总裁出场讲课， ACM 冠军，六中毕业生。</p>
<p>这个 pony.ai 似乎很高科技的样子，自动驾驶很有意思，感觉自动化识别汽车很厉害的样子。叫 拉D 扫码没扫到。</p>
<h4 id="皇帝的滚榜">皇帝的滚榜</h4>
<p>一个老师说要搞滚榜，看起来很高科技的样子哦。不知道是怎样子的。</p>
<p>又说要多测几次代码，取最高分当作分数，让我们休息一会儿。此言一出，很多打随机化算法的同学非常高兴啊。</p>
<p>结果 40 分钟还没有开始，我还以为马上开始了，就没有写作业。最后到五点半，老师说有几个同学每次分数都不一样，要人工核查一下。让我们先去吃饭，吃完再回来滚榜。</p>
<p>吃完饭回来只看到四个大字：“明天再见~”</p>
<h3 id="晚上">晚上</h3>
<p>晚上写了会作业，LYM D 了一篇作文，八点钟的时候离开酒店。 SQC 不去啊，似乎 LYM 又请客啊。去到麦当劳， LYM 和 LYY 点了 3 个套餐， 他们两人 AA 了，我白嫖，两位老板请客。</p>
<p>吃完之后，我提议去中大，看一下重点大学是什么样子的。我看公交站牌，辨认走哪一条路。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7uy46q5k.png" /></p>
<p>如图所示，我看公交站牌上有几条路线的下一站是“中大北门”，于是我就觉得站在这个方向，下一站肯定是向前走，忘记可以左/右转了，就继续向前走，走过十字路口。</p>
<p>走着走着，这里也不像是大学校园的样子啊，看到前面是一个很大的，好似花车一般的，还闪烁着霓虹灯的“车”缓缓开过。我疑心是有游行活动罢。</p>
<p>感觉这条路真的不是往中大的，想要走到下一个路口就掉头。</p>
<p>走到路口，震撼眼前的一幕，珠江映入眼帘，江对面的是繁华的高楼，一座雄伟的大桥跨江而过。广州塔在不远的前方。</p>
<p>和 LYY LYM 继续向前走，拍了几张照，八点四十分就返程了。</p>
<h2 id="day-2">Day 2</h2>
<h3 id="赛时-1">赛时</h3>
<h4 id="problem-1-2">Problem 1</h4>
<blockquote>
<h5 id="题目大意-3">题目大意</h5>
<p>给定一棵 <span class="math inline">\(n\)</span> 个结点的树，有 <span class="math inline">\(Q\)</span> 次询问，每次给定 <span class="math inline">\(x, y, z\)</span>，你要找到三个点 <span class="math inline">\((u, v, w)\)</span> 满足 <span class="math inline">\(dis(u, v) = x\,, dis(u, w) = y\,, dis(v, w) = z\)</span>。其中 <span class="math inline">\(dis(u, v)\)</span> 表示树上 u 和 v 两点唯一简单路径所包含的边数， <span class="math inline">\(dis(u, u) = 0\)</span>。 保证有解。</p>
</blockquote>
<p>我以为今天的 T1 还像昨天的那么水，想了一会，观察了一会样例，发现似乎给出的 <span class="math inline">\(x,y,z\)</span> 中最小的两个相加等于最大的两个，想到如果最小的两个数加起来为最大的，那么三个点必定在一条链上，那么只需要在最长的链（即直径）上找两个点就好了。打树上倍增，在 <span class="math inline">\(O(q \log n)\)</span> 的时间内解决问题。</p>
<p>打之前我还有点疑惑，真的有这么简单吗？最小的两个数加起来真的等于最大的数字吗？但是我又举不出任何反例，自信应该是这样的。大不了打完之后打对拍就好了。</p>
<p>此时我本来应该先打一个程序检验一下是否满足这个性质。但是我没有，继续打这个想法，但是没有想好怎么打，打了很久才打完。样例过了。两个小时过去了。</p>
<p>接着打对拍，第一组数据就挂了。生成的数据太大，没法手动检验。又搞了几个小数据，发现真的不一定满足那个性质。这该怎么办呢？</p>
<p>我没有什么办法，又打了一个暴力，结果暴力也过不了对拍，调了一会，发现只剩下 30 Min 了，赶紧去打后面两道题。</p>
<h4 id="problem-2-2">Problem 2</h4>
<blockquote>
<h5 id="题目大意-4">题目大意</h5>
<p>有一个数字，初始是 <span class="math inline">\(x_0\)</span> 。进行 <span class="math inline">\(K\)</span> 次操作，第 <span class="math inline">\(i\)</span> 次操作从 <span class="math inline">\([0, 2n)\)</span> 均匀随机一个数字 <span class="math inline">\(x\)</span> ， <span class="math inline">\(x_i\)</span> 有 <span class="math inline">\(p\)</span> 的概率是 <span class="math inline">\(x_{i-1} \ \text{or}\  x\)</span>，有 <span class="math inline">\(1 - p\)</span> 的概率是 <span class="math inline">\(x_i-1\ \text{and}\ x\)</span>。 一种方案的权值是 <span class="math inline">\(\sum_{i=1}^{K} c_{xi}\)</span>。对每个 <span class="math inline">\(i \in [0, 2n)\)</span>求出， <span class="math inline">\(x_K = i\)</span> 的所有方案中，权值乘概率之和，对998244353 取模。</p>
</blockquote>
<p>没有什么想法，只能打暴力。但是第一档分就是：对于 <span class="math inline">\(20\%\)</span> 的数据，满足 <span class="math inline">\(K \leq 20\)</span>。我怀疑过不了。</p>
<h4 id="problem-3-2">Problem 3</h4>
<blockquote>
<h5 id="题目大意-5">题目大意</h5>
<p>给定一棵 n 个结点的有根树 T，结点从 1 开始编号，根结点为 1 号结点，每个结点有一个正整数权值 <span class="math inline">\(vi\)</span>。有 <span class="math inline">\(Q\)</span> 次询问，对于一次询问，给定 <span class="math inline">\((x, k)\)</span>，设 <span class="math inline">\(x\)</span> 号结点的子树内（包含 <span class="math inline">\(x\)</span> 自身）的所有满足距离 <span class="math inline">\(x\)</span> 号结点不超过 <span class="math inline">\(k\)</span> 的结点编号为 <span class="math inline">\(c_1\,,c_2\,,\cdots ,c_k\)</span>，则这次询问的答案为： <span class="math inline">\((vc1 \oplus d(c1, x)) + (vc2 \oplus d(c2, x)) + \cdots + (vck \oplus d(ck, x))\)</span></p>
<p>其中 <span class="math inline">\(d(x, y)\)</span> 表示树上 <span class="math inline">\(x\)</span> 号结点与 <span class="math inline">\(y\)</span> 号结点间唯一简单路径所包含的边数， <span class="math inline">\(d(x, x) = 0\)</span>。 <span class="math inline">\(\oplus\)</span> 表示异或运算。</p>
</blockquote>
<p>也没有什么想法，只能打暴力。</p>
<h3 id="赛后">赛后</h3>
<p>比赛结束后发了成绩单，感觉有点不公平， T1 很多随机化过了，感觉对我这种打正解的选手有点亏。</p>
<p>T3 TLE 了，其实不应该枚举完再检验，应该一边枚举一边检验。可以减去很多情况。</p>
<p>中午 LYM 说他 T1 想到一种做法，如图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xdz56k5m.png" /></p>
<p><del>（图片是跟 LYM D 的)</del></p>
<p>三条路径必定有一个交点 <span class="math inline">\(i\)</span> 。</p>
<p>对于 <span class="math inline">\(dis(u,v)\)</span> 可以如上表示成 <span class="math inline">\(A+B\)</span> ，同理可以表示 <span class="math inline">\(dis(u,w)\)</span> 和 <span class="math inline">\(dis(v,w)\)</span> 。</p>
<p>如此便可以解出 <span class="math inline">\(A,B,C\)</span> 的值。</p>
<p>只要找到满足这个条件的点就好了。但是 LYM 不知道怎么弄。</p>
<p>下午讲题的时候，出题人讲的做法居然和 LYM 想的一样。最后似乎是用线段树搞一下。</p>
<p>T2 T3 的讲题没有认真听，感觉很难，而且周记没有写完，写周记先。</p>
<p>讲完题之后就说要跑榜，但是要等一等，就放了一下 GDKOI 2023 纪录片， 拉D 独占 2 秒镜头。</p>
<p>等了好久终于开始跑榜了，我终于知道跑榜是怎么弄的了。看到后面的很多选手不停地向上，我很慌张，怕他们上去之后就超过我了。我和 LYM 大喊：“不要再飞了，不要再 D 了”。</p>
<p>好不容易背景颜色变成了铜色，还没有看到我和 LYM 的名字，我觉得有希望拿牌。终于到我了，Day 1 T1 AC 的颜色格外耀眼，我很开心，因为看了这么久就只有我一个人 A 了 <del>（其实是就只有我一个 A 了还这么低分的）</del> 。</p>
<p>过了一会又看到 LYM 的名字，但是后来都没有我们两个的名字了（其实是因为我们 Day 2 爆零了）。</p>
<p>颁奖的时候本来没有我们的名字，有点小失落，以为我们并非真的是铜牌。结果有好几页，很高兴拿了一个🥉。</p>
<p>麦秋秋 太强了，银牌🥈。</p>
<p>WTC 太强了，金牌🥇。</p>
<p>很多纪雅的初二同学也只有铜牌，但是分数比我高。</p>
<p>吃完饭之后返程，我不知道的是：一堆作业正等待着我的到来。</p>
<p>九点整，就在同学们下课之时，我们刚刚到达校门口，我和 LYY 一路狂奔回课室放东西。</p>
<h2 id="day-3">Day 3</h2>
<p>赛后第一天，我开始思考到底 Day 2 T1 怎么做。</p>
<p>音乐课上我想了一下，感觉似乎可以使用二分，但很快就被我否决了。</p>
<h2 id="day-4">Day 4</h2>
<p>早上想了一想，想出来了。</p>
<p>跟 LYM 讨论了一下，终于想出了正解。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xdz56k5m.png" /></p>
<p>还是这张图。如果知道点 <span class="math inline">\(i\)</span> 的儿孙中的最大深度 <span class="math inline">\(a_i\)</span> ，次大深度 <span class="math inline">\(b_i\)</span> ，第三大深度 <span class="math inline">\(c_i\)</span> 。 满足 <span class="math inline">\(a_i \geq A\)</span> 且 <span class="math inline">\(b_i \geq B\)</span> 且 <span class="math inline">\(c_i \geq C\)</span> ，那么可以用树上倍增就可以在 <span class="math inline">\(O(log n)\)</span> 的时间里解决一次询问。</p>
<p>考虑如何解决，用出题人的想法，用树状数组。将 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(A\)</span> 排序，倒序处理。对于每一次询问，很显然，对于所有 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(a_i \geq A\)</span> 的，以 <span class="math inline">\(b_i\)</span> 为下标，将 <span class="math inline">\(c_i\)</span> 加入树状数组，利用树状数组询问后缀最大值，就可以快速求出 <span class="math inline">\(i\)</span> 了。利用树上倍增就可以在 <span class="math inline">\(O(n \log n)\)</span> 的时间内解决问题了。</p>
<h2 id="day-5">Day 5</h2>
<p>老师给我们看了总的排名，发现其实很多普及组同学的分数并不是很高，有一些平时成绩跟我差不多甚至比我好的同学排名也不高，突然有点高兴来了提高组，不然可能什么牌子都没有。</p>
<h2 id="总结">总结</h2>
<ul>
<li>难的比赛一定要注意部分分，有时候 10 分就可以相差很多名次。不能抛弃任何可能的部分分。</li>
<li>打之前一定要考虑清楚，不能想个大概就打，很容易出问题。高难度的比赛题目往往结论并不那么简单，可能设计一些比较难的结论，一定要保证结论正确。</li>
<li>我和一些优秀的同学之间的差距还很大，要多花一点时间在学习信息学上面，多学多做题，争取赶上其他同学。</li>
<li>Day 1 T3 TLE 了，其实不应该枚举完再检验，应该一边枚举一边检验。可以减去很多情况。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-code"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Tangninghaha</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">34k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:02</span>
  </span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div><a href="https://icp.gov.moe/?keyword=20245550" target="_blank">萌ICP备20245550号</a>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://lib.baomitu.com/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://lib.baomitu.com/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://lib.baomitu.com/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"tangninghaha/Blog-Comment","repo_id":"R_kgDOK75Jug","category":"Announcements","category_id":"DIC_kwDOK75Jus4Cb4f_","mapping":"pathname","reactions_enabled":1,"emit_metadata":1,"theme":"light","lang":"en","crossorigin":"anonymous","input_position":"top","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

<!-- hexo injector body_end start -->
<script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>
<script>
if (window.netlifyIdentity) {
  window.netlifyIdentity.on("init", user => {
    if (!user) {
      window.netlifyIdentity.on("login", () => {
        document.location.href = "/admin/";
      });
    }
  });
}
</script>
<link rel="stylesheet" href="//lib.baomitu.com/highlight.js/9.6.0/styles/github.min.css"><script src="//lib.baomitu.com/highlight.js/9.6.0/highlight.min.js"></script><!-- hexo injector body_end end --></body>
</html>
