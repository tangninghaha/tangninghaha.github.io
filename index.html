<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="msvalidate.01" content="7197295068F5C122E84D3763FE74EC8A">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://lib.baomitu.com/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://lib.baomitu.com/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://lib.baomitu.com/pace/1.2.4/themes/silver/pace-theme-fill-left.css">
  <script src="https://lib.baomitu.com/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"tangninghaha.netlify.app","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.19.1","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="三尺微命，一介书生">
<meta property="og:type" content="website">
<meta property="og:title" content="Tangninghaha">
<meta property="og:url" content="https://tangninghaha.netlify.app/index.html">
<meta property="og:site_name" content="Tangninghaha">
<meta property="og:description" content="三尺微命，一介书生">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tangninghaha">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://tangninghaha.netlify.app/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Tangninghaha</title>
  




  <script type="text/javascript">
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "knozjnw3d2");
</script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Tangninghaha</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Number 10, Tangning Street</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tangninghaha"
      src="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
  <p class="site-author-name" itemprop="name">Tangninghaha</p>
  <div class="site-description" itemprop="description">三尺微命，一介书生</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RhbmduaW5naGFoYQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tangninghaha"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOnRhbmduaW5naGFoYUBvdXRsb29rLmNvbQ==" title="E-Mail → mailto:tangninghaha@outlook.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="https://lib.baomitu.com/creativecommons-vocabulary/2020.11.3/assets/license_badges/big/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>
<div class="cc-license animated" itemprop="sponsor">
  <a href="https://www.netlify.com" class="cc-opacity" title="Deploy with Netlify → https://www.netlify.com" target="_blank"><img height="20" src="https://api.netlify.com/api/v1/badges/098df643-d737-4e3a-8b6d-024ce59dedab/deploy-status" alt="Deploy Status"></a>
</div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <span class="exturl" data-url="aHR0cHM6Ly9kYW5pZWxxZi5uZXRsaWZ5LmFwcC8=" title="https:&#x2F;&#x2F;danielqf.netlify.app&#x2F;">Danielqf</span>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/polya%E5%AE%9A%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/polya%E5%AE%9A%E7%90%86/" class="post-title-link" itemprop="url">polya 定理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-01 10:27:59" itemprop="dateCreated datePublished" datetime="2024-03-01T10:27:59+00:00">2024-03-01</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.8k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>14 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvU291bGlzdC9zb2x1dGlvbi1wNDk4MA==">主要参考</span></p>
<h1 id="群">群</h1>
<h2 id="定义">定义</h2>
<p>定义集合 <span class="math inline">\(G\)</span> 及一个二元运算 <span class="math inline">\(\cdot\)</span>，如果满足 4 个性质就是一个群，记作 <span class="math inline">\((G,\cdot)\)</span>。</p>
<ol type="1">
<li>封闭性。就是集合中两个元素进行 <span class="math inline">\(\cdot\)</span> 运算之后的结果仍然是在集合中。</li>
<li>结合律。这个小学数学讲过。</li>
<li>单位元 <span class="math inline">\(e\)</span>。单位元只有一个（这我乱证一下，假如有 <span class="math inline">\(e_{1}\)</span> 和 <span class="math inline">\(e_{2}\)</span> 都是单位元，那么 <span class="math inline">\(e_{1}\cdot e_{2}\)</span> 该等于什么呢？）</li>
<li>逆元。也就是对于所有 <span class="math inline">\(a\in G\)</span>，都有 <span class="math inline">\(a&#39;\in G\)</span> 满足 <span class="math inline">\(a\cdot a&#39;=a&#39;\cdot a=e\)</span>。据说逆元是唯一的，但是我太菜，不会证。</li>
</ol>
<p>可以感受一下这些性质。<del>反正我不学数学，不证明</del>。</p>
<h2 id="子群">子群</h2>
<p>可以类比子集理解，群有一个集合 <span class="math inline">\(G\)</span>，子群有集合 <span class="math inline">\(H\)</span>，若 <span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的一个子集，且群 <span class="math inline">\((H,\cdot)\)</span> 也是群，那么 <span class="math inline">\((H,\cdot)\)</span> 是群 <span class="math inline">\((G,\cdot)\)</span> 的一个子群。</p>
<h2 id="陪集">陪集</h2>
<p>对于某一个元素 <span class="math inline">\(g\in G\)</span>，如果有</p>
<ul>
<li><span class="math inline">\(gH=\{g\cdot h\vert h\in H\}\)</span>，那么称 <span class="math inline">\(gH\)</span> 为 <span class="math inline">\(H\)</span> 包含 <span class="math inline">\(g\)</span> 的左陪集。</li>
<li><span class="math inline">\(Hg=\{h\cdot g\vert h\in H\}\)</span>，那么称 <span class="math inline">\(Hg\)</span> 为 <span class="math inline">\(H\)</span> 包含 <span class="math inline">\(g\)</span> 的右陪集。</li>
</ul>
<p>陪集具有若干性质。</p>
<blockquote>
<p>注意，举反例要考虑群的封闭性。</p>
<p>曾经我发现性质是“错误”的，我举出了整数集合的一个子集和整数加法运算构成的“群”，发现其子群的陪集不满足下述性质。我感到很疑惑。最后当我将这个“反例”列出的时候，才发现，这个所谓的“群”不满足封闭性。</p>
</blockquote>
<h3 id="阶">阶</h3>
<p>群 <span class="math inline">\(G\)</span>的阶等于其元素个数，记作 <span class="math inline">\(\vert G\vert\)</span>。</p>
<h3 id="陪集的性质">陪集的性质</h3>
<p>分析时采用右陪集，证明均为非严格证明，因为 <del>反正我不学数学</del> 不是很会证明，如果谁会可以分享一下。</p>
<ol type="1">
<li><p>某一子群的阶等于陪集的阶。</p>
<p>符号表达就是 <span class="math inline">\(\forall g\in G,\vert Hg\vert=\vert H\vert\)</span>。</p>
<p>证明：由定义得到，如果右陪集是一个可重集，那么这个可重集中元素个数恰好为 <span class="math inline">\(\vert H\vert\)</span> 个。只需要证明这个可重集中的元素互不相同。如果有 <span class="math inline">\(h_1,h_2\in H,h_1\not=h_2\)</span>，且 <span class="math inline">\(h_1\cdot g=h_2\cdot g\)</span>，由于 <span class="math inline">\(g\)</span> 的逆元唯一，所以 <span class="math inline">\(h_1\cdot g\cdot g^{-1}=h_2\cdot g\cdot g^{-1}\)</span>，推出 <span class="math inline">\(h_1=h_2\)</span>，导出矛盾。</p></li>
<li><p><span class="math inline">\(\forall g\in G,g\in Hg\)</span>。</p>
<p>注意到 <span class="math inline">\(H\)</span> 是一个群，所以 <span class="math inline">\(H\)</span> 一定具有单位元。</p></li>
<li><p><span class="math inline">\(Hg=H\Longleftrightarrow g\in H\)</span>。</p>
<p>从右向左是简单的，因为群具有封闭性。从左往右我不会证 QAQ。</p></li>
<li><p><span class="math inline">\(Ha=Hb\Longleftrightarrow a\cdot b^{-1}\in H\)</span>。</p>
<p>从左向右：对于 <span class="math inline">\(h_1,h_2\in H\)</span>，有 <span class="math inline">\(h_1\cdot a=h_2\cdot b\)</span>，那么 <span class="math inline">\(h_{2}=h_{1}\cdot a\cdot b^{-1}\)</span>，所以 <span class="math inline">\(H=H(a\cdot b^{-1})\)</span>，根据性质 3，可以得到 <span class="math inline">\(a\cdot b^{-1}\in H\)</span>。</p>
<p>从右向左：我们类似上面的过程，反过来。如果 <span class="math inline">\(a\cdot b^{-1}\in H\)</span>，根据群的封闭性，若 <span class="math inline">\(h_{1}\in H\)</span>，有 $h_2=h_1ab^{-1}$，其中 <span class="math inline">\(h_{2}\in H\)</span>，所以可以得到 <span class="math inline">\(h_{2}\cdot b=h_{1}\cdot a\)</span>，也就是两者的陪集相同。</p></li>
<li><p>如果两个陪集交集非空，那么这两个陪集相等。</p>
<p><span class="math inline">\(Ha\cap Hb\not=\varnothing\Longleftrightarrow Ha=Hb\)</span>。</p>
<p>假如 <span class="math inline">\(c\in Ha \wedge c\in Hb\)</span>，那么 <span class="math inline">\(c=h_1\cdot a,h_1\in H\)</span> 并且 <span class="math inline">\(c=h_2\cdot a,h_2\in H\)</span>，也就是说 <span class="math inline">\(h_1\cdot a=h_2\cdot b\)</span>，所以 <span class="math inline">\(h_{2}=h_{1}\cdot a\cdot b^{-1}\)</span>。根据性质 4，可以得到 <span class="math inline">\(Ha=Hb\)</span>。</p></li>
<li><p><span class="math inline">\(H\)</span> 的全体右陪集的并为 <span class="math inline">\(G\)</span>。</p>
<p>因为 <span class="math inline">\(H\)</span> 中存在单位元，右陪集中能够取便所有元素。</p></li>
</ol>
<p>其实这些证明大多都是不严谨或者有问题的，大家看一乐呵就好。</p>
<h3 id="符号规定">符号规定</h3>
<p><span class="math inline">\([G:H]\)</span> 表示 <span class="math inline">\(G\)</span> 中 <span class="math inline">\(H\)</span> 的不同的左或右陪集的数量。</p>
<h2 id="拉格朗日定理">拉格朗日定理</h2>
<p><span class="math inline">\(\vert H\vert \times [G:H]=\vert G\vert\)</span>。</p>
<p>也就是说 <span class="math inline">\(H\)</span> 的阶乘上 <span class="math inline">\(G\)</span> 中 <span class="math inline">\(H\)</span> 的左陪集数量等于 <span class="math inline">\(G\)</span> 的阶。</p>
<p>考虑到 <span class="math inline">\(H\)</span> 的所有不同陪集的交为空集，并且每一个陪集的大小都为 <span class="math inline">\(\vert H\vert\)</span>（性质 1）。由性质 6 得到全体陪集的并为 <span class="math inline">\(G\)</span>，得证。</p>
<h1 id="置换">置换</h1>
<p>群的介绍告一段落，下面来说说置换。</p>
<p>参考：</p>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9tYXRoL3Blcm11dGF0aW9uLw==">OI-Wiki - 置换和排列</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvU291bGlzdC9zb2x1dGlvbi1wNDk4MA==">主要参考</span></li>
</ol>
<h2 id="定义-1">定义</h2>
<p>置换定义为有限集合 <span class="math inline">\(S\)</span> 到自身的一个双射。</p>
<p>集合 <span class="math inline">\(S={a_1,a_2,\cdots,a_n}\)</span> 的一个置换可以表示为： <span class="math display">\[
f=\begin{pmatrix}a_1,a_2,\dots,a_n\\
a_{p_1},a_{p_2},\dots,a_{p_n}
\end{pmatrix}
\]</span> 其中 <span class="math inline">\(p\)</span> 是一个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的一个排列。我们可以认为置换就是将一个序列按照某一个排列的顺序重新排序。</p>
<h2 id="运算">运算</h2>
<p>置换的运算用符号 <span class="math inline">\(\sigma\)</span> 表示，<span class="math inline">\(\sigma(a)=({a_{\sigma_{1}},a_{\sigma_{2}},\cdots,a_{\sigma_{n}}})\)</span>。</p>
<p>这个运算通过接受一个序列，返回这个序列置换后的结果。</p>
<p>我们称其为置换的“合成”（这里引用的是 <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvU291bGlzdC9zb2x1dGlvbi1wNDk4MA==">参考资料</span> 中的说法，严格的叫法我也不知道）。</p>
<h2 id="置换群">置换群</h2>
<p>如果一个元素为若干个排列，运算是置换的“合成”的“二元组”满足群的定义，我们称其为一个置换群。</p>
<p>容易发现如果元素为 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的全排列，那么这个“二元组”满足群的定义，下面简单验证一下：</p>
<ol type="1">
<li>封闭性，显然，因为“合成”之后仍然是 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的一个排列。</li>
<li>单位元 <span class="math inline">\(e=(1,2,\cdots,n)\)</span>。</li>
<li>结合律 / 逆元：容易验证存在。</li>
</ol>
<h1 id="轨道-稳定子定理">轨道-稳定子定理</h1>
<h2 id="群作用">群作用</h2>
<p>对于一个群 <span class="math inline">\(G\)</span> 和集合 <span class="math inline">\(M\)</span>，若有一个二元函数 <span class="math inline">\(\varphi(g,m),g\in G,m\in M\)</span> 满足下列要求，则称群 <span class="math inline">\(G\)</span> 作用于集合 <span class="math inline">\(M\)</span>。 <span class="math display">\[
\varphi(e,m)=m
\]</span></p>
<p><span class="math display">\[
\varphi(g_1\cdot g_2,m)=\varphi(g1,\varphi(g_2,m))
\]</span></p>
<h2 id="轨道">轨道</h2>
<p>假如群 <span class="math inline">\(G\)</span> 作用与集合 <span class="math inline">\(X\)</span>，那么称元素 <span class="math inline">\(x\in X\)</span> 通过 <span class="math inline">\(G\)</span> 中的元素能够转移到的元素集合为 <span class="math inline">\(x\)</span> 的轨道，记作 <span class="math inline">\(G(x)\)</span>。很形象吧。</p>
<h2 id="稳定子">稳定子</h2>
<p>使得 <span class="math inline">\(\varphi(g,x)=x\)</span> 的 <span class="math inline">\(g\)</span> 的集合称为 <span class="math inline">\(x\)</span> 的稳定子，记作 <span class="math inline">\(G^{x}\)</span>。</p>
<h2 id="举个离子">举个离子</h2>
<p>想必上述内容过于抽象了，那就举一个 <del>离子</del> 例子来说明一下吧。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/r3qchaw6.png" /></p>
<p>来源：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvU291bGlzdC9zb2x1dGlvbi1wNDk4MA==">参考资料</span>，侵权删除。</p>
<h2 id="定理内容">定理内容</h2>
<p>铺垫了这么多，就是想说：</p>
<p>轨道大小和稳定子的大小的乘积恰好为的群 <span class="math inline">\(G\)</span> 的大小。</p>
<p>用符号表示就是 <span class="math inline">\(\vert G(x)\vert\times \vert G^x\vert=\vert G\vert\)</span>。</p>
<h2 id="证明">证明</h2>
<p>首先可以发现 <span class="math inline">\(G^x\)</span> 是 <span class="math inline">\(G\)</span> 的一个子群。</p>
<p>接着发现 <span class="math inline">\([G:G^x]=\vert G(x)\vert\)</span>。</p>
<p>由拉格朗日定理得证！</p>
<p>首先证明 <span class="math inline">\(G^x\)</span> 是 <span class="math inline">\(G\)</span> 的一个子群。</p>
<ol type="1">
<li>由稳定子的定义可以得到 <span class="math inline">\(G^x\)</span> 的元素组成的集合是 <span class="math inline">\(G\)</span> 中元素集合的子集。</li>
<li><span class="math inline">\(G^x\)</span> 满足封闭性，如果有 <span class="math inline">\(f\in G^x,g\in G^x\)</span>，那么 <span class="math inline">\(\varphi(f\cdot g)=\varphi(f,\varphi(g,x))=x\)</span>。</li>
<li><span class="math inline">\(G^x\)</span> 满足结合律，这由 <span class="math inline">\(G\)</span> 满足结合律得到。</li>
<li><span class="math inline">\(G^x\)</span> 具有单位元 <span class="math inline">\(e\)</span>，这是因为 <span class="math inline">\(e\)</span> 必定是 <span class="math inline">\(x\)</span> 的一个稳定子。</li>
<li><span class="math inline">\(G^x\)</span> 中的每一个元素 <span class="math inline">\(g\)</span> 都具有逆元，因为 <span class="math inline">\(\varphi(g^{-1},x)=\varphi(g^{-1},\varphi(g,x))=\varphi(g\cdot g^{-1},x)=\varphi(e,x)=x\)</span>。</li>
</ol>
<p>接下来证明 <span class="math inline">\([G:G^x]=\vert G(x)\vert\)</span>，也就是 <span class="math inline">\(G\)</span> 中 <span class="math inline">\(G^x\)</span> 的陪集数量恰好等于 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(G\)</span> 作用下的轨道大小。</p>
<p>利用构造双射来证明，也就是陪集和轨道一一对应。</p>
<p>先证明相同轨道对应相同陪集。对于 <span class="math inline">\(f,g\in G\)</span>，<span class="math inline">\(x\)</span> 在 <span class="math inline">\(f,g\)</span> 的作用下转移到了 <span class="math inline">\(\varphi(f,x)\)</span> 和 <span class="math inline">\(\varphi(g,x)\)</span>。如果 <span class="math inline">\(\varphi(f,x)=\varphi(g,x)\)</span>，那么 <span class="math inline">\(\varphi(f\cdot g^{-1},x)=\varphi(g^{-1},\varphi(f,x))=\varphi(g^{-1},\varphi(g,x))=\varphi(e,x)=x\)</span>，也就是说 <span class="math inline">\(f\cdot g^{-1}\in G^x\)</span>，由陪集的性质可以得到，<span class="math inline">\(fG=gG\)</span>。</p>
<p>反过来便可以推出相同陪集对应相同轨道。</p>
<p>由此得证！</p>
<h1 id="burnside-引理">Burnside 引理</h1>
<p>推了这么多只是为了引出今天的主角：Burnside 引理和 Pólya 定理。</p>
<h2 id="等价类">等价类</h2>
<p>等价类是对于一个置换群 <span class="math inline">\(G\)</span> 作用于一个集合 <span class="math inline">\(X\)</span> 的情况下定义的。如果 <span class="math inline">\(\varphi(g,x)=y\)</span>，那么我们认为 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 在同一等价类中。</p>
<p>每一个等价类是一个集合，集合中的元素之间能够通过进行若干次这个二元函数后相等。</p>
<p>记 <span class="math inline">\(X/G\)</span> 表示 <span class="math inline">\(G\)</span> 作用在 <span class="math inline">\(X\)</span> 后产生的所有等价类的集合。</p>
<h2 id="内容">内容</h2>
<p><span class="math display">\[
\vert X/G\vert=\vert G\vert\sum_{g\in G}\vert X^g\vert
\]</span></p>
<p>这里 <span class="math inline">\(\vert X^g\vert\)</span> 表示 <span class="math inline">\(X\)</span> 集合中有多少个元素的稳定子包含 <span class="math inline">\(g\)</span>。</p>
<p>用文字描述就是：<span class="math inline">\(G\)</span> 作用于 <span class="math inline">\(X\)</span> 产生的等价类数量等于 <span class="math inline">\(x\)</span> 稳定子包含 <span class="math inline">\(g\)</span> 的数量的算术平均值。</p>
<h2 id="证明-1">证明</h2>
<p>我们用另一种形式表示 <span class="math inline">\(\sum_{g\in G}\vert X^g\vert\)</span>，像这样 <span class="math inline">\(\sum_{x\in X}\vert G^x\vert\)</span>，我们对这个形式进行变换： <span class="math display">\[
\begin{aligned}
\sum_{x\in X}\vert G^x\vert&amp;=\sum_{x\in X}\frac{\vert G\vert}{\vert G(x)\vert}&amp;\text{轨道-稳定子定理}\\
&amp;=\vert G\vert\sum_{x\in X}\frac{1}{\vert G(x)\vert}\\
&amp;=\vert G\vert\sum_{Y\in X/G}\sum_{x\in Y}\frac{1}{\vert G(x)\vert}\\
&amp;=\vert G\vert\sum_{Y\in X/G}\sum_{x\in Y}\frac{1}{\vert Y\vert}\\
&amp;=\vert G\vert\sum_{Y\in X/G}1\\
&amp;=\vert G\vert\vert X/G\vert
\end{aligned}
\]</span> 也就是说我们证明了 <span class="math inline">\(\sum_{g\in G}\vert X^g\vert=\vert G\vert\vert X/G\vert\)</span>。</p>
<p>将 <span class="math inline">\(\vert G\vert\)</span> 除过去得到 Burnside 引理。</p>
<h1 id="模板polya-定理"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ5ODA=">【模板】Polya 定理</span></h1>
<h2 id="题目大意">题目大意</h2>
<p><span class="math inline">\(n\)</span> 种颜色给 <span class="math inline">\(n\)</span> 个点染色，问多少种本质不同的染色方案。本质不同定义为循环不同构。</p>
<p><span class="math inline">\(n\le 10^{9}\)</span>，多测，<span class="math inline">\(t\le 10^{3}\)</span>。</p>
<h2 id="解法">解法</h2>
<p>设群 <span class="math inline">\(G\)</span> 为旋转 1 次，旋转 2 次，……，旋转 <span class="math inline">\(n\)</span> 次组成置换群。</p>
<p>集合 <span class="math inline">\(X\)</span> 为染色的方案的集合。</p>
<p>群 <span class="math inline">\(G\)</span> 作用于集合 <span class="math inline">\(X\)</span> 上，得到的一个等价类是同一种染色方案。所以我们只需要求等价类的数量即可。</p>
<p>利用 Burnside 引理，我们可以预见到，设 <span class="math inline">\(X^p\)</span> 表示 <span class="math inline">\(X\)</span> 集合中有多少个染色方案在旋转 <span class="math inline">\(p\)</span> 次之后，仍然相同，那么根据 Burnside 引理，我们知道 <span class="math inline">\(\vert X/G\vert=\frac{1}{\vert G\vert}\sum_{p\in G}X^p\)</span>，在这道题中，相当于： <span class="math display">\[
ans=\frac{1}{n}\sum_{i=1}^{n}X^{i}
\]</span> 如果旋转 <span class="math inline">\(i\)</span> 次之后和原来相同，其充要条件就是有长度为 <span class="math inline">\(j\)</span> 的循环节，且 <span class="math inline">\(j\vert i\)</span>。</p>
<p>另外我们知道 <span class="math inline">\(j\)</span> 还得满足 <span class="math inline">\(j\vert n\)</span>，也就是说循环节长度最长为 <span class="math inline">\(\gcd(i,n)\)</span>。所以 <span class="math inline">\(X^i\)</span> 可以转写为 <span class="math inline">\(n^{\gcd(i,n)}\)</span>，因为循环节内部可以任意染色。</p>
<p>也就是 <span class="math display">\[
ans=\frac{1}{n}\sum_{i=1}^{n}n^{\gcd(i,n)}
\]</span> 进行常见的变换 <span class="math display">\[
ans=\frac{1}{n}\sum_{d\vert n}n^{d}\sum_{i=1}^{\frac{n}{d}}[\gcd(i,\frac{n}{d})=1]
\]</span> 第二个 <span class="math inline">\(\Sigma\)</span> 就是欧拉函数，所以： <span class="math display">\[
ans=\frac{1}{n}\sum_{d\vert n}n^{d}\varphi(\frac{n}{d})
\]</span> 在本题中暴力计算欧拉函数是可以通过的，时间复杂度约为 <span class="math inline">\(O(n^{\frac{1}{2}+\epsilon})\)</span>，其中 <span class="math inline">\(\epsilon\)</span> 是一个任意大于 0 的实数（CHD说的）。</p>
<h1 id="pólya-定理">Pólya 定理</h1>
<p>我们发现置换群中，如果是 <span class="math inline">\(i\)</span> 置换到 <span class="math inline">\(p_i\)</span>，那么我们从 <span class="math inline">\(i\)</span> 向 <span class="math inline">\(p_i\)</span> 连一条边，那么一定会形成若干个置换环。将这些环染色，不难发现，如果要满足上面所说的，旋转之后是等价类，那么每一个环的颜色都应当是相同的。所以如果一种置换 <span class="math inline">\(g\in G\)</span> 有 <span class="math inline">\(c_g\)</span> 个环，那么 <span class="math display">\[
\vert X/G\vert=\frac{1}{\vert G\vert}\sum_{g\in G}m^{c_{g}}
\]</span> 其中 <span class="math inline">\(m\)</span> 是不同的颜色个数。</p>
<p>注意到这个定理和 Burnside 定理的不同之处在于 <span class="math inline">\(\Sigma\)</span> 后面的内容。<span class="math inline">\(m^{c_{g}}\)</span> 和 <span class="math inline">\(n^g\)</span>，按照上面的推理，可以发现两者是等价的。</p>
<h1 id="p1446-hnoi2008-cards"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE0NDY=">P1446 [HNOI2008] Cards</span></h1>
<h2 id="题目大意-1">题目大意</h2>
<p>将 <span class="math inline">\(n=r+b+g\)</span> 张牌染色，需要染出 <span class="math inline">\(r\)</span> 张红牌，<span class="math inline">\(b\)</span> 张蓝牌，<span class="math inline">\(g\)</span> 张绿牌。并给定 <span class="math inline">\(m\)</span> 种置换方案，这些置换满足封闭性，具有逆元。</p>
<p>如果两种染色方案通过洗牌能够相同，就认为这两种方案不是同一种方案。求方案数对给定的质数 <span class="math inline">\(p\)</span> 取模的结果。</p>
<p><span class="math inline">\(r,b,g\le 20,m\le60\)</span>。</p>
<h2 id="解法-1">解法</h2>
<p>因为这是例题，第一感觉是题目给出了一个置换群，那么我能不能使用 Polya 定理？那么求出每一种置换的数目之后，利用 Polya 定理就可以快速算出了。我发现这样的时间复杂度是 <span class="math inline">\(O(nm)\)</span> 的。数据范围这么小，不合理。</p>
<p>Polya 定理中，隐含了要求，其对于集合 <span class="math inline">\(X\)</span> 必须是所有可能的集合。也就是说，不能对颜色进行限制。但是这道题限制了每一种颜色的数目。</p>
<p>我继续分析道，仍然按照其思想，形成了若干个环，要想满足置换后相同，每一个环仍然要求具有相同的颜色。能否将 Polya 定理中的 <span class="math inline">\(m^{c_g}\)</span> 修改为将这些环染色，满足染成红色的环的个数和为 <span class="math inline">\(r\)</span> 以此类推。得到的方案数，累加起来，除以 <span class="math inline">\(\vert G\vert\)</span> 是否就可行了呢？</p>
<p>其实到这里就已经不再是 Polya 定理了，而是 Burnside 定理的形式了。我们其实是考虑了每一种置换，与有多少中染色方案满足，这就是 Burnside 定理。</p>
<p>所以使用背包计数即可。</p>
<h1 id="p3307-sdoi2013-项链"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzMDc=">P3307 [SDOI2013] 项链</span></h1>
<p>黑题果然不简单。</p>
<h2 id="题目大意-2">题目大意</h2>
<p><span class="math inline">\(n\)</span> 个点的一个环中，每一个点需要染 <span class="math inline">\([1,m]\)</span> 之中的三种颜色（同个一个点可以染多种相同的颜色）。</p>
<p>要求：</p>
<ol type="1">
<li>每一个点染的颜色的编号 <span class="math inline">\(\gcd\)</span> 为 1。</li>
<li>相邻两个点的颜色互不相同，这里定义不同是两个点染的颜色形成的可重集不同。</li>
</ol>
<p>现在要求有多少种本质不同的染色方案。两种染色方案相同，当且仅当将这个环旋转若干次之后相同。</p>
<p>多测，<span class="math inline">\(t\le 10,n\le 10^{14},m\le 10^{7}\)</span>。</p>
<h2 id="解法-2">解法</h2>
<p>首先解决这个 <span class="math inline">\(\gcd\)</span>，一眼莫反，直接上 <span class="math inline">\(O(m+tm)\)</span> 的暴力莫反。</p>
<p>然后要解决相邻不能相同的问题。我问 CHD，他说：每一个点不能和它左边的点颜色相同，所以每一个点都有 <span class="math inline">\(m-1\)</span> 种染色方案，总共就是 <span class="math inline">\((m-1)^{n}\)</span>。过不了样例。</p>
<p>我问 wtc，他说：设 <code>f[i][0/1]</code> 表示第 <span class="math inline">\(i\)</span> 个和第 1 个是否相同，然后矩阵优化。</p>
<p>最后解决本质不同，直接上 po 定理即可。时间复杂度我也不知道，因为 phi 函数是暴力求的。</p>
<p>最后 WA 一个点。原来是因为 <span class="math inline">\(n\ge mod\)</span>，所以可能存在 <span class="math inline">\(n\)</span> 是模数的倍数的情况。这时候，就对 <span class="math inline">\(mod^{2}\)</span> 取模。最后，如果 <span class="math inline">\(n\)</span> 是 <span class="math inline">\(mod\)</span> 的倍数，那么 <span class="math inline">\(ans\)</span> 先直接除以 <span class="math inline">\(mod\)</span>，然后求 <span class="math inline">\(\frac{n}{mod}\)</span> 在模 <span class="math inline">\(mod\)</span> 意义下的逆元，相乘即可（我也不知道为什么）。</p>
<p>然后 TLE 了，原来是因为最开始那个 gcd 我不用整除分块来算。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/NOIP2020-%E7%A7%BB%E7%90%83%E6%B8%B8%E6%88%8F%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/NOIP2020-%E7%A7%BB%E7%90%83%E6%B8%B8%E6%88%8F%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">NOIP2020 移球游戏题解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-28 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-28T00:00:00+00:00">2024-01-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 10:58:52" itemprop="dateModified" datetime="2024-03-23T10:58:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>921</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>题目链接：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDcxMTU=">Luogu</span> or <span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8zMzg4">LOJ</span></p>
<p>这是一道巧妙的构造题，其中蕴含了将规模较大的问题划归到规模小的问题的思想。</p>
<p>如果想要在比赛的时候做出这道题，那么观察样例绝对是不二法门，因为样例提供了丰富的信息。<del>虽然说笔者做题的时候没有观察过。</del></p>
<h2 id="从简单的问题出发">从简单的问题出发</h2>
<p>让我们试着解决 <span class="math inline">\(n=2\)</span> 的特殊部分，尽管这只有 10 分的部分分，但是对简单的情形分析，能为拓展到复杂情况提供好的引导。</p>
<p>现在我们有 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>，<span class="math inline">\(z\)</span>，三根柱子，<span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 上有两种颜色的球，让我们称其中一种颜色的球为 <strong>关键球</strong>。</p>
<p>我们希望将所有关键球移动到同一根柱子上。我们先考虑位于 <span class="math inline">\(x\)</span> 柱上的关键球，假设 <span class="math inline">\(x\)</span> 柱上有 <span class="math inline">\(c\)</span> 个关键球。</p>
<ol type="1">
<li>将 <span class="math inline">\(y\)</span> 柱上的前 <span class="math inline">\(c\)</span> 个球移动到 <span class="math inline">\(z\)</span> 柱上。</li>
<li>逐个考虑 <span class="math inline">\(x\)</span> 柱上的球：</li>
</ol>
<ul>
<li>如果这个球是关键球，那么移动其到 <span class="math inline">\(y\)</span> 柱上。</li>
<li>否则，移动其到 <span class="math inline">\(z\)</span> 柱上。</li>
</ul>
<p>注意到第一步，我们实际上是创造了两个空间，一个能容纳 <span class="math inline">\(c\)</span> 个球，另一个能容纳 <span class="math inline">\(m-c\)</span> 个球。</p>
<p>我们将 <span class="math inline">\(x\)</span> 柱上的球，按照其是否为关键球，分别放入这两个空间中，就能够分离 <span class="math inline">\(x\)</span> 上的关键球与非关键球了。</p>
<p>下面我们需要考虑原来 <span class="math inline">\(y\)</span> 柱上的关键球，我们仍然需要为关键球的放置创造空间。</p>
<ol start="3" type="1">
<li>将 <span class="math inline">\(z\)</span> 柱上的前 <span class="math inline">\(m-c\)</span> 个球移回 <span class="math inline">\(x\)</span> 柱。</li>
<li>将 <span class="math inline">\(y\)</span> 柱上的前 <span class="math inline">\(c\)</span> 个球移回 <span class="math inline">\(x\)</span> 柱。</li>
<li>将 <span class="math inline">\(z\)</span> 柱上剩余的 <span class="math inline">\(c\)</span> 个球移回 <span class="math inline">\(y\)</span> 柱。（这些球事实上来源于第一步中，从 <span class="math inline">\(y\)</span> 柱移来）</li>
<li>将 <span class="math inline">\(x\)</span> 柱上前 <span class="math inline">\(c\)</span> 个球移动到 <span class="math inline">\(z\)</span> 柱。</li>
</ol>
<p>我们发现，此时 <span class="math inline">\(x\)</span> 柱上剩下的是非关键球，<span class="math inline">\(z\)</span> 柱上都是关键球，而 <span class="math inline">\(y\)</span> 柱上的球正是它原来的那些球。</p>
<p>下面我们将 <span class="math inline">\(y\)</span> 柱上的球移动：</p>
<p>逐个考虑 <span class="math inline">\(y\)</span> 柱上的球：</p>
<ol start="7" type="1">
<li>如果这个球是关键球，那么移动其到 <span class="math inline">\(z\)</span> 柱上。</li>
<li>否则，移动其到 <span class="math inline">\(x\)</span> 柱上。</li>
</ol>
<p>这样我们就移动完成了，此时 <span class="math inline">\(x\)</span> 柱上都是非关键球，<span class="math inline">\(z\)</span> 柱上都是关键球。</p>
<p>这样子只需要操作 <span class="math inline">\(O(m)\)</span> 步，更具体地，考虑每一步的步数，可以得到： <span class="math display">\[
c+m+(m-c)+c+c+c+m=3m+3c
\]</span></p>
<h2 id="拓展到原问题">拓展到原问题</h2>
<p>如果有 <span class="math inline">\(n\)</span> 个柱子该怎么办呢？一个好的想法是分治。</p>
<p>具体地，我们用 <code>solve(l,r)</code> 解决所有球的颜色都在 <span class="math inline">\([l,r]\)</span> 之间的问题。</p>
<p>我们试图让每一个柱子上都只有 <span class="math inline">\(\le mid\)</span> 的，或是只有 <span class="math inline">\(&gt;mid\)</span> 的颜色。</p>
<p>这样我们就可以在解决完成当前问题后递归解决啦！</p>
<p>我们设 <span class="math inline">\(mid=\lfloor\frac{l+r}{2}\rfloor\)</span>，我们枚举其中的两个柱子 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>，那么：</p>
<ul>
<li>如果 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(y\)</span> 中 <span class="math inline">\(\le mid\)</span> 的个数超过了 <span class="math inline">\(m\)</span> 个，那么我们钦定颜色 <span class="math inline">\(\le mid\)</span> 的为关键球，按照规模为 2 的算法计算即可。</li>
<li>否则，我们钦定颜色 <span class="math inline">\(&gt;mid\)</span> 的为关键球，仍然按照规模为 <span class="math inline">\(2\)</span> 的算法计算。</li>
</ul>
<p>接下来 <code>solve(l,mid)</code> 和 <code>solve(mid+1,r)</code> 即可。</p>
<p>注意到每一次都会让其中一个柱子中的球都为关键球，也就是说，我们最多进行 <span class="math inline">\(O(r-l+1)\)</span> 次这样的操作。</p>
<p>每次操作进行 <span class="math inline">\(O(m)\)</span> 次移动，会递归 <span class="math inline">\(\log n\)</span> 层，也就是 <span class="math inline">\(O(nm\log n)\)</span>，是能够通过的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/%E8%B4%AA%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E8%B4%AA%E5%BF%83/" class="post-title-link" itemprop="url">贪心</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-20T00:00:00+00:00">2024-01-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 10:58:52" itemprop="dateModified" datetime="2024-03-23T10:58:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>贪心是常见的一种算法，通常能够在较低的复杂度内，通过正确的决策得到答案。</p>
<p>常见的贪心方法有邻项交换法、反悔贪心等。</p>
<h1 id="邻项交换法">邻项交换法</h1>
<h2 id="noip2012-提高组-国王游戏"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwODA=">NOIP2012 提高组 国王游戏</span></h2>
<h3 id="题目大意">题目大意</h3>
<p>有 <span class="math inline">\(n+1\)</span> 个二元组 <span class="math inline">\((a_{i},b_{i})\)</span>，编号为 0 到 n。可以任意重新排列第 1 到 n 个二元组。</p>
<p>定义每个二元组的权值 <span class="math inline">\(c_{i}\)</span> 为： <span class="math display">\[
c_{i}=\frac{\prod_{j=0}^{i-1}a_{j}}{b_{i}}
\]</span> 要求最小化： <span class="math display">\[
\max_{i=1}^{n}(c_{i})
\]</span> ### 解法</p>
<p>考虑邻项交换法，即什么时候，交换相邻的两项能够使得答案更优。</p>
<p>假设第 <span class="math inline">\(i\)</span> 项前 <span class="math inline">\(a\)</span> 的乘积为 <span class="math inline">\(s\)</span>，那么更优的条件是： <span class="math display">\[
\max(\frac{s}{b_{i}},\frac{s\times a_{i}}{b_{i+1}})&lt;\max(\frac{s}{b_{i+1}},\frac{s\times a_{i+1}}{b_{i}})
\]</span> 做一下变换： <span class="math display">\[
\begin{aligned}
\max(\frac{1}{b_{i}},\frac{a_{i}}{b_{i+1}})&amp;&lt;\max(\frac{1}{b_{i+1}},\frac{a_{i+1}}{b_{i}})\\
\max(b_{i+1},a_{i}\times b_{i})&amp;&lt;\max(b_{i},a_{i+1}\times b_{i+1})
\end{aligned}
\]</span> 我们按照这个式子进行排序，接着依照题意模拟即可得出答案。</p>
<hr />
<p>事实上，我们只需要比较 <span class="math inline">\(a_{i}\times b_{i}&lt;a_{i+1}\times b_{i+1}\)</span> 即可。</p>
<p>由于 <span class="math inline">\(a_{i}&gt;0\)</span>，所以有 <span class="math inline">\(b_{i+1}\le a_{i+1}\times b_{i+1}\)</span>，<span class="math inline">\(b_{i}\le a_{i}\times b_{i}\)</span>。</p>
<p>证明只需要分类考虑：</p>
<ul>
<li>左边的最大值取到 <span class="math inline">\(b_{i+1}\)</span> 时，因为 <span class="math inline">\(b_{i+1}\le a_{i+1}\times b_{i+1}\)</span>，此时左边小于右边，如果将左边换成更小的 <span class="math inline">\(a_{i}\times b_{i}\)</span>，左边小于右边仍然成立。</li>
<li>右边的最大值取到 <span class="math inline">\(b_{i}\)</span> 时，因为 <span class="math inline">\(b_{i}\le a_{i}\times b_{i}\)</span>，此时左边一定小于右边，如果将右边换成更小的 <span class="math inline">\(a_{i+1}\times b_{i+1}\)</span>，仍然满足左边小于右边。</li>
</ul>
<p>所以我们发现，如果最大值取到了 <span class="math inline">\(b_{i+1}\)</span> 或是 <span class="math inline">\(b_{i}\)</span> 时，使用另一项是等效的，我们只需要使用另一项比较即可！</p>
<p>为什么我们要拆开这个 <span class="math inline">\(\max\)</span> 呢？因为我们要证明其传递性，也就是如果 <span class="math inline">\(a_{i}\times b_{i}\le a_{j}\times b_{j}\)</span>，<span class="math inline">\(a_{j}\times b_{j}\le a_{k}\times b_{k}\)</span>，那么 <span class="math inline">\(a_{i}\times b_{i}\le a_{k}\times b_{k}\)</span>。如果不拆开 <span class="math inline">\(\max\)</span> 我们就难以证明这一点。如果不能满足传递性，我们排序之后模拟就是错误的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a,b=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">ans=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    ans.append([<span class="built_in">int</span>(ii) <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">input</span>().split()])</span><br><span class="line">ans.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>]*x[<span class="number">1</span>]))</span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    s=<span class="built_in">max</span>(s,a//ans[i][<span class="number">1</span>])</span><br><span class="line">    a*=ans[i][<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
<h2 id="atcoder-dp-x"><span class="exturl" data-url="aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2RwL3Rhc2tzL2RwX3g=">AtCoder DP X</span></h2>
<p>虽然这道题是 DP，但是其中使用了邻项交换法。</p>
<h3 id="题目大意-1">题目大意</h3>
<p>有 <span class="math inline">\(N(1\le N\le 10^{3})\)</span> 个块，每一个块有质量 <span class="math inline">\(w_{i}\)</span>，坚固度 <span class="math inline">\(s_{i}\)</span>，价值 <span class="math inline">\(v_{i}\)</span>（<span class="math inline">\(1\le w_{i},s_{i}\le 10^{4},1\le v_{i}\le 10^{9}\)</span>）。想要选出若干个块堆叠成一个塔，要求满足某一个块上方的块的 <span class="math inline">\(w\)</span> 之和不超过这一个块的 <span class="math inline">\(s\)</span>。求最大代价和。</p>
<h3 id="解法">解法</h3>
<p>看到这到题，容易想到设 <span class="math inline">\(f_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 个块，选择后质量和为 <span class="math inline">\(j\)</span> 的最大价值。转移并不难，是一个 01 背包。</p>
<p>但是转移的顺序该如何确定？也就是说，我们应该按照什么顺序来考虑这些块？</p>
<p>我们考虑如果我们把块 <span class="math inline">\(i\)</span> 放在块 <span class="math inline">\(j\)</span> 的上方，那么还可以放 <span class="math inline">\(s_{j}-w_{i}\)</span>。</p>
<p>反之，如果把 <span class="math inline">\(j\)</span> 放在 <span class="math inline">\(i\)</span> 的上方，那么还可以方 <span class="math inline">\(s_{i}-w_{j}\)</span>。</p>
<p>我们当然是先转移上方的，才能转移下方的，所以 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(j\)</span> 上方就要满足： <span class="math display">\[
s_{j}-w_{i}\ge s_{i}-w_{j}
\]</span> 也就是 <span class="math display">\[
s_{j}+w_{j}\ge s_{i}+w_{i}
\]</span> 所以我们按照 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(w\)</span> 之和从小到大排序，进行转移即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>,M=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> w,s,v;</span><br><span class="line">&#125;a[N];</span><br><span class="line">ll f[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a[i].w,&amp;a[i].s,&amp;a[i].v);</span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,[](Node x,Node y)&#123;<span class="keyword">return</span> x.s+x.w&lt;y.s+y.w;&#125;);</span><br><span class="line">  ll ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=a[i].s+a[i].w;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">      <span class="keyword">if</span>(j&lt;a[i].w)<span class="keyword">break</span>;</span><br><span class="line">      f[j]=<span class="built_in">max</span>(f[j],f[j-a[i].w]+a[i].v);</span><br><span class="line">      ans=<span class="built_in">max</span>(ans,f[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="yloi2019-梅深不见冬"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU1MjE=">yLOI2019 梅深不见冬</span></h2>
<h3 id="题目大意-2">题目大意</h3>
<p>按照欧拉序遍历一棵 <span class="math inline">\(n(1\le n\le 10^{5}+4)\)</span> 的树，每一个节点有一个需要放置的梅花数量 <span class="math inline">\(w_{i}(1\le w_{i}\le 1000)\)</span>。</p>
<p>规定每一个节点放置梅花的时候必须满足其所有 <strong>儿子</strong> 节点 <span class="math inline">\(v\)</span> 必须放置了恰好 <span class="math inline">\(w_{v}\)</span> 个梅花。</p>
<p>你可以在任何时候任何地点收回梅花，你可以以任意欧拉序遍历这一棵树。</p>
<p>求对于所有 <span class="math inline">\(i\)</span>，要在 <span class="math inline">\(i\)</span> 号点上放置 <span class="math inline">\(w_{i}\)</span> 个棉花至少需要多少个梅花。</p>
<h3 id="解法-1">解法</h3>
<p>考虑求对于某一个 <span class="math inline">\(i\)</span> 的答案，以欧拉序遍历，那么我们只需要考虑 <span class="math inline">\(i\)</span> 的子树即可。</p>
<p>假设点 <span class="math inline">\(i\)</span> 的答案为 <span class="math inline">\(ans_{i}\)</span>，<span class="math inline">\(i\)</span> 遍历儿子的顺序确定了，那么计算答案：</p>
<ul>
<li>遍历一个儿子 <span class="math inline">\(j\)</span> 以前，要将 1 到 j-1 这些儿子全部遍历，也就是说现在 1 到 j-1 这些儿子上都有梅花了，并且遍历节点 <span class="math inline">\(j\)</span> 也需要 <span class="math inline">\(ans_{j}\)</span> 个梅花，总共需要 <span class="math inline">\(ans_{j}+\sum_{k=1}^{j-1}w_{k}\)</span>。</li>
<li>以及遍历完所有儿子，那么 <span class="math inline">\(i\)</span> 也需要放置 <span class="math inline">\(w_{i}\)</span> 个梅花，需要 <span class="math inline">\(w_{i}+\sum_{j\in son_{x}}w_{j}\)</span> 的梅花。</li>
</ul>
<p>上面两个式子中的最大值就是 <span class="math inline">\(ans_{i}\)</span>。</p>
<hr />
<p>那么如何确定遍历儿子的顺序呢？我们发现如果有相邻的 <span class="math inline">\(i,j\)</span> 两个儿子，它们先后顺序对答案的贡献与其它儿子无关，所以可以考虑邻项交换。</p>
<p>如果儿子 <span class="math inline">\(i\)</span> 在儿子 <span class="math inline">\(j\)</span> 以前，就需要满足： <span class="math display">\[
\max(ans_{i},ans_{j}+w_{i})\le \max(ans_{j},ans_{i}+w_{j})
\]</span> 按照国王游戏类似的方法拆开这个 <span class="math inline">\(\max\)</span>，可以得到，上面的式子等价于： <span class="math display">\[
ans_{j}+w_{i}\le ans_{i}+w_{j}
\]</span> 也就是： <span class="math display">\[
w_{i}-ans_{i}\le w_{j}-ans_{j}
\]</span> 所以按照 <span class="math inline">\(ans_{i}-w_{i}\)</span> 从小到大排序后选择就是最优的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created: 2024.01.20 02:51:34 PM +0800</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">  <span class="type">int</span> head[N],nxt[N],to[N],tot;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u];</span><br><span class="line">    to[tot]=v;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;G;</span><br><span class="line"><span class="type">int</span> sonId[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=G.head[x];i;i=G.nxt[i])<span class="built_in">dfs</span>(G.to[i]);</span><br><span class="line">  <span class="type">int</span> sonCnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=G.head[x];i;i=G.nxt[i])sonId[++sonCnt]=G.to[i];</span><br><span class="line">  <span class="built_in">sort</span>(sonId+<span class="number">1</span>,sonId+sonCnt+<span class="number">1</span>,[](<span class="type">int</span> _,<span class="type">int</span> __)&#123;<span class="keyword">return</span> w[_]-ans[_]&lt;w[__]-ans[__];&#125;);</span><br><span class="line">  ll sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sonCnt;++i)&#123;</span><br><span class="line">    ans[x]=<span class="built_in">max</span>(ans[x],sum+ans[sonId[i]]);</span><br><span class="line">    sum+=w[sonId[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  ans[x]=<span class="built_in">max</span>(ans[x],sum+w[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;fa[i]),G.<span class="built_in">add</span>(fa[i],i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="反悔贪心">反悔贪心</h1>
<h2 id="国家集训队-种树"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE3OTI=">2011国家集训队 种树</span></h2>
<h3 id="题目大意-3">题目大意</h3>
<p>有 <span class="math inline">\(n(1\le n\le 2\times 10^{5})\)</span> 个数字 <span class="math inline">\(a_{i}\)</span> 围成一圈，选择一个数字之后，其相邻的两个数字就不能选择，求能够选择出的最大数字之和。</p>
<h3 id="解法-2">解法</h3>
<p>很容易可以得到一个 <span class="math inline">\(O(n^2)\)</span> 的 DP，但是时间难以承受。</p>
<p>我们考虑贪心。直接贪心，考虑每一次尽可能选择大的，然后标记左右两边的数字不能选择。</p>
<p>但是这样显然是错误的。例如 <code>10 9 1 9</code>，我们会选择 10，然后选 1。但是显然 9 和 9 会更优秀。</p>
<p>这该怎么办呢？我们反悔，不选择 10 了，改为选择 9 和 9。</p>
<p>具体而言，我们仍然从大向小选择，但是选择之后，我们留一条后路。</p>
<p>加入选择了 <span class="math inline">\(a_{i}\)</span>，那么我们将 <span class="math inline">\(a_{i}\)</span> 替换为 <span class="math inline">\(a_{l_{i}}+a_{r_{i}}-a_{i}\)</span>。这样，当再次选择 <span class="math inline">\(i\)</span> 的时候，就相当于原来没有选择 <span class="math inline">\(a_{i}\)</span>，而是选择了其左右两边的。</p>
<p>使用双向链表维护左右两边的是那些数字即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Created: 2024.01.20 03:39:41 PM +0800</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N],l[N],r[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  l[r[x]]=l[x];</span><br><span class="line">  r[l[x]]=r[x];</span><br><span class="line">  l[x]=r[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pi&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">if</span>(m&gt;n/<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),q.<span class="built_in">push</span>(&#123;a[i],i&#125;);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)l[i]=i<span class="number">-1</span>,r[i]=i+<span class="number">1</span>;</span><br><span class="line">  l[<span class="number">1</span>]=n;r[n]=<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(cnt&lt;m)&#123;</span><br><span class="line">    pi tmp=q.<span class="built_in">top</span>();</span><br><span class="line">    <span class="type">int</span> cur=tmp.second;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(vis[cur])<span class="keyword">continue</span>;</span><br><span class="line">    ans+=tmp.first;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;a[l[cur]]+a[r[cur]]-a[cur],cur&#125;);</span><br><span class="line">    a[cur]=a[l[cur]]+a[r[cur]]-a[cur];</span><br><span class="line">    vis[l[cur]]=<span class="literal">true</span>;vis[r[cur]]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">remove</span>(l[cur]);<span class="built_in">remove</span>(r[cur]);</span><br><span class="line">    ++cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/GDKOIDay2T2%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/GDKOIDay2T2%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">GDKOI Day2 T2 计算题解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-15T00:00:00+00:00">2024-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 10:58:52" itemprop="dateModified" datetime="2024-03-23T10:58:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>看不清公式可以放大。</p>
<p>题意简单转化</p>
<p>首先有 <span class="math inline">\(\gcd(x^{a}-1,x^{b}-1)+1=x^{\gcd(a,b)}\)</span>。</p>
<blockquote>
<p>证明：</p>
<p>因为当 <span class="math inline">\(a\ge b\)</span> 时， <span class="math inline">\(\gcd(a,b)=\gcd(a-b,b)\)</span>。</p>
<p>让我们钦定 <span class="math inline">\(a\ge b\)</span>，那么</p>
<p>考虑 <span class="math inline">\(\gcd(x^{a}-1,x^{b}-1)=\gcd(x^{a}-x^{b},x^{b}-1)=\gcd(x^{b}(x^{a-b}-1),x^{b}-1)\)</span></p>
<p>由于 <span class="math inline">\(\gcd(x^{b},x^{b}-1)=1\)</span>，所以</p>
<p><span class="math inline">\(\gcd(x^{b}(x^{a-b}-1),x^{b}-1)=\gcd(x^{a-b}-1,x^{b}-1)\)</span></p>
<p>我们发现指数在更相减损！</p>
<p>直到更相减损结束的时候，即 <span class="math inline">\(\gcd(x^{\gcd(a,b)}-1,x^{0}-1)\)</span> 时，我们得到原式为 <span class="math inline">\(x^{\gcd(a,b)}-1\)</span>。</p>
</blockquote>
<hr />
<p>发现 <span class="math inline">\(m\vert L-1\)</span> 且 <span class="math inline">\(m\vert R\)</span>，将 <span class="math inline">\(L,R\)</span> 都减去 <span class="math inline">\(L\)</span>，原问题相当于 <span class="math inline">\([1,N]\)</span> 的问题。</p>
<p>这题中有多项式 <span class="math inline">\(f(x)=(1+x)(1+x^{2})(1+x^{3})\cdots (1+x^{k})=c_{0}+c_{1}x+c_{2}x^{2}+\cdots+c_{t}x^{t}\)</span>。</p>
<p>我们知道展开这个多项式，就相当于在每一个括号内选取一项相乘。</p>
<p><span class="math inline">\((1+x^{i})\)</span>，如果选择1，乘积的指数不变，表示子集中没有 <span class="math inline">\(i\)</span>。如果选择 <span class="math inline">\(x^{i}\)</span>，乘积的指数增加了 <span class="math inline">\(i\)</span>，表示子集中有 <span class="math inline">\(i\)</span>。那么如果展开后有一项 <span class="math inline">\(c_{i}x^{i}\)</span>，其中 <span class="math inline">\(c_{i}\)</span> 是系数，那么 <span class="math inline">\(c_{i}\)</span> 就表示子集和为 <span class="math inline">\(i\)</span> 的方案数。</p>
<p>因为 <span class="math inline">\(x\)</span> 是任意代入的，所以我们希望代入一些具有优秀性质的 <span class="math inline">\(x\)</span> 来简化我们的运算。</p>
<hr />
<p>引理 <span class="math display">\[
[m\vert i]=\frac{1}{m}\sum_{k=0}^{m-1}\omega_{m}^{ik}
\]</span> 证明：</p>
<p>考虑等比数列求和：<span class="math inline">\(S=\frac{\omega_{m}^{im}-1}{\omega_{m}^{i}-1}\)</span>，分类讨论：</p>
<ul>
<li>当 <span class="math inline">\(\omega_{m}^{i}\not=1\)</span> 时，可以知道 <span class="math inline">\(i\)</span> 不是 <span class="math inline">\(m\)</span> 的倍数，并且 <span class="math inline">\(\omega_{m}^{im}-1\)</span> 为0。</li>
<li>当 <span class="math inline">\(\omega_{m}^{i}=1\)</span> 时，可以知道 <span class="math inline">\(i\)</span> 是 <span class="math inline">\(m\)</span> 的倍数，并且由于分母为0，此时不能使用等比数列求和公式，所以特判。此时 <span class="math inline">\(\omega_{m}^{ik}=1\)</span>，因为 <span class="math inline">\(i\)</span> 是 <span class="math inline">\(m\)</span> 的倍数。得到 <span class="math inline">\(\sum_{k=0}^{m-1}\omega_{m}^{ik}=m\)</span>，所以除以 <span class="math inline">\(m\)</span> 得到 1。</li>
</ul>
<hr />
<p>将 <span class="math inline">\(m\)</span> 次单位根代入得到 <span class="math inline">\(\sum f(\omega_{m}^{i})\)</span>，展开，由引理得到只有 <span class="math inline">\(m\vert i\)</span> 时，系数为 <span class="math inline">\(c_{i}\)</span> 的项的和不为0。而下标为 <span class="math inline">\(m\)</span> 的倍数的数相加得到 <span class="math inline">\(m\times c_{k}\)</span>。故答案为 <span class="math display">\[
\frac{1}{m}\sum f(\omega_{m}^{i})
\]</span> 问题转化为快速计算该式子。</p>
<hr />
<p>当 <span class="math inline">\(m\)</span> 为奇素数的时候：</p>
<p>考虑：根据单位根的定义，我们可以对 <span class="math inline">\(z^{m}-1\)</span> 在复数域内进行因式分解。得到 <span class="math inline">\(z^{m}-1=(z-\omega_{m}^{0})(z-\omega_{m}^{1})\cdots(z-\omega_{m}^{m-1})\)</span>，代入 <span class="math inline">\(z=-1\)</span>，进一步得到 <span class="math inline">\(2=(1+\omega_{m}^{1})(1+\omega_{m}^{2})\cdots(1+\omega_{m}^{m})\)</span>。又因为 <span class="math inline">\(m\)</span> 是素数，所以 <span class="math inline">\((1+\omega_{m}^{i})(1+\omega_{m}^{2i})\cdots(1+\omega_{m}^{mi})\)</span> 的指数模 <span class="math inline">\(m\)</span> 组成了一个完全剩余系，其值仍然等于2。</p>
<blockquote>
<p>当然，如果 <span class="math inline">\(m\)</span> 为偶数的时候，可以得到 <span class="math inline">\(z^{m}=(-1)^{m}=1\)</span>，所以该式子等于0。</p>
</blockquote>
<p>进一步对其拓展，我们知道 <span class="math inline">\(n\)</span> 是 <span class="math inline">\(m\)</span> 的倍数，那么当 <span class="math inline">\(i&gt;0\)</span> 时， <span class="math inline">\(f(\omega_{m}^{i})=(1+\omega_{m}^{i})(1+\omega_{m}^{2i})\cdots(1+\omega_{m}^{ni})=2^{\frac{n}{m}}\)</span>。当 <span class="math inline">\(i=0\)</span> 时，该式等于 <span class="math inline">\(2^{n}\)</span>。</p>
<p>所以答案等于 <span class="math inline">\(\frac{1}{m}(2^{n}+(m-1)2^{\frac{n}{m}})\)</span>。</p>
<hr />
<p>拓展到 <span class="math inline">\(m\)</span> 一般的情况，考虑假设<span class="math inline">\((i,m)=p\)</span>，1~m分别乘 i 模 m 得到的剩余系，包含 <span class="math inline">\(\frac{m}{p}\)</span> 个数，是由 <span class="math inline">\(p\)</span> 个 模 <span class="math inline">\(\frac{m}{p}\)</span> 的完全剩余系中的数字乘 <span class="math inline">\(p\)</span> 得到的。</p>
<p>那么可以将 <span class="math inline">\((1+\omega_{m}^{i})(1+\omega_{m}^{2i})\cdots(1+\omega_{m}^{mi})\)</span> 按照模 <span class="math inline">\(m\)</span> 得到的值可以表示为 <span class="math inline">\([(1+\omega_{m}^{p})(1+\omega_{m}^{2p})\cdots(1+\omega_{m}^{m})]^{p}\)</span>。</p>
<p>所以 <span class="math inline">\(f(\omega_{m}^{i})=[(1+\omega_{m}^{p})(1+\omega_{m}^{2p})\cdots(1+\omega_{m}^{m})]^{p\times \frac{n}{m}}\)</span>。</p>
<p>注意到单位根的性质 <span class="math inline">\(\omega_{m}^{p}=\omega_{\frac{m}{p}}^{1}\)</span>，所以其实上式中括号内的部分就是 <span class="math inline">\((1+\omega_{\frac{m}{p}}^{1})(1+\omega_{\frac{m}{p}}^{2})\cdots(1+\omega_{\frac{m}{p}}^{\frac{m}{p}})\)</span>。</p>
<p>当 <span class="math inline">\(\frac{m}{p}\)</span> 为偶数的时候，上面的式子为0。当 <span class="math inline">\(\frac{m}{p}\)</span> 为奇数的时候，上面的式子为2。所以 <span class="math inline">\(f(\omega_{m}^{i})=2^{p\times\frac{n}{m}}[2\nmid \frac{m}{p}]\)</span>。</p>
<p>所以答案等于 <span class="math inline">\(\frac{1}{m}(2^{n}+\sum_{i=1}^{m-1}2^{\frac{n}{m}\times p}[2\nmid \frac{m}{p}])\)</span>。</p>
<p>我们之前特判了 <span class="math inline">\(i=0\)</span> 的情况，其实 <span class="math inline">\(i=0\)</span> 和 <span class="math inline">\(i=m\)</span> 是一样的，当 <span class="math inline">\(i=m\)</span> 时，<span class="math inline">\(p=m\)</span>，<span class="math inline">\(2^{\frac{n}{m}\times p}[2\nmid \frac{m}{p}])=2^{n}\)</span>，所以式子可以简化为： <span class="math display">\[
\frac{1}{m}(\sum_{i=0}^{m-1}2^{\frac{n}{m}\times p}[2\nmid \frac{m}{p}])
\]</span> 直接计算可以获得 85 分。</p>
<hr />
<p>进一步优化，观察到如果 <span class="math inline">\(2\vert \frac{m}{(i,m)}\)</span> 时，<span class="math inline">\(i\)</span> 对答案没有贡献。所以假设 <span class="math inline">\(m=2^{k}\times u\)</span>，其中 <span class="math inline">\(u\)</span> 是一个奇数，那么 <span class="math inline">\(i\)</span> 要求满足 <span class="math inline">\(i=2^{k}\times x\)</span>。</p>
<p>所以有： <span class="math display">\[
\begin{aligned}
\frac{1}{m}(\sum_{i=0}^{m-1}2^{\frac{n}{m}\times p}[2\nmid \frac{m}{p}])&amp;=\frac{1}{m}(\sum_{i=1}^{u}2^{\frac{n}{2^{k}\times u}\times \gcd(2^{k}\times u,2^{k}\times i)})\\
&amp;=\frac{1}{m}(\sum_{i=1}^{u}2^{\frac{n}{u}\times \gcd(u,i)})
\end{aligned}
\]</span> 考虑到 <span class="math inline">\(\gcd(u,i)\)</span> 为 <span class="math inline">\(u\)</span> 的约数，我们直接枚举 <span class="math inline">\(\gcd(u,i)\)</span>，也就是： <span class="math display">\[
\frac{1}{m}(\sum_{d\vert u}2^{\frac{n}{u}\times d}\times \varphi(\frac{u}{d}))
\]</span> 因为 <span class="math inline">\(\gcd(u,i)=d\)</span> 要求 <span class="math inline">\(\gcd(\frac{u}{d},\frac{i}{d})=1\)</span>，所以有多少个 <span class="math inline">\(\frac{i}{d}\)</span> 满足 <span class="math inline">\(\gcd(\frac{u}{d},\frac{i}{d})=1\)</span> 就是与 <span class="math inline">\(\frac{u}{d}\)</span> 互质的数字的个数。（此处题解写错了）</p>
<p>由于 <span class="math inline">\(u\)</span> 的特殊性（没有质因子2），所以其约数个数不会太多，1e7 之内大约只有 200 个（题解提供的数据），可以通过本题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/NOIP2016-%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5%E9%A2%98%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/NOIP2016-%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5%E9%A2%98%E8%A7%A3/" class="post-title-link" itemprop="url">NOIP2016 天天爱跑步 题解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-11T00:00:00+00:00">2024-01-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 10:58:52" itemprop="dateModified" datetime="2024-03-23T10:58:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="题目大意">题目大意</h2>
<p>给定一棵 <span class="math inline">\(n(991\le n\le 299998)\)</span> 个点的树，每个节点上有一个观察者，观察者在时刻 <span class="math inline">\(w_{i}\)</span> 进行观察。</p>
<p>现在有 <span class="math inline">\(m(991\le m\le 299998)\)</span> 条路径 <span class="math inline">\(s \rightarrow t\)</span>，每个路径上会有一个人，时刻0时从 <span class="math inline">\(s\)</span> 出发，沿着树上路径，向 <span class="math inline">\(t\)</span> 行走，每一个时刻走一条边，走到 <span class="math inline">\(t\)</span> 之后一个时刻消失。</p>
<p>问每一个观察者能够看到多少个人？</p>
<h2 id="转化">转化</h2>
<p>我们记 <span class="math inline">\(dep_{i}\)</span> 表示点 <span class="math inline">\(i\)</span> 的深度。</p>
<p>我们将一条路径 <span class="math inline">\(s\rightarrow t\)</span> 按照其 LCA 拆分为 <span class="math inline">\(s\rightarrow \text{LCA}\)</span> 和 <span class="math inline">\(\text{LCA}\rightarrow t\)</span> 两部分。</p>
<p>下面分别考虑这两部分：</p>
<ol type="1">
<li><p><span class="math inline">\(s\rightarrow \text{LCA}\)</span></p>
<p>那么，如果跑步者在经过 <span class="math inline">\(s\rightarrow \text{LCA}\)</span> 能够被节点 <span class="math inline">\(i\)</span> 上的观察者观察到，要满足：</p>
<p><span class="math display">\[
dep_{s}-dep_{i}=w_{i}
\]</span></p>
<p>也就是： <span class="math display">\[
dep_{s}=dep_{i}+w_{i}
\]</span></p>
<p>并且这条路径会经过 <span class="math inline">\(i\)</span> 这个点（因为有可能存在 <span class="math inline">\(i\)</span> 满足上面的式子，但是不经过点 <span class="math inline">\(i\)</span> ）。</p></li>
<li><p><span class="math inline">\(\text{LCA}\rightarrow t\)</span></p>
<p>如果跑步者在经过 <span class="math inline">\(\text{LCA}\rightarrow t\)</span> 能够被节点 <span class="math inline">\(i\)</span> 上的观察者观察到，要满足： <span class="math display">\[
(dep_{s}-dep_{lca})+(dep_{i}-dep_{lca})=w_{i}
\]</span> 也就是： <span class="math display">\[
dep_{s}-2\times dep_{lca}=w_{i}-dep_{i}
\]</span> 同样地，还要满足这条路径经过了 <span class="math inline">\(i\)</span> 这个点。</p></li>
</ol>
<h2 id="进一步转化">进一步转化</h2>
<p>进一步转化第二个条件，一条路径（指拆分成两段后的其中一段）经过了 <span class="math inline">\(i\)</span> 这个点，相当于 <span class="math inline">\(i\)</span> 的子树中包含恰好一个路径的端点。</p>
<p>具体地：</p>
<ul>
<li><p>如果 <span class="math inline">\(i\)</span> 的子树中包含 <span class="math inline">\(s\)</span> 但是不包含 <span class="math inline">\(\text{LCA}\)</span>，那么路径 <span class="math inline">\(s\rightarrow \text{LCA}\)</span> 一定 <strong>经过</strong> <span class="math inline">\(i\)</span>（可以画一下图感受一下）</p></li>
<li><p>如果 <span class="math inline">\(i\)</span> 的子树中包含了 <span class="math inline">\(s\)</span> 也包含了 <span class="math inline">\(\text{LCA}\)</span>，那么路径 <span class="math inline">\(s\rightarrow \text{LCA}\)</span> 一定 <strong>不经过</strong> <span class="math inline">\(i\)</span> 。</p></li>
<li><p>如果 <span class="math inline">\(i\)</span> 的子树中两者都不包含，那么路径 <span class="math inline">\(s\rightarrow \text{LCA}\)</span> 一定 <strong>不经过</strong> <span class="math inline">\(i\)</span> 。</p></li>
</ul>
<h2 id="解决">解决</h2>
<p>下面我们遍历树上的每一个节点，假设现在遍历到了点 <span class="math inline">\(i\)</span>，<span class="math inline">\(i\)</span> 上的观察者能够观察到几个人。</p>
<p>我将以 <span class="math inline">\(s\rightarrow \text{LCA}\)</span> 的这部分解决方法作为示例</p>
<p>我们使用一个桶 <span class="math inline">\(t_{d}\)</span> 来记录子树中深度为 <span class="math inline">\(d\)</span> 的有多少，那么观察者 <span class="math inline">\(i\)</span> 就会有 <span class="math inline">\(t[dep_{i}+w_{i}]\)</span> 的贡献。</p>
<p>关键在于如何维护桶。</p>
<h2 id="维护-t">维护 <span class="math inline">\(t\)</span></h2>
<p>先递归解决 <span class="math inline">\(i\)</span> 的儿子的问题，解决完毕，回溯到 <span class="math inline">\(i\)</span>。</p>
<p>有一些路径的一个端点在 <span class="math inline">\(i\)</span>，如果是 <span class="math inline">\(s\)</span>，我们就在桶里面加入，即 <code>++t[dep[s]]</code>，因为从此，这条路径开始产生贡献。</p>
<p>接下来统计答案，<code>ans[i]+=t[w[i]+dep[i]]</code> 。</p>
<p>接下来准备回溯到 <span class="math inline">\(i\)</span> 的父亲了，如果有一些路径的 LCA 在 <span class="math inline">\(i\)</span> 的话，我们就要将这条路径的贡献删去，即 <code>--t[dep[x]]</code>。</p>
<p>然后回溯即可！</p>
<h2 id="小问题">小问题</h2>
<p>按照我们的定义，<span class="math inline">\(t_{d}\)</span> 是以 <span class="math inline">\(i\)</span> 为根的子树中，<span class="math inline">\(dep[s]=d\)</span> 的路径数。</p>
<p>假设 <span class="math inline">\(i\)</span> 有两个儿子 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>，我们先递归解决了 <span class="math inline">\(x\)</span>，返回之后桶里面存储的是 <strong>以 <span class="math inline">\(x\)</span> 为根的子树，<span class="math inline">\(dep[s]=d\)</span> 的路径数</strong>。</p>
<p>接下来我们要递归解决 <span class="math inline">\(y\)</span>，但是桶里面有 <strong>以 <span class="math inline">\(x\)</span> 为根的子树</strong>，<span class="math inline">\(dep[s]=d\)</span> 的路径数，但是我们想知道 <strong>以 <span class="math inline">\(y\)</span> 为根的子树</strong>，<span class="math inline">\(dep[s]=d\)</span> 的路径数。</p>
<p>我们要设法消除解决 <span class="math inline">\(x\)</span> 时对 <span class="math inline">\(y\)</span> 产生的影响。</p>
<h3 id="法1">法1</h3>
<p>我们发现，我们只需要知道 <code>t[w[y]+dep[y]]</code> 的值。</p>
<p>那么我们在进入 <span class="math inline">\(y\)</span> 的时候，记录 <code>num1=t[w[y]+dep[y]]</code>，这其中只有以 <span class="math inline">\(x\)</span> 为根的子树的路径数。</p>
<p>当我们遍历完成 <span class="math inline">\(y\)</span> 的子树，记录 <code>num2=t[w[y]+dep[y]]</code>，这其中就有以 <span class="math inline">\(x\)</span> 为根和以 <span class="math inline">\(y\)</span> 为根的子树的路径数。</p>
<p>用 <code>num2-num1</code> 就可以求得以 <span class="math inline">\(y\)</span> 为根的子树的路径数。</p>
<h3 id="法2">法2</h3>
<p>不推荐使用，麻烦，复杂度多一个 <span class="math inline">\(\log\)</span>。</p>
<p>我们定义重儿子为子树大小最大的儿子（若有多个，任选一个），其它均称为轻儿子。</p>
<p>我们用树上启发式合并，先遍历所有轻儿子。每一次在遍历完轻儿子之后就立刻遍历其子树，反向操作（即原本加，现在减），达到删除的目的。</p>
<p>接着遍历重儿子，遍历完成之后不用清空桶（因为此时其它儿子都已经遍历完成了，不会再影响其它儿子）</p>
<p>再将所有轻儿子的子树遍历，将它们加进桶里。</p>
<h2 id="细节">细节</h2>
<p>注意到如果 LCA 能被观察到，那么被拆分出的两条路径都会统计到 LCA 的贡献。我们要减去其中一个。</p>
<p>如果有 <span class="math inline">\(dep_{s}=dep_{lca}+w_{lca}\)</span> 的路径，我们就将 <code>ans[lca]--</code> 。</p>
<h2 id="后记">后记</h2>
<p>注意到这篇题解并没有讨论如何计算转化部分第二条路径的答案，其实是一样的，大家推一推就可以知道了。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/gdkoi-2024-%E6%B8%B8%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/gdkoi-2024-%E6%B8%B8%E8%AE%B0/" class="post-title-link" itemprop="url">GDKOI 2024 游记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-08 21:48:07" itemprop="dateCreated datePublished" datetime="2024-01-08T21:48:07+00:00">2024-01-08</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>一转眼间 KOI2024 已经开始了，但是 KOI2023 仍然历历在目。</p>
<h2 id="省流">省流</h2>
<p>这次比赛发挥比较稳健，没有挂分。</p>
<h2 id="逆天-textday-x">逆天 / <span class="math inline">\(\text{Day}^{-x}\)</span></h2>
<p>比赛前这几天都在 <del>复习WHK</del> 腐败。</p>
<h2 id="第零天-textday-o">第零天 / <span class="math inline">\(\text{Day o}\)</span></h2>
<p>没有设备该怎么腐败呢？</p>
<p>车上看 LYX 写 NTT，真是太 curly 了。</p>
<p>本来想推一推 FFT 的（虽然说没有用），但是 ky_star 带了笔记本，我们便一起观看我 U 盘里的神秘视频（#include<WC2022 宣传片>，#include<ZSSSX学校宣传片>），真是太好看了，可惜没有声音。本校学长 LZC 友情出镜，但是在镜头下写了一堆 for 套 for，估计是被迫营业。</p>
<p>好容易等到酒店，这酒店可真高级，看起来就是比麦克阿瑟还要多几颗星。</p>
<p>小度：本酒店已安装全屋监控系统。</p>
<p>我：？？？</p>
<p>晚上 【数据删除】 说我们是带着任务来的，不是来享受的。深以为然。</p>
<p>结束之后去逛街，但是我不喜欢逛街，刚跑出去就后悔了，转了半个小时回房间腐败。</p>
<h2 id="第一天-textday-1">第一天 / <span class="math inline">\(\text{Day 1}\)</span></h2>
<h3 id="赛前">赛前</h3>
<p>本着这次比赛是省选组的难度，估计做不出来，决定把部分分尽可能多拿。</p>
<h3 id="赛时">赛时</h3>
<p>第一题的前两档很显然是状压DP，40分很容易可以拿到。当机立断决定把这40分先拿下，实在想不到正解的时候有保底的分数，想到正解可以用来对拍。</p>
<p>第二题题意不是很复杂，感觉是比较可做的题目。分析了一下部分分，第一档是暴力，第二档是输出0，第三档是前缀和优化，都比较简单，总共有60分的部分分。所以直接开始写，写完之后对拍，没有问题。想冲一冲正解（毕竟看起来是最简单的一题），试了几种做法，都不是很可行。就直接做下一题。</p>
<p>第三题的题目看起来就比较复杂，想了一会，想不出什么很好的做法， 就决定先把10分的暴力分给拿到。</p>
<p>最后没有什么进展，就只是把大众分给拿到了。</p>
<h3 id="赛后">赛后</h3>
<p>很多同学都也只是写了这几档分，但是很多同学都写挂了，大众分都没有拿到，所以比较稳健地拿到了110分。</p>
<h3 id="晚上">晚上</h3>
<p>腐败腐了一个晚上。</p>
<p>巴托夫：叭叭叭！叭叭叭叭叭叭叭叭叭↓，叭叭叭叭叭叭叭叭叭叭叭叭↓，叭叭叭叭叭叭叭叭叭叭叭叭↑，叭叭↓</p>
<p>秋秋教我如何使用小度打开浏览器，强强强！</p>
<p>然后使用小度打了 At，切了AB就不想打了。</p>
<p>接着打Gen，比卡扎菲还要卡，Gen不动。</p>
<p>然后和秋秋一起看小约翰，看了一集整活大王，然后又给秋秋看了衣戈，挺有趣的，看完就睡觉了。</p>
<h2 id="第二天-textday-2">第二天 / <span class="math inline">\(\text{Day 2}\)</span></h2>
<h3 id="赛前-1">赛前</h3>
<p>居然忘记拿身份证了，早上行李放在签到处，顺便把身份证也放那了🤣。关键是我还不想提前入场，直到17分才入场，才发现身份证没带。赶紧跑去拿，还好在开考前拿到了。</p>
<h3 id="赛中">赛中</h3>
<p>可能是刚刚运动完的缘故，思维比较迅速，杂念也比较少。在读完T1之后推出了三条性质，依据此快速写了20分的部分分。还担心性质推错了，写了一个非常朴素的暴力，进行对拍，没有出现什么问题。</p>
<p>写完之后一时间没有什么进展，就顺便写了一下第二档的特殊性质，有10分。</p>
<p>写完之后突然发现，这些性质具有单调性，可以进行二分。又把二分给写了，但是性质三不具有单调性，一时间没有想出来该怎么处理。后来发现可以直接主席树维护，就上了主席树。</p>
<p>比较顺利地通过了对拍数据，但是突然发现空间爆了。还好当时怕爆空间，写了一个输出程序静态空间的东西，对拍的时候恍然发现560MIB了（空间限制512）。还好主席树可以开小一点（大约三个数组，每个可以少开1e7的数组），不然就要挂0了。</p>
<p>写完第一题已经十一点了。第二题题目看起来有点复杂，但是实际上也不是很复杂。仔细看了看就看明白了。依据题意模拟写出暴力，发现可以DP将其优化成多项式级别的。顺利写完了30分的档。</p>
<p>本来考虑DP是否可以使用矩阵乘法转移，但是一来比较复杂，二来这样只有10分，我还不如打第三题的20分暴力呢。</p>
<p>然后把第三题20分暴力写完了。还加了一点剪枝，试图通过更多的数据（事实证明不行）。</p>
<p>写完之后，又考虑了一下第二题的矩阵乘法，发现仍然不是很可做，所以就没有写。</p>
<h3 id="赛后-1">赛后</h3>
<p>比赛结束之后听同学说第三题可以高斯消元，确实是！我怎么没有想到呢？</p>
<p>今天仍然没有挂分，稳健地拿到了第一、二、三题的大众分。</p>
<p>凭借两天的稳定发挥，没有挂1分，260分踩线Au。</p>
<h2 id="总结">总结</h2>
<p>其实部分分拿完，至少不会太差。写部分分要快而准，不能犹豫。平时模拟赛总是不想写部分分，总想着多想一会儿正解，最后一无所获。</p>
<p>快速地写完部分分，才能为冲正解留下充足的时间。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/" class="post-title-link" itemprop="url">整除分块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-03 18:47:39" itemprop="dateCreated datePublished" datetime="2024-01-03T18:47:39+00:00">2024-01-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 10:58:52" itemprop="dateModified" datetime="2024-03-23T10:58:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>738</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>整除分块用于解决一类与 <span class="math inline">\(\lfloor \frac{k}{i}\rfloor\)</span> 相关的问题。</p>
<p>这里面的 <span class="math inline">\(k\)</span> 是常量。往往这一类问题，因为事实上 <span class="math inline">\(\lfloor \frac{k}{i}\rfloor\)</span> 的取值少于 <span class="math inline">\(k\)</span> 个，具体地，取值仅有 <span class="math inline">\(O(\sqrt{k})\)</span> 个！所以我们可以大大缩短我们计算的时间。</p>
<h1 id="一维整除分块">一维整除分块</h1>
<h2 id="简单介绍">简单介绍</h2>
<p>一维整除分块解决这样的问题：<span class="math inline">\(\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor\)</span> 的值。</p>
<p>我们可以想到：<span class="math inline">\(\lfloor \frac{n}{i}\rfloor\)</span> 的取值并不会太多，事实上，取值数量不会超过 <span class="math inline">\(O(\sqrt{n})\)</span> 个。</p>
<blockquote>
<p>证明：</p>
<ol type="1">
<li>当 <span class="math inline">\(i\le \sqrt{n}\)</span> 的时候，显然 <span class="math inline">\(\lfloor \frac{n}{i}\rfloor\)</span> 的取值不会超过 <span class="math inline">\(\sqrt{n}\)</span> 个。</li>
<li>当 <span class="math inline">\(i&gt;\sqrt{n}\)</span> 的时候，有 <span class="math inline">\(\frac{n}{i}\le \sqrt{n}\)</span>，所以 <span class="math inline">\(\lfloor \frac{n}{i}\rfloor\)</span> 的取值也不会超过 <span class="math inline">\(\sqrt{n}\)</span> 个。</li>
</ol>
</blockquote>
<p>所以我们只需要考虑找到这 <span class="math inline">\(O(\sqrt{n})\)</span> 种取值，并确定每一种取值有多少个即可。</p>
<p>如何求每一种取值有多少呢？我们容易发现：取同一个值的 <span class="math inline">\(i\)</span> 必然是连续的。并且取的值必然是递减的。</p>
<p>所以它们事实上形成了一个类似于块状的结构，所以我们考虑求出每一个块的左右端点，就可以知道它们的长度了。</p>
<p>假设左端点为 <span class="math inline">\(i\)</span>，有结论：右端点为 <span class="math inline">\(\lfloor\frac{n}{\lfloor\frac{n}{i}\rfloor}\rfloor\)</span>。</p>
<blockquote>
<p>证明：设 <span class="math inline">\(k=\lfloor \frac{n}{i}\rfloor\)</span>，那么显然有 <span class="math inline">\(k\le \frac{n}{i}\)</span>。</p>
<p>于是有 <span class="math inline">\(\lfloor\frac{n}{k}\rfloor\ge \lfloor\frac{n}{\frac{n}{i}}\rfloor=\lfloor i\rfloor=i\)</span>。</p>
</blockquote>
<p>当取等号的时候，即 <span class="math inline">\(i\)</span> 等于 <span class="math inline">\(\lfloor \frac{n}{k}\rfloor\)</span> 的时候，<span class="math inline">\(i\)</span> 是可能的最大的 <span class="math inline">\(i\)</span>。</p>
<p>于是我们就可以按照当前的左端点找到右端点，右端点加一得到下一段的左端点，便可以在 <span class="math inline">\(O(\sqrt{n})\)</span> 的时间内完成这项任务。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly92anVkZ2UubmV0L3Byb2JsZW0vVVZBLTExNTI2">板题</span></p>
<h2 id="数论分块">数论分块</h2>
<p>进一步地，我们可以解决这样的问题： <span class="math display">\[
\sum_{i=1}^{n}f(i)\lfloor\frac{n}{i}\rfloor
\]</span> 我们如果求得了 <span class="math inline">\(f\)</span> 的前缀和，记为 <span class="math inline">\(s\)</span>，我们就可以在 <span class="math inline">\(O(\sqrt{n})\)</span> 的时间内解决这个问题。</p>
<p>具体地，我们发现对于 <span class="math inline">\(\lfloor\frac{n}{i}\rfloor\)</span> 相等的一段区间 <span class="math inline">\([l,r]\)</span>，我们可以得到它们的答案为 <span class="math inline">\((s_r-s_{l-1})\lfloor\frac{n}{i}\rfloor\)</span>。</p>
<h1 id="n维整除分块">n维整除分块</h1>
<p>求 <span class="math inline">\(\sum_{i=1}^{n}\prod_{j=1}^{k}\lfloor\frac{n_{j}}{i}\rfloor\)</span>，也就是将求和的内容换成若干个可以整除分块的东西罢了。</p>
<figure>
<img src="https://oi-wiki.org/math/number-theory/images/n-dimension-sqrt-decomposition.png" alt="高维数论分块的示意图 图源:oi-wiki.org" /><figcaption aria-hidden="true">高维数论分块的示意图 图源:oi-wiki.org</figcaption>
</figure>
<p>不同颜色的线表示每一种颜色分出的段，蓝色线的意义如图所示，所以每一段中的乘积是相同的。</p>
<p>常用的是二维的数论分块，我们只需将 <code>r=n/(n/l)</code> 替换成 <code>r=min(n/(n/l),m/(m/l))</code> 即可。</p>
<p>容易发现，这样最多分出的段数仍然是 <span class="math inline">\(O(\sqrt{n})\)</span> 级别的。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/%E9%B2%9C%E8%8A%B1-%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E9%B2%9C%E8%8A%B1-%E5%BA%8F/" class="post-title-link" itemprop="url">鲜花 / 序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-01-02 19:00:00" itemprop="dateCreated datePublished" datetime="2024-01-02T19:00:00+00:00">2024-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-23 10:58:52" itemprop="dateModified" datetime="2024-03-23T10:58:52+00:00">2024-03-23</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>208</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>总是想写些什么，拿起笔，写下三两个字，又停下。</p>
<p>喜欢一个人发呆，望着落霞的齐飞，望着秋叶的愁容，望着远方的山，从清晰渐渐朦胧，从记忆里渐渐淡去。</p>
<p>在斟满回忆的烟雨中，看，一朵鲜花，她在淅沥中绽放。回眸间，雨凝结了时间，那抹芳香，向晚风中，丝丝缕缕，不知萦绕谁的心间。淡雨装点着她的美，朦胧中，将染山的霞光绚烂，隐约间，把落日的余晖点洒。</p>
<p>记不得你的模样，只剩下想象，无际的想象海洋，该用什么找回印象？彷徨，忧伤，如丁香般的惆怅。</p>
<p>希望，鲜花开遍，仍是春天。</p>
<blockquote>
<p>不是有希望，所以坚持，而是坚持，所以看到希望。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/%E7%BA%BF%E6%80%A7%E5%9F%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E7%BA%BF%E6%80%A7%E5%9F%BA/" class="post-title-link" itemprop="url">线性基</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-22 20:38:36" itemprop="dateCreated datePublished" datetime="2023-12-22T20:38:36+00:00">2023-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-28 17:21:09" itemprop="dateModified" datetime="2023-12-28T17:21:09+00:00">2023-12-28</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>线性基是解决OI中异或问题的利器。</p>
<p>知识点完善程度：初步了解，做题量不足。</p>
<h1 id="介绍">介绍</h1>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGpoMjAwMC1qdW1wL3AvNTg2OTk5MS5odG1s">1</span> <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vVHJvdmVybGQvcC8xNDYyMTQzNC5odG1s">2</span> <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FfZm9yZXZlcl9kcmVhbS9hcnRpY2xlL2RldGFpbHMvODM2NTQzOTc=">3</span></p>
<ol type="1">
<li><p><strong>简单理解</strong>：一个数列 <span class="math inline">\(b_{i}\)</span> 的线性基是一组数字，<span class="math inline">\(a_{1},a_{2},a_{3},\cdots,a_{k}\)</span>，其中 <span class="math inline">\(a_{x}=b_{i}\)</span> 表示 <span class="math inline">\(b_{i}\)</span> 满足 <span class="math inline">\(b_{i}\)</span> 最高位的1是第 <span class="math inline">\(x\)</span> 位。如果存在多个 <span class="math inline">\(b_{i}\)</span> 满足这个条件，任选其中一个。如果没有就为0。</p></li>
<li><p><strong>性质</strong>：</p>
<ol type="1">
<li>一个数列的线性基中的数进行异或能够得到的数，与原数列中的数异或能够得到的数字相同。这个性质的证明可以由下面的构造的得出。</li>
<li>线性基中的任意一些数字异或起来都不为0。这个也能由构造给出。</li>
<li>线性基的大小唯一，并且是 <span class="math inline">\(b_{i}\)</span> 的子集中，能够拥有性质1的最小的。</li>
</ol></li>
<li><p><strong>构造</strong>：对序列 <span class="math inline">\(b_{i}\)</span> 中的数字进行插入。从高到低枚举每一个位置。</p>
<ul>
<li>如果这一位为0，那么跳过。[操作0]</li>
<li>如果这一位为1（假设是第 <span class="math inline">\(x\)</span> 位），考虑两种情况：
<ul>
<li>如果 <span class="math inline">\(a_{x}\)</span> 不为0，那么将这个数字异或上 <span class="math inline">\(a_{x}\)</span>。[操作1]</li>
<li>如果 <span class="math inline">\(a_{x}\)</span> 为0，那么将这个数字放到 <span class="math inline">\(a_{x}\)</span> 上。直接退出即可。[操作2]</li>
</ul></li>
</ul></li>
<li><p>性质 1 的证明</p>
<p>如果插入的这个数字没有进行过操作2：说明通过线性基中的数字可以构造出这个数字。</p>
<p>如果插入的这个数字进行了操作2：进行操作2时，由于操作1的存在，这个数字高于 <span class="math inline">\(x\)</span> 位都为0了，此时插入线性基满足要求。</p>
<p>并且此时可以通过操作1的数字异或出这个数字的高 <span class="math inline">\(x\)</span> 位，再异或上 <span class="math inline">\(a_{x}\)</span> 就可以得到这个数字啦。</p>
<p>既然我们能够用线性基中的数字构造出原来的数列，那么也可以构造出原来数列能够异或出的集合啦。</p>
<p>如果一个数字是原来的序列不能够构造出的，那么线性基必然不能构造出。反证：如果线性基能够构造出，原数列也能构造出。</p></li>
<li><p>性质 2 的证明</p>
<p>如果有 <span class="math inline">\(a_{p_{1}},a_{p_{2}},a_{p_{3}},\cdots,a_{p_{k}}\)</span> 异或和为0，那么有 <span class="math inline">\(a_{p_{1}},a_{p_{2}},a_{p_{3}},\cdots,a_{p_{k-1}}\)</span> 的异或和为 <span class="math inline">\(a_{p_{k}}\)</span> （由 <span class="math inline">\(a\oplus b=0 \Rightarrow a=b\)</span> 得到）</p>
<p>所以我们可以直接把 <span class="math inline">\(p_{k}\)</span> 从线性基中删掉，这样才能满足性质3。</p></li>
<li><p>性质 3 的证明</p>
<ul>
<li><p>如果序列 <span class="math inline">\(b\)</span> 中的每一个数字都能插入到线性基中，那么这样一定是最小的。</p></li>
<li><p>如果有一个数字 <span class="math inline">\(b_{i}\)</span> 没能插入线性基，那么必然满足 <span class="math inline">\(c\oplus a_{j}=b_{i}\)</span> ，其中 <span class="math inline">\(c\)</span> 是 <span class="math inline">\(a\)</span> 中某些元素的异或和。</p>
<p>那么可以得到 <span class="math inline">\(c\oplus b_{i}=a_{j}\)</span>，也就是说，如果我们先插入了 <span class="math inline">\(b_{i}\)</span>，再插入 <span class="math inline">\(a_{j}\)</span>，那么 <span class="math inline">\(a_{j}\)</span> 不能被插入，线性基中元素个数不变。</p>
<p>并且如果我们删除线性基中的某一个元素，那么 <span class="math inline">\(b\)</span> 中必然有一些数字无法被表示，于是线性基的大小也是符合条件中最小的。</p></li>
</ul></li>
</ol>
<p>判断一个数字是否在原数列通过异或，能够构造出的集合中。</p>
<p>我们从高位到低位判断，如果某一位为1，那么就异或上 <span class="math inline">\(a_{x}\)</span> 。如果最后是0，那么不能被构造出，否则能够被构造出。</p>
<h1 id="应用">应用</h1>
<p>是例题，也是用法。</p>
<h2 id="最大异或和"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MTI=">最大异或和</span></h2>
<h3 id="题意">题意</h3>
<p>给定 <span class="math inline">\(n\)</span> 个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。</p>
<p><span class="math inline">\(1\le n\le 50\)</span>， <span class="math inline">\(0\le S_{i}\lt 2^{50}\)</span></p>
<h3 id="做法">做法</h3>
<p>直接做是 <span class="math inline">\(2^{n}\)</span> 的，线性基就可以了。</p>
<p>具体地，我们类似01-trie的贪心思想，每一次都异或上 <span class="math inline">\(a_{i}\)</span> 即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">50</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i])x^=a[i];</span><br><span class="line">      <span class="keyword">else</span>&#123;a[i]=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;ll x;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x),<span class="built_in">insert</span>(x);&#125;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">50</span>;i&gt;=<span class="number">0</span>;--i)<span class="keyword">if</span>((res^a[i])&gt;res)res^=a[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小异或和">最小异或和</h2>
<p>似乎没有这道题，那我胡一个。</p>
<p>题面类似求最大异或和。</p>
<p>但是做法不同。考虑如果有一个数字插入失败，那么异或和显然为0.</p>
<p>否则最小的 <span class="math inline">\(d_{i}\)</span> 就是答案。</p>
<h2 id="第k大异或和"><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8xMTQ=">第k大异或和</span></h2>
<h3 id="题意-1">题意</h3>
<p>给出一个 <span class="math inline">\(n\)</span> 个数的序列，可以从中任意选出一些，求它们的异或和。</p>
<p>询问 <span class="math inline">\(m\)</span> 次，每次要在得到的不同异或和中，找到第 <span class="math inline">\(k\)</span> <strong>小</strong>（题目名字具有误导性，是要找第 k 小）</p>
<p><span class="math inline">\(1\le n,m \lt 10^{5}\)</span>，<span class="math inline">\(0\le S_{i}\lt 2^{50}\)</span></p>
<h3 id="做法-1">做法</h3>
<p>这次我们要寻找性质更强的线性基。</p>
<p>具体地，一个序列的线性基其实不止一种。当我们将 <span class="math inline">\(a_{i}\)</span> 异或上某一个 <span class="math inline">\(a_{j}\)</span> 后，这个序列仍然是原数列的一组线性基，证明是比较显然的。</p>
<p>那么我们要找出一组最小的线性基。</p>
<p>具体地，我们从小到大枚举每一个 <span class="math inline">\(i\)</span>，对于 <span class="math inline">\(a_{i}\)</span>，从大到小再枚举一个 <span class="math inline">\(j\)</span>。如果 <span class="math inline">\(a_{i}\)</span> 的第 <span class="math inline">\(j\)</span> 位是1，那么 <span class="math inline">\(a_{i}\leftarrow a_{i}\oplus a_{j}\)</span> 。这样我们就能够把 <span class="math inline">\(a_{i}\)</span> 的第 <span class="math inline">\(j\)</span> 位上的1给消去。</p>
<p>并且由于我们是从大到小的枚举的 <span class="math inline">\(j\)</span>，之前消去过的1不会再出现。</p>
<p>这样处理过得一组线性基的有非常好的性质。那就是，当用 <span class="math inline">\(a_{i}\oplus a_{j}\)</span> 时，得到的结果必然比 <span class="math inline">\(a_{i}\)</span> 和 <span class="math inline">\(a_{j}\)</span> 都大，因为得到的结果的第 <span class="math inline">\(i\)</span> 位和第 <span class="math inline">\(j\)</span> 位都变成了1，而原来它们只有其中一个为1。</p>
<p>推广一下，如果我们已经选了若干个 <span class="math inline">\(a_{i}\)</span> ，得到了一个异或和。当我们再加入一个没加入过得 <span class="math inline">\(a_{j}\)</span> 时，结果只会变大。</p>
<p>如果我们用一个二进制数，第 <span class="math inline">\(i\)</span> 位表示 <span class="math inline">\(a_{i}\)</span> 是否被选入参与异或；那么如果有两个二进制数 <span class="math inline">\(S&lt;T\)</span>，那么 <span class="math inline">\(S\)</span> 对应的异或和必然小于 <span class="math inline">\(T\)</span> 对应的异或和。只需要考虑它们选择了 <span class="math inline">\(a_{i}\)</span> ，那么第 <span class="math inline">\(i\)</span> 位异或后为1。</p>
<p>于是我们可以将 <span class="math inline">\(k\)</span> 表示成二进制，如果第 <span class="math inline">\(i\)</span> 位为1，那么异或上第 <span class="math inline">\(i\)</span> 个 <strong>非0</strong> 的 <span class="math inline">\(a\)</span>（而不是 <span class="math inline">\(a_{i}\)</span>）。</p>
<p>还要注意，如果最小异或和为0，我们就要将 <span class="math inline">\(k\)</span> 减去1，因为我们刚刚没有考虑0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K=<span class="number">55</span>;</span><br><span class="line">ll a[K],b[K];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">50</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i])x^=a[i];</span><br><span class="line">      <span class="keyword">else</span>&#123;a[i]=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  flag=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">50</span>;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">      <span class="keyword">if</span>((a[i]&gt;&gt;j)&amp;<span class="number">1</span>)a[i]^=a[j];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">50</span>;++i)</span><br><span class="line">    <span class="keyword">if</span>(a[i])b[tot++]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(ll k)</span></span>&#123;</span><br><span class="line">  k-=flag;</span><br><span class="line">  <span class="keyword">if</span>(k&gt;=(<span class="number">1ll</span>&lt;&lt;tot))<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=tot;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>((k&gt;&gt;i)&amp;<span class="number">1</span>)res^=b[i];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;ll x;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);<span class="built_in">insert</span>(x);&#125;</span><br><span class="line">  <span class="built_in">preProcess</span>();</span><br><span class="line">  <span class="type">int</span> m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;ll k;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;k);<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">qry</span>(k));&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可删除线性基">可删除线性基</h2>
<p>现在要求支持一些操作：插入，删除，求最大异或和。</p>
<p>在线做法比较复杂，离线做法相对简单。</p>
<p>没有找到完全的模版题，自己造了一道，但是还没出好数据。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vVTM5MzUwOA==">模版链接</span></p>
<h3 id="在线做法">在线做法</h3>
<p>这些都是理论分析，还没写代码，可能存在错误。</p>
<p>插入就直接插。</p>
<p>删除的时候，如果删掉的数字在线性基外，直接删了就好，对答案没有影响。</p>
<p>如果删掉的数字在线性基内，这样不好直接删除。</p>
<ul>
<li><p>我们就考虑：当我们插入的时候，有一些没有插入成功的 <span class="math inline">\(x\)</span> ，它能够由线性基中的某些数的异或和表示 <span class="math inline">\(c\oplus a_{i}=x\)</span>，其中 <span class="math inline">\(c\)</span> 是线性基中某些数的异或和。我们变一下形，发现 <span class="math inline">\(c\oplus x=a_{i}\)</span>。</p>
<p>当我们用 <span class="math inline">\(a_{i}\)</span> 表示另一个数时，也可以用 <span class="math inline">\(x\)</span> 表示，<span class="math inline">\(c\oplus a_{i}\oplus y=x\oplus y\)</span>，我们发现 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(a_{i}\)</span> 是等价的。</p>
<p>也就是说，这些没有插入成功的数字可以“代替”在线性基中的一些数。</p>
<p>如果我们删除一个数，我们就把它替换成那个，能够代替的数。</p>
<p>这样不方便，我们不妨把那个代替的数给删掉，让李代桃僵，这样是等效的。</p>
<p>实现时直接维护 <span class="math inline">\(a_{i}\)</span> 有哪些可替代的数即可。</p></li>
<li><p>但是如果 <span class="math inline">\(a_{i}\)</span> 没有能够替代的数呢？</p>
<p>我们就必须要在线性基中消除 <span class="math inline">\(a_{i}\)</span> 的影响。我们考虑在插入的时候维护每一个数异或过哪些数字。</p>
<p>对于那些插入的时候异或过 <span class="math inline">\(a_{i}\)</span> 的数，我们回忆一下，插入的时候，我们将所有第 <span class="math inline">\(i\)</span> 位为1的数都异或上了 <span class="math inline">\(a_{i}\)</span>。删除的时候，我们就将它们全部异或上<span class="math inline">\(a_{i}\)</span>，但是这时候，它们的第 <span class="math inline">\(i\)</span> 位都为1，这在插入过程中显然是不可能出现的。</p>
<p>所以我们寻找一个最小的，异或过 <span class="math inline">\(a_{i}\)</span> 的数字。将它替换成 <span class="math inline">\(a_{i}\)</span>，那么其它数字在插入的时候，就会异或上新的 <span class="math inline">\(a_{i}\)</span>。</p>
<p>于是我们将其它异或过 <span class="math inline">\(a_{i}\)</span> 的数字都异或上新的 <span class="math inline">\(a_{i}\)</span> 即可。</p></li>
</ul>
<h3 id="离线做法">离线做法</h3>
<p>我们考虑贪心地进行插入的过程。</p>
<p>我们每次插入时，更高的位上，让线性基的删除时间更晚。因为如果时间到了，大的不能选，小的可以选，这不优。</p>
<p>所以我们让高位上的线性基的删除时间尽可能晚。</p>
<h4 id="代码">代码</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> tim,ll x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LEN;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">    <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(tim&gt;dTime[i])<span class="built_in">swap</span>(dTime[i],tim),<span class="built_in">swap</span>(bas[i],x);</span><br><span class="line">      <span class="keyword">if</span>(!tim)<span class="keyword">return</span>;</span><br><span class="line">      x^=bas[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(<span class="type">int</span> tim)</span></span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LEN;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(tim&lt;dTime[i]&amp;&amp;((res&gt;&gt;i)&amp;<span class="number">1</span>)==<span class="number">0</span>)res=<span class="built_in">max</span>(res,res^bas[i]);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="与图论结合">与图论结合</h2>
<h3 id="p4151-wc2011-最大xor和路径"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQxNTE=">P4151 [WC2011] 最大XOR和路径</span></h3>
<h4 id="题意-2">题意</h4>
<p>给出一个 <span class="math inline">\(n(1\le n\le 5\times 10^{4})\)</span> 个点，<span class="math inline">\(m(1\le m\le 10^{5})\)</span>无向图，边有权值，权值范围在 <span class="math inline">\([0,10^{18}]\)</span> 之间。</p>
<p>要求找出一条从1号点到n号点的路径，满足路径的异或和最大。</p>
<h4 id="做法-2">做法</h4>
<p>首先我们考虑从1到n，假设只有一条路径，大概是这样：</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/9rw2ca6s.png" alt="graph1" /><figcaption aria-hidden="true">graph1</figcaption>
</figure>
<p>但是我们发现实际上这个路径上可能有环。</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/e47kryh7.png" alt="graph2" /><figcaption aria-hidden="true">graph2</figcaption>
</figure>
<p>我们考虑加入环之后路径答案的变化。如果原来的异或和为 <span class="math inline">\(dis\)</span> ，那么加入环之后就变为 <span class="math inline">\(dis\oplus k1\oplus c1\oplus k1=dis\oplus c1\)</span>。</p>
<p>如果加入多个环，同理可得，答案变为 <span class="math inline">\(dis\oplus c1\oplus c2\)</span>。</p>
<p>也就是说，我们只需要找到这条路径，并异或上某些环的异或和即可。</p>
<p>但是如果1到n有多条路径呢？</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/wpuke3ed.png" alt="graph3" /><figcaption aria-hidden="true">graph3</figcaption>
</figure>
<p>假设左边路径的异或和为 <span class="math inline">\(dis_{1}\)</span>，右边路径的异或和为 <span class="math inline">\(dis_{2}\)</span>，两条路径构成的环异或和为 <span class="math inline">\(dis_{3}\)</span>，那么我们有： <span class="math display">\[
dis_{2}=dis_{1}\oplus dis_{3}
\]</span> 也就是说，右边的路径可以通过左边的路径异或上一个环得到。</p>
<p>综上所述，我们只需要解决两个任务：</p>
<ol type="1">
<li><p>找到任意一条1到n的路径，并找到图中的所有环。</p></li>
<li><p>答案这条路径异或上若干个环得到。</p></li>
</ol>
<p>找环的部分可以通过一个有趣的结论来解决：所有环可以通过基本环（由一条非树边及其端点在书上路径组成的环）异或得到。所以我们只需要在DFS生成树上找基本环即可。（P.S.当时笔者写这道题的时候是暴力找的环，直接T0了。）</p>
<p>求答案的最大值可以使用线性基多快好省地解决。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">5</span>,M=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">  <span class="type">int</span> head[N],nxt[M],to[M],tot;</span><br><span class="line">  ll dis[M];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll w)</span></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u];</span><br><span class="line">    dis[tot]=w;</span><br><span class="line">    to[tot]=v;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;G;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">ll sum[N];</span><br><span class="line">set&lt;ll&gt; cyc;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  vis[x]=<span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=G.head[x];i;i=G.nxt[i])</span><br><span class="line">    <span class="keyword">if</span>(!vis[G.to[i]])sum[G.to[i]]=sum[x]^G.dis[i],<span class="built_in">dfs</span>(G.to[i]);</span><br><span class="line">    <span class="keyword">else</span> cyc.<span class="built_in">insert</span>(sum[x]^sum[G.to[i]]^G.dis[i]);</span><br><span class="line">&#125;</span><br><span class="line">ll bas[<span class="number">64</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">63</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(bas[i])x^=bas[i];</span><br><span class="line">      <span class="keyword">else</span>&#123;bas[i]=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">63</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>((x^bas[i])&gt;x)x^=bas[i];</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="type">int</span> u,v;ll w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">    G.<span class="built_in">add</span>(u,v,w);G.<span class="built_in">add</span>(v,u,w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll x:cyc)<span class="built_in">insert</span>(x);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">qry</span>(sum[n]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="p3733-haoi2017-八纵八横"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM3MzM=">P3733 [HAOI2017] 八纵八横</span></h3>
<h4 id="题意-3">题意</h4>
<p>给出 <span class="math inline">\(n(1\le n\le 500)\)</span> 个点 <span class="math inline">\(m(1\le 500\le m)\)</span> 条边的无向图。</p>
<p>进行 <span class="math inline">\(Q(1\le Q\le 1000)\)</span> 次操作，操作分为三种：</p>
<ol type="1">
<li><code>Add x y z</code> 表示加入一条连接 <span class="math inline">\(x,y\)</span> 边权为 <span class="math inline">\(z\)</span> 的边。</li>
<li><code>Cancel k</code> 删除第 <span class="math inline">\(k\)</span> 次加入的边。</li>
<li><code>Change k z</code> 将第 <span class="math inline">\(k\)</span> 次加入的边的边权修改为 <span class="math inline">\(z\)</span>。</li>
</ol>
<p>其中所有边权 <span class="math inline">\(z\)</span> 均为非负整数，在二进制下长度不超过 <span class="math inline">\(1000\)</span> 位。</p>
<p>输入的 <span class="math inline">\(z\)</span> 和输出的答案均要在二进制下给出。</p>
<p>定义一条路径的权值为路径上的边的异或和。求经过1的环中的最大权值。</p>
<h3 id="做法-3">做法</h3>
<p>由于异或的性质，我们可以发现，任何环都是可以取到的。</p>
<p>如果一个环不包括1号点，那么我们可以从1号点出发，经过一些路径到这个环，遍历这个环后再原路返回。由于中间的路径被经过两次，贡献为0，只保留了环的共线。</p>
<p>所以我们现在只要维护环的最大答案即可，我们仍然考虑线性基来维护环的信息。</p>
<p>对于修改边的操作可以拆分成一次插入一次删除。</p>
<p>如果记 <span class="math inline">\(dis_{i}\)</span> 为从1到点 <span class="math inline">\(i\)</span> 的任意一条路径的长度，那么我们加入一条连接 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> ，权值为 <span class="math inline">\(z\)</span> 的边时，我们只需要加入 <span class="math inline">\(dis_{u}\oplus z\oplus dis_{v}\)</span> 的一个数字即可，相当于是经过了这条边的一个环。</p>
<p>那么如何处理删除操作呢？</p>
<h4 id="可删线性基做法">可删线性基做法</h4>
<p>按照上方可删线性基的离线/在线做法来做即可。</p>
<p>代码丑得要命，不忍直视。后面想方设法离线，搞得挺混乱，不要学我。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1005</span>,Q=<span class="number">2005</span>,LEN=<span class="number">2005</span>,M=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">using</span> bs=bitset&lt;LEN&gt;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(bs&amp; x)</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(c!=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;1&#x27;</span>)c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>;x.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="keyword">while</span>(c==<span class="string">&#x27;0&#x27;</span>||c==<span class="string">&#x27;1&#x27;</span>)x[cnt++]=c^<span class="number">48</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt/<span class="number">2</span>;++i)&#123;<span class="type">bool</span> tmp=x[i];x[i]=x[cnt-i<span class="number">-1</span>];x[cnt-i<span class="number">-1</span>]=tmp;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> bs&amp; x)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">while</span>(x[i]==<span class="number">0</span>&amp;&amp;i&gt;<span class="number">0</span>)--i;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(x[i]^<span class="number">48</span>);</span><br><span class="line">    --i;</span><br><span class="line">  &#125;<span class="keyword">while</span>(i&gt;=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">  <span class="type">int</span> head[N],nxt[M],to[M],tot;</span><br><span class="line">  bs dis[M];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,bs w)</span></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u];</span><br><span class="line">    to[tot]=v;</span><br><span class="line">    dis[tot]=w;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;G;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> dTime[N];</span><br><span class="line">bs bas[LEN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> tim,bs x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1000</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x[i])&#123;</span><br><span class="line">      <span class="keyword">if</span>(tim&gt;dTime[i])<span class="built_in">swap</span>(tim,dTime[i]),<span class="built_in">swap</span>(x,bas[i]);</span><br><span class="line">      <span class="keyword">if</span>(!tim)<span class="keyword">return</span>;</span><br><span class="line">      x^=bas[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bs <span class="title">qry</span><span class="params">(<span class="type">int</span> tim)</span></span>&#123;</span><br><span class="line">  bs res;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1000</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!res[i])</span><br><span class="line">      <span class="keyword">if</span>(dTime[i]&gt;tim)res^=bas[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bs dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  vis[x]=<span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=G.head[x];i;i=G.nxt[i])</span><br><span class="line">    <span class="keyword">if</span>(vis[G.to[i]])<span class="built_in">insert</span>(q+<span class="number">1</span>,dis[x]^dis[G.to[i]]^G.dis[i]);</span><br><span class="line">    <span class="keyword">else</span> dis[G.to[i]]=dis[x]^G.dis[i],<span class="built_in">dfs</span>(G.to[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">bs ins[Q],chgVal[Q];</span><br><span class="line"><span class="type">int</span> tp[Q],cur[Q],del[Q],num[Q],v1[Q],v2[Q];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; chg[Q];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter[Q];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">  <span class="type">int</span> u,v;bs w;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">    <span class="built_in">read</span>(w);</span><br><span class="line">    G.<span class="built_in">add</span>(u,v,w);G.<span class="built_in">add</span>(v,u,w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">qry</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)del[i]=q+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">      tp[i]=<span class="number">1</span>;++cnt;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v1[cnt],&amp;v2[cnt]);<span class="built_in">read</span>(ins[cnt]);ins[cnt]=ins[cnt]^dis[v1[cnt]]^dis[v2[cnt]];cur[cnt]=cnt;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">1</span>]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">      tp[i]=<span class="number">2</span>;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num[i]);del[num[i]]=i;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      tp[i]=<span class="number">3</span>;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num[i]);<span class="built_in">read</span>(chgVal[i]);chg[num[i]].<span class="built_in">push_back</span>(i);chgVal[i]^=dis[v1[num[i]]]^dis[v2[num[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)iter[i]=chg[i].<span class="built_in">begin</span>();</span><br><span class="line">  cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tp[i]==<span class="number">1</span>)&#123;</span><br><span class="line">      ++cnt;</span><br><span class="line">      <span class="built_in">insert</span>(iter[cnt]==chg[cnt].<span class="built_in">end</span>()?del[cnt]:*iter[cnt],ins[cnt]);</span><br><span class="line">      <span class="keyword">if</span>(iter[cnt]!=chg[cnt].<span class="built_in">end</span>())++iter[cnt];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tp[i]==<span class="number">3</span>)&#123;</span><br><span class="line">      <span class="type">int</span> k=num[i];</span><br><span class="line">      <span class="built_in">insert</span>(iter[k]==chg[k].<span class="built_in">end</span>()?del[k]:*iter[k],chgVal[i]);</span><br><span class="line">      <span class="keyword">if</span>(iter[k]!=chg[k].<span class="built_in">end</span>())++iter[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">qry</span>(i));</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线段树分治">线段树分治</h4>
<p>我们可以将信息离线下来之后线段树分治。</p>
<p>不是很会做。可以去洛谷看看题解。</p>
<h1 id="推广">推广</h1>
<p>其实我们在介绍部分提到的线性基是一种特殊的线性基：异或线性基，是 OI 中较为常用的线性基。</p>
<p>我们先定义线性无关：对于一个集合 <span class="math inline">\(A\)</span>（实际上是线性空间），包含 <span class="math inline">\(m\)</span> 维向量，如果这个集合中的任何元素都不能通过其他元素进行线性运算（例如：数乘，加法等）得到，我们称这个集合线性无关。否则称为线性有关。</p>
<p>在异或线性基中，集合 <span class="math inline">\(A\)</span> 中的元素不能通过其它元素异或得到，就叫做线性无关。</p>
<p>线性基实质上是一个极大的线性无关组。这个基，通过线性运算能够得到的向量称为其张成。我们发现线性基和线性空间的张成是相同的。</p>
<p>推广之后，我们就可以做实数线性基了：</p>
<h2 id="p3265-jloi2015-装备购买"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMyNjU=">P3265 [JLOI2015] 装备购买</span></h2>
<h3 id="题意-4">题意</h3>
<p>给定 <span class="math inline">\(n(1\le n\le 500)\)</span> 个装备，每个装备有 <span class="math inline">\(m(1\le m\le 500)\)</span> 个属性值 <span class="math inline">\(a_{i}(0\le a_{i}\le 1000)\)</span>，每一个装备有一个代价 <span class="math inline">\(c_{i}\)</span>。</p>
<p>每一个装备的属性值组成了一个 <span class="math inline">\(m\)</span> 维向量 <span class="math inline">\(\mathbf{z}_{i}=(a_{1},\cdots,a_{j},\cdots,a_{m})\)</span>​。现在要求找出这些向量的最小代价线性基。</p>
<h3 id="做法-4">做法</h3>
<p>版题，排序之后插入，跟异或线性基差不多。</p>
<p>只不过这里的插入不使用异或来操作，使用类似高斯消元的办法消去第 <span class="math inline">\(i\)</span> 位上的属性值。</p>
<p>注意高斯消元的精度一直很玄学，所以EPS不要开太小，否则会挂分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> EPS=<span class="number">1e-5</span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Abs</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x&lt;<span class="number">0</span>?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Abs</span>(x)&lt;=EPS)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> x&lt;<span class="number">0</span>?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N][N],val[N],id[N];</span><br><span class="line"><span class="type">double</span> bas[N][N],tmp[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)tmp[i]=a[x][i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(tmp[i]))&#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[i])&#123;vis[i]=<span class="literal">true</span>;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)bas[i][j]=tmp[j];ans+=val[x];++cnt;<span class="keyword">return</span>;&#125;</span><br><span class="line">      <span class="type">double</span> t=tmp[i]/bas[i][i];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)tmp[j]-=bas[i][j]*t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i]),id[i]=i;</span><br><span class="line">  <span class="built_in">sort</span>(id+<span class="number">1</span>,id+<span class="number">1</span>+n,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> val[x]&lt;val[y];&#125;);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">insert</span>(id[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %lld\n&quot;</span>,cnt,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://tangninghaha.netlify.app/posts/%E6%BB%A1%E5%88%86%EF%BC%81zs%E4%B8%80%E5%AD%A6%E7%94%9F%E8%8E%B7%E5%85%A8%E5%9B%BD%E7%AC%AC%E4%B8%80%EF%BC%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://cravatar.cn/avatar/d9eec067bd5d56059d20b709bd0ef72b?f=mp&s=256">
      <meta itemprop="name" content="Tangninghaha">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tangninghaha">
      <meta itemprop="description" content="三尺微命，一介书生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Tangninghaha">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/posts/%E6%BB%A1%E5%88%86%EF%BC%81zs%E4%B8%80%E5%AD%A6%E7%94%9F%E8%8E%B7%E5%85%A8%E5%9B%BD%E7%AC%AC%E4%B8%80%EF%BC%81/" class="post-title-link" itemprop="url">满分！ZS一学生获全国第一！</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-12-21 22:15:55" itemprop="dateCreated datePublished" datetime="2023-12-21T22:15:55+00:00">2023-12-21</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>899</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vQ0RPSS0yNDM3NC9wLzE3MDExMjUyLmh0bWw=">原文出处</span>：原文作者：<span class="exturl" data-url="aHR0cHM6Ly9ob21lLmNuYmxvZ3MuY29tL3UvQ0RPSS0yNDM3NC8=">Jijidawang</span>。</p>
<p>原文遵循「署名-非商业性使用-相同方式共享 4.0 国际」许可协议（CC BY-NC-SA 4.0）进行许可。本博客博文遵循此协议。</p>
<p>满分！中山一学生这项赛事获全国第一！班里有牛娃咋办？没事别跟牛娃比！</p>
<p>他，是中国计算机学会主办的CSP软件能力认证的全国第一。年仅初二的他，成为全场最夺目的选手之一。</p>
<p>虽然只是初二的选手，但他取得优异成绩后，不少网友并不感到奇异，纷纷留言：</p>
<blockquote>
<p>这不是洛谷上天天爆切神仙题的少先队员们吗？</p>
</blockquote>
<p>没错，虽然他年纪轻轻，但是已经年少有为。俗话说：“有志不在年高”，这句话在他身上得到了很好的体现。</p>
<p>他就是洛谷账号 Follow 数达到 1w 的 OI （信息学奥林匹克竞赛）选手，Daniel QF。这么高的数据放在微博也是妥妥的大 V 了。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8pqfxegp.png" alt="Daniel QF'S LuoGu" style="zoom: 67%;" /></p>
<p>他的首页里面都是他获得的荣誉奖项，因为他为人谦虚谨慎，心地善良，所以只展示了考得最差的几次的成绩。尽管如此，这些成绩还是很耀眼的，一般的高中选手都难以获得，更何况一个初二选手了。</p>
<p>2022国际初中生信息学竞赛（International School in Informatics “Junior”，简称 ISIJ） 一个月前，Daniel QF更是在个人的洛谷博客上发布一篇博客，是 ISIJ 集训队的作业，并且在博客的最后放下豪言“近几年的 IOI 题都是傻逼题”。</p>
<p>一位“不明真相”的网友还评价说，“ISIJ 第一只有 1% 的机会能获得，我愿意以 1:99 的赔率打赌”。</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/y7xe7evp.png" alt="不明真相的网友" /><figcaption aria-hidden="true">不明真相的网友</figcaption>
</figure>
<p>这位网友不知道的是，Daniel QF去年第一次参加 NOI 就获得了 705 分以上的好成绩，吊打了全国所有的选手。</p>
<p>现在该评论已经被Daniel QF删除，不知道这位网友作何感想。</p>
<p>另外，与国内诸多 NOI 金牌学霸一样的是，Daniel QF也收到了名校通知书。</p>
<p>国内有不少 NOI 金牌得主被清华姚班选择，同样Daniel QF也与清华大学成功签约。</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/mbp4tsyb.png" alt="THU录取通知书" /><figcaption aria-hidden="true">THU录取通知书</figcaption>
</figure>
<p>对于仅仅年满 4 岁的他来说，一切都才刚开始。</p>
<p>Daniel QF对编程产生的兴趣起源很早，53 年前就开始在国内顶尖学术网站 UOJ （Universal Online Judge） 注册了一个账号，通过的第一个题目是 <span class="exturl" data-url="aHR0cHM6Ly91b2ouYWMvcHJvYmxlbS82MDc=">UOJ #1024 蚱蜢电话</span>。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/2rcklc2k.png" /></p>
<p>而 UOJ 1024 这道题到现在的通过率都不到 <span class="math inline">\(1%\)</span> ，可见他的天赋是多么过人了。一位不愿透露姓名的集训队队员都直言：这道题，我想一年都未必想得明白。</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/l2xzidt7.png" alt="CF Rating" /><figcaption aria-hidden="true">CF Rating</figcaption>
</figure>
<p>上图是 Codeforces 的 rating 的榜，前几位的选手都是世界排名前几的知名选手，多来自世界顶级大学，例如 Benq 来自就来自美国的顶级学府 MIT。Tourist 更是从小便开始接触信息学，获得过<strong>6次</strong>IOI金牌，但是在面对 danielqf 时，他也直言：</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/5us6nto7.png" alt="T宝的留言" /><figcaption aria-hidden="true">T宝的留言</figcaption>
</figure>
<p><strong>从全国第一逆袭到全球第一</strong></p>
<p>当被问及怎么样才能才能成为一个好的程序员（computer programmer，CP）时，danielqf可能会给出一个建议：</p>
<blockquote>
<p>除非像我一样天赋异禀，否则不可能！</p>
</blockquote>
<p>因为，他本人就是这么天才。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-code"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Tangninghaha</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">34k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:02</span>
  </span>
</div>
  <div class="powered-by">由 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZy9waXNjZXMv">NexT.Pisces</span> 强力驱动
  </div><a href="https://icp.gov.moe/?keyword=20245550" target="_blank">萌ICP备20245550号</a>


    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://lib.baomitu.com/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://lib.baomitu.com/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://lib.baomitu.com/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"tangninghaha/Blog-Comment","repo_id":"R_kgDOK75Jug","category":"Announcements","category_id":"DIC_kwDOK75Jus4Cb4f_","mapping":"pathname","reactions_enabled":1,"emit_metadata":1,"theme":"light","lang":"en","crossorigin":"anonymous","input_position":"top","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

<!-- hexo injector body_end start -->
<script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>
<script>
if (window.netlifyIdentity) {
  window.netlifyIdentity.on("init", user => {
    if (!user) {
      window.netlifyIdentity.on("login", () => {
        document.location.href = "/admin/";
      });
    }
  });
}
</script>
<link rel="stylesheet" href="//lib.baomitu.com/highlight.js/9.6.0/styles/github.min.css"><script src="//lib.baomitu.com/highlight.js/9.6.0/highlight.min.js"></script><!-- hexo injector body_end end --></body>
</html>
