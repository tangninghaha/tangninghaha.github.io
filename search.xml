<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GDKOI2023游记</title>
    <url>/posts/GDKOI2023%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="day-0">Day 0</h2>
<p>去广州比赛，非常开心。看一看省行政中心是什么样子。</p>
<p>车上被 LYY 拍了一个照。快下高速的时候看到一个大铜钱样子的建筑，第一次见这么“钱”的建筑。</p>
<p>本来以为广州全都是高楼大厦，没想到很多地方其实看起来很旧，甚至看起来还比不上中山。</p>
<span id="more"></span>
<p>酒店居然叫 吉桔酒店 ，名字很独特啊。</p>
<p>到了酒店，开房的时候，同学们发现墙壁哪里有一个机器人，就都围着机器人转，让机器人送草稿纸，还给它拍照。</p>
<p>进了酒店，有电视，马上看电视，不知道看什么，本来想看人大的，但是太无聊了。</p>
<p>一个下午看电视过去了……</p>
<p>集合的时候见到了几位纪中的朋友， 冯D 刘瑾 都来了，他们打的是普及组，想到提高组是省选水平，就感觉似乎没有什么希望拿奖了。</p>
<p>到六中报道，发现这个学校似乎也不是很大的样子，似乎有点旧。</p>
<p>太开心了，居然送了我一个笔记本和一支笔，很有纪念意义，可以做笔记了。</p>
<p>六中的菜真的很好吃，比某学校强多了。</p>
<p>回酒店以后继续腐败，本来想刷回 B 站视频的，但是不好操作。</p>
<p>晚上 LYM 说请客，和 LYY 一起溜去喝奶茶，有点小激动，第一次和同学去逛街，想到班上的同学还在上自习。奶茶不太健康，就只点了个柠檬水。</p>
<p>回酒店后看 LYM 和 LYY 洗澡，去九楼的洗衣机把衣服洗了。</p>
<p>十点半睡觉了。</p>
<h2 id="day-1">Day 1</h2>
<p>比赛就要开始了，为什么提高组是省选的难度啊？这怎么打？</p>
<p>走进考场，决定怎么说打不出来就打暴力吧，心情躺平。开始之后，发现居然没有虚拟机（不是说要提供 NOI LINUX 吗？），又发现居然有 VIM （虽然版本只有 7.2 ）。聊胜于无，2 min 打完配置之后看题目。</p>
<h3 id="赛时">赛时</h3>
<h4 id="problem-1">Problem 1</h4>
<blockquote>
<h5 id="题目大意">题目大意：</h5>
<p>给出三个 <span class="math inline">\(n \times n\)</span> 的矩阵 <span class="math inline">\(A\)</span> 、 <span class="math inline">\(B\)</span> 、<span class="math inline">\(C\)</span> 。求 <span class="math inline">\(A \times B\)</span> 是否等于 <span class="math inline">\(C\)</span> 。有多组询问。</p>
<h5 id="数据范围">数据范围：</h5>
<p>对于 <span class="math inline">\(20\%\)</span> 的数据，<span class="math inline">\(\sum n \leq 300\)</span> 。</p>
<p>对于另外 <span class="math inline">\(20\%\)</span> 的数据， <span class="math inline">\(A_{i,j} \not= 0\)</span> 的不超过 <span class="math inline">\(n\)</span> 个。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，<span class="math inline">\(\sum n \leq 3000\)</span> 。</p>
</blockquote>
<p>T1 看起来很不错啊，题目通俗易懂，简单明了。暴力很好打，可惜只有 20 分。目光对准 20 分的性质，发现此时可以枚举有数值的 <span class="math inline">\(A_{i,j}\)</span> ，考虑它对答案的贡献。由矩阵乘法定义式：</p>
<p><span class="math display">\[
C_{i,j}=A_{i,k}\times B_{k,j}
\]</span></p>
<p>枚举 <span class="math inline">\(i, k\)</span> 。如果 <span class="math inline">\(A_{i,k}\)</span> 不为 0 ，就枚举 <span class="math inline">\(j\)</span> 来贡献，这样是 <span class="math inline">\(O(n^2)\)</span> 的。</p>
<p>最后我觉得差不多了，感觉有机会想出正解，但是感觉又不一定想出来。于是就快速把 40 分的部分分打出来了。</p>
<p>打完以后又打了一个对拍，拍了一下特殊性质和暴力，结果是对的，就决定从特殊性质出发，考虑能否想出正解。</p>
<p>考虑将 <span class="math inline">\(O(n^3)\)</span> 的算法优化一维，就考虑到题目只是问是否相同，并没有让我将结果矩阵求出来，考虑可不可以用奇妙的办法将 <span class="math inline">\(j\)</span> 优化掉。</p>
<p>于是想到似乎 <span class="math inline">\(A_{i,k}\)</span> 会乘上 <span class="math inline">\(B\)</span> 的某一行贡献到 <span class="math inline">\(C\)</span> 的某一行，一开始想的是：<span class="math inline">\(A_{i,k}\)</span> 是固定的，不如对 <span class="math inline">\(B\)</span> 整行求和，乘上 <span class="math inline">\(A_{i,k}\)</span> ，看是否等于 <span class="math inline">\(C\)</span> 的行。但是这样如果每一行和是相同的，但具体数字不一样就会出错。</p>
<p>考虑将 <span class="math inline">\(B\)</span> 不同的列乘上随机不同的数字，这样就可以将数字之间的差异放大化。打完对拍，似乎能过。</p>
<p>最后生成了大小为 3000 的一组数据，发现文件有一百多M，读入有点慢，跑了 5s 多才跑完，还开了O，有点怕 T 。</p>
<p>两个小时过去了。</p>
<h4 id="problem-2">Problem 2</h4>
<blockquote>
<h5 id="题目大意-1">题目大意</h5>
<p>求有多少个排列 <span class="math inline">\(p_i\)</span> 。对于所有 <span class="math inline">\(i \leq m\)</span> ，<span class="math inline">\(p_i &gt; m\)</span> 且 <span class="math inline">\(p_i \not= i\)</span> 。</p>
</blockquote>
<p>暴力很显然，可是只有 10 分。看到有 <span class="math inline">\(m \leq 0\)</span> 的 <span class="math inline">\(10 \%\)</span> 的数据，发现这不就是一个错排问题吗？但是式子是什么呢？</p>
<p>我记得好像当初 CSP 初赛的时候学过，但是是初一的时候学的，有点久远，记忆有点模糊。怎么办呢？我想推一下式子，奈何数学水平太差劲，没有推出来。（分数 -= 10）</p>
<h4 id="problem-3">Problem 3</h4>
<blockquote>
<h5 id="题目大意-2">题目大意</h5>
<p>给定一张 n 个点 m 条边的无向图和一个长度为 n 的数组 <span class="math inline">\(a_1,a_2,\cdots,a_n\)</span> 以及一个整数 <span class="math inline">\(C\)</span> ，你需要求出有多少个长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(b\)</span> 满足：</p>
<ol type="1">
<li><span class="math inline">\(0 \leq b_i \leq ai\)</span>， <span class="math inline">\(\forall 1 \leq i \leq n\)</span>。</li>
<li>对于每条边 <span class="math inline">\((u, v)\)</span>， <span class="math inline">\(b_u \not= bv\)</span> 。</li>
<li><span class="math inline">\(b_1 \oplus b_2 \oplus \cdots \oplus b_n\)</span> = C，其中 <span class="math inline">\(\oplus\)</span> 代表异或。</li>
</ol>
<p>答案对 998244353 取模。</p>
</blockquote>
<p>本来考虑异或的特殊性质，想到是否可以对于 <span class="math inline">\(b\)</span> 的每一位计算这一位为 C 的概率，推了一会，发现第二个限制有点难办。</p>
<p>打了暴力就算了。</p>
<p>打完三道题之后，还剩一个小时，没事干，就把 T1 的对拍运行了一下，又想了一会 T2 的式子，还是没有推出来。</p>
<p>比完赛之后听说 T1 是原题。</p>
<h3 id="讲题">讲题</h3>
<h4 id="problem-1-1">Problem 1</h4>
<p>正解很是奇怪，用一个长度为 n 的随机向量乘上矩阵 <span class="math inline">\(A\)</span> 再乘 <span class="math inline">\(B\)</span> ，判断是否跟 <span class="math inline">\(C\)</span> 相同。这样子本质上是和我的做法差不多的，只是这样讲比较高级。</p>
<h4 id="problem-2-1">Problem 2</h4>
<p>T2 没有认真听，感觉很难，好像是生成函数，很奇怪啊。</p>
<h4 id="problem-3-1">Problem 3</h4>
<p>T3 听了一会，没听懂，一脸懵逼。</p>
<h3 id="讲座">讲座</h3>
<h4 id="罗国杰教授的讲座">罗国杰教授的讲座</h4>
<p>教授太奇怪了，头像就是一个建模建歪了的卡通大叔。</p>
<p>一直在讲北大的计算机学科体系，感觉没有什么有意思的内容。</p>
<h4 id="小马智行">小马智行</h4>
<p>莫璐怡副总裁出场讲课， ACM 冠军，六中毕业生。</p>
<p>这个 pony.ai 似乎很高科技的样子，自动驾驶很有意思，感觉自动化识别汽车很厉害的样子。叫 拉D 扫码没扫到。</p>
<h4 id="皇帝的滚榜">皇帝的滚榜</h4>
<p>一个老师说要搞滚榜，看起来很高科技的样子哦。不知道是怎样子的。</p>
<p>又说要多测几次代码，取最高分当作分数，让我们休息一会儿。此言一出，很多打随机化算法的同学非常高兴啊。</p>
<p>结果 40 分钟还没有开始，我还以为马上开始了，就没有写作业。最后到五点半，老师说有几个同学每次分数都不一样，要人工核查一下。让我们先去吃饭，吃完再回来滚榜。</p>
<p>吃完饭回来只看到四个大字：“明天再见~”</p>
<h3 id="晚上">晚上</h3>
<p>晚上写了会作业，LYM D 了一篇作文，八点钟的时候离开酒店。 SQC 不去啊，似乎 LYM 又请客啊。去到麦当劳， LYM 和 LYY 点了 3 个套餐， 他们两人 AA 了，我白嫖，两位老板请客。</p>
<p>吃完之后，我提议去中大，看一下重点大学是什么样子的。我看公交站牌，辨认走哪一条路。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7uy46q5k.png" /></p>
<p>如图所示，我看公交站牌上有几条路线的下一站是“中大北门”，于是我就觉得站在这个方向，下一站肯定是向前走，忘记可以左/右转了，就继续向前走，走过十字路口。</p>
<p>走着走着，这里也不像是大学校园的样子啊，看到前面是一个很大的，好似花车一般的，还闪烁着霓虹灯的“车”缓缓开过。我疑心是有游行活动罢。</p>
<p>感觉这条路真的不是往中大的，想要走到下一个路口就掉头。</p>
<p>走到路口，震撼眼前的一幕，珠江映入眼帘，江对面的是繁华的高楼，一座雄伟的大桥跨江而过。广州塔在不远的前方。</p>
<p>和 LYY LYM 继续向前走，拍了几张照，八点四十分就返程了。</p>
<h2 id="day-2">Day 2</h2>
<h3 id="赛时-1">赛时</h3>
<h4 id="problem-1-2">Problem 1</h4>
<blockquote>
<h5 id="题目大意-3">题目大意</h5>
<p>给定一棵 <span class="math inline">\(n\)</span> 个结点的树，有 <span class="math inline">\(Q\)</span> 次询问，每次给定 <span class="math inline">\(x, y, z\)</span>，你要找到三个点 <span class="math inline">\((u, v, w)\)</span> 满足 <span class="math inline">\(dis(u, v) = x\,, dis(u, w) = y\,, dis(v, w) = z\)</span>。其中 <span class="math inline">\(dis(u, v)\)</span> 表示树上 u 和 v 两点唯一简单路径所包含的边数， <span class="math inline">\(dis(u, u) = 0\)</span>。 保证有解。</p>
</blockquote>
<p>我以为今天的 T1 还像昨天的那么水，想了一会，观察了一会样例，发现似乎给出的 <span class="math inline">\(x,y,z\)</span> 中最小的两个相加等于最大的两个，想到如果最小的两个数加起来为最大的，那么三个点必定在一条链上，那么只需要在最长的链（即直径）上找两个点就好了。打树上倍增，在 <span class="math inline">\(O(q \log n)\)</span> 的时间内解决问题。</p>
<p>打之前我还有点疑惑，真的有这么简单吗？最小的两个数加起来真的等于最大的数字吗？但是我又举不出任何反例，自信应该是这样的。大不了打完之后打对拍就好了。</p>
<p>此时我本来应该先打一个程序检验一下是否满足这个性质。但是我没有，继续打这个想法，但是没有想好怎么打，打了很久才打完。样例过了。两个小时过去了。</p>
<p>接着打对拍，第一组数据就挂了。生成的数据太大，没法手动检验。又搞了几个小数据，发现真的不一定满足那个性质。这该怎么办呢？</p>
<p>我没有什么办法，又打了一个暴力，结果暴力也过不了对拍，调了一会，发现只剩下 30 Min 了，赶紧去打后面两道题。</p>
<h4 id="problem-2-2">Problem 2</h4>
<blockquote>
<h5 id="题目大意-4">题目大意</h5>
<p>有一个数字，初始是 <span class="math inline">\(x_0\)</span> 。进行 <span class="math inline">\(K\)</span> 次操作，第 <span class="math inline">\(i\)</span> 次操作从 <span class="math inline">\([0, 2n)\)</span> 均匀随机一个数字 <span class="math inline">\(x\)</span> ， <span class="math inline">\(x_i\)</span> 有 <span class="math inline">\(p\)</span> 的概率是 <span class="math inline">\(x_{i-1} \ \text{or}\  x\)</span>，有 <span class="math inline">\(1 - p\)</span> 的概率是 <span class="math inline">\(x_i-1\ \text{and}\ x\)</span>。 一种方案的权值是 <span class="math inline">\(\sum_{i=1}^{K} c_{xi}\)</span>。对每个 <span class="math inline">\(i \in [0, 2n)\)</span>求出， <span class="math inline">\(x_K = i\)</span> 的所有方案中，权值乘概率之和，对998244353 取模。</p>
</blockquote>
<p>没有什么想法，只能打暴力。但是第一档分就是：对于 <span class="math inline">\(20\%\)</span> 的数据，满足 <span class="math inline">\(K \leq 20\)</span>。我怀疑过不了。</p>
<h4 id="problem-3-2">Problem 3</h4>
<blockquote>
<h5 id="题目大意-5">题目大意</h5>
<p>给定一棵 n 个结点的有根树 T，结点从 1 开始编号，根结点为 1 号结点，每个结点有一个正整数权值 <span class="math inline">\(vi\)</span>。有 <span class="math inline">\(Q\)</span> 次询问，对于一次询问，给定 <span class="math inline">\((x, k)\)</span>，设 <span class="math inline">\(x\)</span> 号结点的子树内（包含 <span class="math inline">\(x\)</span> 自身）的所有满足距离 <span class="math inline">\(x\)</span> 号结点不超过 <span class="math inline">\(k\)</span> 的结点编号为 <span class="math inline">\(c_1\,,c_2\,,\cdots ,c_k\)</span>，则这次询问的答案为： <span class="math inline">\((vc1 \oplus d(c1, x)) + (vc2 \oplus d(c2, x)) + \cdots + (vck \oplus d(ck, x))\)</span></p>
<p>其中 <span class="math inline">\(d(x, y)\)</span> 表示树上 <span class="math inline">\(x\)</span> 号结点与 <span class="math inline">\(y\)</span> 号结点间唯一简单路径所包含的边数， <span class="math inline">\(d(x, x) = 0\)</span>。 <span class="math inline">\(\oplus\)</span> 表示异或运算。</p>
</blockquote>
<p>也没有什么想法，只能打暴力。</p>
<h3 id="赛后">赛后</h3>
<p>比赛结束后发了成绩单，感觉有点不公平， T1 很多随机化过了，感觉对我这种打正解的选手有点亏。</p>
<p>T3 TLE 了，其实不应该枚举完再检验，应该一边枚举一边检验。可以减去很多情况。</p>
<p>中午 LYM 说他 T1 想到一种做法，如图：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xdz56k5m.png" /></p>
<p><del>（图片是跟 LYM D 的)</del></p>
<p>三条路径必定有一个交点 <span class="math inline">\(i\)</span> 。</p>
<p>对于 <span class="math inline">\(dis(u,v)\)</span> 可以如上表示成 <span class="math inline">\(A+B\)</span> ，同理可以表示 <span class="math inline">\(dis(u,w)\)</span> 和 <span class="math inline">\(dis(v,w)\)</span> 。</p>
<p>如此便可以解出 <span class="math inline">\(A,B,C\)</span> 的值。</p>
<p>只要找到满足这个条件的点就好了。但是 LYM 不知道怎么弄。</p>
<p>下午讲题的时候，出题人讲的做法居然和 LYM 想的一样。最后似乎是用线段树搞一下。</p>
<p>T2 T3 的讲题没有认真听，感觉很难，而且周记没有写完，写周记先。</p>
<p>讲完题之后就说要跑榜，但是要等一等，就放了一下 GDKOI 2023 纪录片， 拉D 独占 2 秒镜头。</p>
<p>等了好久终于开始跑榜了，我终于知道跑榜是怎么弄的了。看到后面的很多选手不停地向上，我很慌张，怕他们上去之后就超过我了。我和 LYM 大喊：“不要再飞了，不要再 D 了”。</p>
<p>好不容易背景颜色变成了铜色，还没有看到我和 LYM 的名字，我觉得有希望拿牌。终于到我了，Day 1 T1 AC 的颜色格外耀眼，我很开心，因为看了这么久就只有我一个人 A 了 <del>（其实是就只有我一个 A 了还这么低分的）</del> 。</p>
<p>过了一会又看到 LYM 的名字，但是后来都没有我们两个的名字了（其实是因为我们 Day 2 爆零了）。</p>
<p>颁奖的时候本来没有我们的名字，有点小失落，以为我们并非真的是铜牌。结果有好几页，很高兴拿了一个🥉。</p>
<p>麦秋秋 太强了，银牌🥈。</p>
<p>WTC 太强了，金牌🥇。</p>
<p>很多纪雅的初二同学也只有铜牌，但是分数比我高。</p>
<p>吃完饭之后返程，我不知道的是：一堆作业正等待着我的到来。</p>
<p>九点整，就在同学们下课之时，我们刚刚到达校门口，我和 LYY 一路狂奔回课室放东西。</p>
<h2 id="day-3">Day 3</h2>
<p>赛后第一天，我开始思考到底 Day 2 T1 怎么做。</p>
<p>音乐课上我想了一下，感觉似乎可以使用二分，但很快就被我否决了。</p>
<h2 id="day-4">Day 4</h2>
<p>早上想了一想，想出来了。</p>
<p>跟 LYM 讨论了一下，终于想出了正解。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xdz56k5m.png" /></p>
<p>还是这张图。如果知道点 <span class="math inline">\(i\)</span> 的儿孙中的最大深度 <span class="math inline">\(a_i\)</span> ，次大深度 <span class="math inline">\(b_i\)</span> ，第三大深度 <span class="math inline">\(c_i\)</span> 。 满足 <span class="math inline">\(a_i \geq A\)</span> 且 <span class="math inline">\(b_i \geq B\)</span> 且 <span class="math inline">\(c_i \geq C\)</span> ，那么可以用树上倍增就可以在 <span class="math inline">\(O(log n)\)</span> 的时间里解决一次询问。</p>
<p>考虑如何解决，用出题人的想法，用树状数组。将 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(A\)</span> 排序，倒序处理。对于每一次询问，很显然，对于所有 <span class="math inline">\(i\)</span> 满足 <span class="math inline">\(a_i \geq A\)</span> 的，以 <span class="math inline">\(b_i\)</span> 为下标，将 <span class="math inline">\(c_i\)</span> 加入树状数组，利用树状数组询问后缀最大值，就可以快速求出 <span class="math inline">\(i\)</span> 了。利用树上倍增就可以在 <span class="math inline">\(O(n \log n)\)</span> 的时间内解决问题了。</p>
<h2 id="day-5">Day 5</h2>
<p>老师给我们看了总的排名，发现其实很多普及组同学的分数并不是很高，有一些平时成绩跟我差不多甚至比我好的同学排名也不高，突然有点高兴来了提高组，不然可能什么牌子都没有。</p>
<h2 id="总结">总结</h2>
<ul>
<li>难的比赛一定要注意部分分，有时候 10 分就可以相差很多名次。不能抛弃任何可能的部分分。</li>
<li>打之前一定要考虑清楚，不能想个大概就打，很容易出问题。高难度的比赛题目往往结论并不那么简单，可能设计一些比较难的结论，一定要保证结论正确。</li>
<li>我和一些优秀的同学之间的差距还很大，要多花一点时间在学习信息学上面，多学多做题，争取赶上其他同学。</li>
<li>Day 1 T3 TLE 了，其实不应该枚举完再检验，应该一边枚举一边检验。可以减去很多情况。</li>
</ul>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>GDKOI Day2 T2 计算题解</title>
    <url>/posts/GDKOIDay2T2%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>看不清公式可以放大。</p>
<p>题意简单转化</p>
<p>首先有 <span class="math inline">\(\gcd(x^{a}-1,x^{b}-1)+1=x^{\gcd(a,b)}\)</span>。</p>
<span id="more"></span>
<blockquote>
<p>证明：</p>
<p>因为当 <span class="math inline">\(a\ge b\)</span> 时， <span class="math inline">\(\gcd(a,b)=\gcd(a-b,b)\)</span>。</p>
<p>让我们钦定 <span class="math inline">\(a\ge b\)</span>，那么</p>
<p>考虑 <span class="math inline">\(\gcd(x^{a}-1,x^{b}-1)=\gcd(x^{a}-x^{b},x^{b}-1)=\gcd(x^{b}(x^{a-b}-1),x^{b}-1)\)</span></p>
<p>由于 <span class="math inline">\(\gcd(x^{b},x^{b}-1)=1\)</span>，所以</p>
<p><span class="math inline">\(\gcd(x^{b}(x^{a-b}-1),x^{b}-1)=\gcd(x^{a-b}-1,x^{b}-1)\)</span></p>
<p>我们发现指数在更相减损！</p>
<p>直到更相减损结束的时候，即 <span class="math inline">\(\gcd(x^{\gcd(a,b)}-1,x^{0}-1)\)</span> 时，我们得到原式为 <span class="math inline">\(x^{\gcd(a,b)}-1\)</span>。</p>
</blockquote>
<hr />
<p>发现 <span class="math inline">\(m\vert L-1\)</span> 且 <span class="math inline">\(m\vert R\)</span>，将 <span class="math inline">\(L,R\)</span> 都减去 <span class="math inline">\(L\)</span>，原问题相当于 <span class="math inline">\([1,N]\)</span> 的问题。</p>
<p>这题中有多项式 <span class="math inline">\(f(x)=(1+x)(1+x^{2})(1+x^{3})\cdots (1+x^{k})=c_{0}+c_{1}x+c_{2}x^{2}+\cdots+c_{t}x^{t}\)</span>。</p>
<p>我们知道展开这个多项式，就相当于在每一个括号内选取一项相乘。</p>
<p><span class="math inline">\((1+x^{i})\)</span>，如果选择1，乘积的指数不变，表示子集中没有 <span class="math inline">\(i\)</span>。如果选择 <span class="math inline">\(x^{i}\)</span>，乘积的指数增加了 <span class="math inline">\(i\)</span>，表示子集中有 <span class="math inline">\(i\)</span>。那么如果展开后有一项 <span class="math inline">\(c_{i}x^{i}\)</span>，其中 <span class="math inline">\(c_{i}\)</span> 是系数，那么 <span class="math inline">\(c_{i}\)</span> 就表示子集和为 <span class="math inline">\(i\)</span> 的方案数。</p>
<p>因为 <span class="math inline">\(x\)</span> 是任意代入的，所以我们希望代入一些具有优秀性质的 <span class="math inline">\(x\)</span> 来简化我们的运算。</p>
<hr />
<p>引理 <span class="math display">\[
[m\vert i]=\frac{1}{m}\sum_{k=0}^{m-1}\omega_{m}^{ik}
\]</span> 证明：</p>
<p>考虑等比数列求和：<span class="math inline">\(S=\frac{\omega_{m}^{im}-1}{\omega_{m}^{i}-1}\)</span>，分类讨论：</p>
<ul>
<li>当 <span class="math inline">\(\omega_{m}^{i}\not=1\)</span> 时，可以知道 <span class="math inline">\(i\)</span> 不是 <span class="math inline">\(m\)</span> 的倍数，并且 <span class="math inline">\(\omega_{m}^{im}-1\)</span> 为0。</li>
<li>当 <span class="math inline">\(\omega_{m}^{i}=1\)</span> 时，可以知道 <span class="math inline">\(i\)</span> 是 <span class="math inline">\(m\)</span> 的倍数，并且由于分母为0，此时不能使用等比数列求和公式，所以特判。此时 <span class="math inline">\(\omega_{m}^{ik}=1\)</span>，因为 <span class="math inline">\(i\)</span> 是 <span class="math inline">\(m\)</span> 的倍数。得到 <span class="math inline">\(\sum_{k=0}^{m-1}\omega_{m}^{ik}=m\)</span>，所以除以 <span class="math inline">\(m\)</span> 得到 1。</li>
</ul>
<hr />
<p>将 <span class="math inline">\(m\)</span> 次单位根代入得到 <span class="math inline">\(\sum f(\omega_{m}^{i})\)</span>，展开，由引理得到只有 <span class="math inline">\(m\vert i\)</span> 时，系数为 <span class="math inline">\(c_{i}\)</span> 的项的和不为0。而下标为 <span class="math inline">\(m\)</span> 的倍数的数相加得到 <span class="math inline">\(m\times c_{k}\)</span>。故答案为 <span class="math display">\[
\frac{1}{m}\sum f(\omega_{m}^{i})
\]</span> 问题转化为快速计算该式子。</p>
<hr />
<p>当 <span class="math inline">\(m\)</span> 为奇素数的时候：</p>
<p>考虑：根据单位根的定义，我们可以对 <span class="math inline">\(z^{m}-1\)</span> 在复数域内进行因式分解。得到 <span class="math inline">\(z^{m}-1=(z-\omega_{m}^{0})(z-\omega_{m}^{1})\cdots(z-\omega_{m}^{m-1})\)</span>，代入 <span class="math inline">\(z=-1\)</span>，进一步得到 <span class="math inline">\(2=(1+\omega_{m}^{1})(1+\omega_{m}^{2})\cdots(1+\omega_{m}^{m})\)</span>。又因为 <span class="math inline">\(m\)</span> 是素数，所以 <span class="math inline">\((1+\omega_{m}^{i})(1+\omega_{m}^{2i})\cdots(1+\omega_{m}^{mi})\)</span> 的指数模 <span class="math inline">\(m\)</span> 组成了一个完全剩余系，其值仍然等于2。</p>
<blockquote>
<p>当然，如果 <span class="math inline">\(m\)</span> 为偶数的时候，可以得到 <span class="math inline">\(z^{m}=(-1)^{m}=1\)</span>，所以该式子等于0。</p>
</blockquote>
<p>进一步对其拓展，我们知道 <span class="math inline">\(n\)</span> 是 <span class="math inline">\(m\)</span> 的倍数，那么当 <span class="math inline">\(i&gt;0\)</span> 时， <span class="math inline">\(f(\omega_{m}^{i})=(1+\omega_{m}^{i})(1+\omega_{m}^{2i})\cdots(1+\omega_{m}^{ni})=2^{\frac{n}{m}}\)</span>。当 <span class="math inline">\(i=0\)</span> 时，该式等于 <span class="math inline">\(2^{n}\)</span>。</p>
<p>所以答案等于 <span class="math inline">\(\frac{1}{m}(2^{n}+(m-1)2^{\frac{n}{m}})\)</span>。</p>
<hr />
<p>拓展到 <span class="math inline">\(m\)</span> 一般的情况，考虑假设<span class="math inline">\((i,m)=p\)</span>，1~m分别乘 i 模 m 得到的剩余系，包含 <span class="math inline">\(\frac{m}{p}\)</span> 个数，是由 <span class="math inline">\(p\)</span> 个 模 <span class="math inline">\(\frac{m}{p}\)</span> 的完全剩余系中的数字乘 <span class="math inline">\(p\)</span> 得到的。</p>
<p>那么可以将 <span class="math inline">\((1+\omega_{m}^{i})(1+\omega_{m}^{2i})\cdots(1+\omega_{m}^{mi})\)</span> 按照模 <span class="math inline">\(m\)</span> 得到的值可以表示为 <span class="math inline">\([(1+\omega_{m}^{p})(1+\omega_{m}^{2p})\cdots(1+\omega_{m}^{m})]^{p}\)</span>。</p>
<p>所以 <span class="math inline">\(f(\omega_{m}^{i})=[(1+\omega_{m}^{p})(1+\omega_{m}^{2p})\cdots(1+\omega_{m}^{m})]^{p\times \frac{n}{m}}\)</span>。</p>
<p>注意到单位根的性质 <span class="math inline">\(\omega_{m}^{p}=\omega_{\frac{m}{p}}^{1}\)</span>，所以其实上式中括号内的部分就是 <span class="math inline">\((1+\omega_{\frac{m}{p}}^{1})(1+\omega_{\frac{m}{p}}^{2})\cdots(1+\omega_{\frac{m}{p}}^{\frac{m}{p}})\)</span>。</p>
<p>当 <span class="math inline">\(\frac{m}{p}\)</span> 为偶数的时候，上面的式子为0。当 <span class="math inline">\(\frac{m}{p}\)</span> 为奇数的时候，上面的式子为2。所以 <span class="math inline">\(f(\omega_{m}^{i})=2^{p\times\frac{n}{m}}[2\nmid \frac{m}{p}]\)</span>。</p>
<p>所以答案等于 <span class="math inline">\(\frac{1}{m}(2^{n}+\sum_{i=1}^{m-1}2^{\frac{n}{m}\times p}[2\nmid \frac{m}{p}])\)</span>。</p>
<p>我们之前特判了 <span class="math inline">\(i=0\)</span> 的情况，其实 <span class="math inline">\(i=0\)</span> 和 <span class="math inline">\(i=m\)</span> 是一样的，当 <span class="math inline">\(i=m\)</span> 时，<span class="math inline">\(p=m\)</span>，<span class="math inline">\(2^{\frac{n}{m}\times p}[2\nmid \frac{m}{p}])=2^{n}\)</span>，所以式子可以简化为： <span class="math display">\[
\frac{1}{m}(\sum_{i=0}^{m-1}2^{\frac{n}{m}\times p}[2\nmid \frac{m}{p}])
\]</span> 直接计算可以获得 85 分。</p>
<hr />
<p>进一步优化，观察到如果 <span class="math inline">\(2\vert \frac{m}{(i,m)}\)</span> 时，<span class="math inline">\(i\)</span> 对答案没有贡献。所以假设 <span class="math inline">\(m=2^{k}\times u\)</span>，其中 <span class="math inline">\(u\)</span> 是一个奇数，那么 <span class="math inline">\(i\)</span> 要求满足 <span class="math inline">\(i=2^{k}\times x\)</span>。</p>
<p>所以有： <span class="math display">\[
\begin{aligned}
\frac{1}{m}(\sum_{i=0}^{m-1}2^{\frac{n}{m}\times p}[2\nmid \frac{m}{p}])&amp;=\frac{1}{m}(\sum_{i=1}^{u}2^{\frac{n}{2^{k}\times u}\times \gcd(2^{k}\times u,2^{k}\times i)})\\
&amp;=\frac{1}{m}(\sum_{i=1}^{u}2^{\frac{n}{u}\times \gcd(u,i)})
\end{aligned}
\]</span> 考虑到 <span class="math inline">\(\gcd(u,i)\)</span> 为 <span class="math inline">\(u\)</span> 的约数，我们直接枚举 <span class="math inline">\(\gcd(u,i)\)</span>，也就是： <span class="math display">\[
\frac{1}{m}(\sum_{d\vert u}2^{\frac{n}{u}\times d}\times \varphi(\frac{u}{d}))
\]</span> 因为 <span class="math inline">\(\gcd(u,i)=d\)</span> 要求 <span class="math inline">\(\gcd(\frac{u}{d},\frac{i}{d})=1\)</span>，所以有多少个 <span class="math inline">\(\frac{i}{d}\)</span> 满足 <span class="math inline">\(\gcd(\frac{u}{d},\frac{i}{d})=1\)</span> 就是与 <span class="math inline">\(\frac{u}{d}\)</span> 互质的数字的个数。（此处题解写错了）</p>
<p>由于 <span class="math inline">\(u\)</span> 的特殊性（没有质因子2），所以其约数个数不会太多，1e7 之内大约只有 200 个（题解提供的数据），可以通过本题。</p>
]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Multiplicative Functions</title>
    <url>/posts/Multiplicative_Functions/</url>
    <content><![CDATA[<p>Introduction about multiplicative functions.</p>
<span id="more"></span>
<h1 id="multiplicative-functions">Multiplicative Functions</h1>
<p>Function <span class="math inline">\(f(x)\)</span> satisfied <span class="math inline">\(f(xy)=f(x)\cdot f(y), \gcd(x,y)=1\)</span> , then we call <span class="math inline">\(f(x)\)</span> a multiplicative function.</p>
<ol type="1">
<li><p><span class="math display">\[
d(n)=\sum_{y|n}y,\forall n\in \mathbb{N}
\]</span></p>
<p><span class="math inline">\(d(n)\)</span> is a multiplicative function.</p>
<p>Proof</p>
<p>Constant function <span class="math inline">\(f(x)=x\)</span> is clearly a multiplicative function.</p>
<p>Consider n,m satisfied <span class="math inline">\(\gcd(n,m)=1\)</span> , then we have:</p>
<p><span class="math display">\[
\begin{aligned}
d(nm)&amp;=\sum_{x|nm}f(x)\\
&amp;=\sum_{x|n}f(x)\sum_{x|m}f(x)\\
&amp;=d(n)\cdot d(m)
\end{aligned}
\]</span></p>
<p>But <span class="math inline">\(f(x)\)</span> is not a complete multiplicative function, since <span class="math inline">\(f(2)=3\)</span>, <span class="math inline">\(f(4)=7\)</span>, but <span class="math inline">\(f(8)\not =21\)</span> .</p></li>
<li><p>Euler function <span class="math display">\[
\varphi(n)=\sum_{\gcd(d,n)=1,1\le d\le n} 1,\forall n\in \mathbb{Z}
\]</span> is a multiplicative function.</p>
<p>Proof</p>
<p>We know if <span class="math inline">\(\gcd(t,nm)=1\)</span>, then <span class="math inline">\(\gcd(t,n)=1,\gcd(t,m)=1\)</span>.</p>
<p>And if <span class="math inline">\(\gcd(t,n)=1,\gcd(t,m)=1\)</span>, then <span class="math inline">\(\gcd(t,nm)=1\)</span>.</p>
<p>So let us construct a matrix with n lines m rows, like this <span class="math display">\[
\begin{matrix}
1&amp;2&amp;3&amp;\cdots&amp;r&amp;\cdots&amp;m\\
m+1&amp;m+1&amp;m+3&amp;\cdots&amp;m+r&amp;\cdots&amp;2m\\
2m+1&amp;2m+2&amp;2m+3&amp;\cdots&amp;2m+r&amp;\cdots&amp;3m\\
\vdots&amp;\vdots&amp;\vdots&amp;&amp;\vdots&amp;&amp;\vdots\\
(n-1)m+1&amp;(n-1)m+2&amp;(n-1)m+3&amp;\cdots&amp;(n-1)m+r&amp;\cdots&amp;nm\\
\end{matrix}
\]</span> In line 1, we can find exactly <span class="math inline">\(\varphi(m)\)</span> numbers r satisfied <span class="math inline">\(\gcd(r,m)=1\)</span> .</p>
<p>In row r, we have <span class="math inline">\(r,m+r,2m+r,\cdots,(n-1)m+r\)</span> , they constitute a complete system of residues. So there are exactly <span class="math inline">\(\varphi(n)\)</span> numbers satisfied <span class="math inline">\(gcd(r,n)=1\)</span>.</p>
<p>So there are <span class="math inline">\(nm\)</span> numbers satisfied <span class="math inline">\(\gcd(r,nm)=1\)</span>.</p>
<p>And this is the meaning of <span class="math inline">\(\varphi(n)\)</span>.</p></li>
<li><p>Legendre symbol, define as <span class="math display">\[
\left(\frac{a}{p}\right)=\begin{cases}
    0,  &amp; p\mid a,\\
    1,  &amp; \text{a is a quadratic residuce modulo p} \\
    -1, &amp; \text{a is a quadratic nonresiduce modulo p}.\\
\end{cases}
\]</span> p is an odd prime.</p></li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2016 天天爱跑步 题解</title>
    <url>/posts/NOIP2016-%E5%A4%A9%E5%A4%A9%E7%88%B1%E8%B7%91%E6%AD%A5%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="题目大意">题目大意</h2>
<p>给定一棵 <span class="math inline">\(n(991\le n\le 299998)\)</span> 个点的树，每个节点上有一个观察者，观察者在时刻 <span class="math inline">\(w_{i}\)</span> 进行观察。</p>
<p>现在有 <span class="math inline">\(m(991\le m\le 299998)\)</span> 条路径 <span class="math inline">\(s \rightarrow t\)</span>，每个路径上会有一个人，时刻0时从 <span class="math inline">\(s\)</span> 出发，沿着树上路径，向 <span class="math inline">\(t\)</span> 行走，每一个时刻走一条边，走到 <span class="math inline">\(t\)</span> 之后一个时刻消失。</p>
<p>问每一个观察者能够看到多少个人？</p>
<span id="more"></span>
<h2 id="转化">转化</h2>
<p>我们记 <span class="math inline">\(dep_{i}\)</span> 表示点 <span class="math inline">\(i\)</span> 的深度。</p>
<p>我们将一条路径 <span class="math inline">\(s\rightarrow t\)</span> 按照其 LCA 拆分为 <span class="math inline">\(s\rightarrow \text{LCA}\)</span> 和 <span class="math inline">\(\text{LCA}\rightarrow t\)</span> 两部分。</p>
<p>下面分别考虑这两部分：</p>
<ol type="1">
<li><p><span class="math inline">\(s\rightarrow \text{LCA}\)</span></p>
<p>那么，如果跑步者在经过 <span class="math inline">\(s\rightarrow \text{LCA}\)</span> 能够被节点 <span class="math inline">\(i\)</span> 上的观察者观察到，要满足：</p>
<p><span class="math display">\[
dep_{s}-dep_{i}=w_{i}
\]</span></p>
<p>也就是： <span class="math display">\[
dep_{s}=dep_{i}+w_{i}
\]</span></p>
<p>并且这条路径会经过 <span class="math inline">\(i\)</span> 这个点（因为有可能存在 <span class="math inline">\(i\)</span> 满足上面的式子，但是不经过点 <span class="math inline">\(i\)</span> ）。</p></li>
<li><p><span class="math inline">\(\text{LCA}\rightarrow t\)</span></p>
<p>如果跑步者在经过 <span class="math inline">\(\text{LCA}\rightarrow t\)</span> 能够被节点 <span class="math inline">\(i\)</span> 上的观察者观察到，要满足： <span class="math display">\[
(dep_{s}-dep_{lca})+(dep_{i}-dep_{lca})=w_{i}
\]</span> 也就是： <span class="math display">\[
dep_{s}-2\times dep_{lca}=w_{i}-dep_{i}
\]</span> 同样地，还要满足这条路径经过了 <span class="math inline">\(i\)</span> 这个点。</p></li>
</ol>
<h2 id="进一步转化">进一步转化</h2>
<p>进一步转化第二个条件，一条路径（指拆分成两段后的其中一段）经过了 <span class="math inline">\(i\)</span> 这个点，相当于 <span class="math inline">\(i\)</span> 的子树中包含恰好一个路径的端点。</p>
<p>具体地：</p>
<ul>
<li><p>如果 <span class="math inline">\(i\)</span> 的子树中包含 <span class="math inline">\(s\)</span> 但是不包含 <span class="math inline">\(\text{LCA}\)</span>，那么路径 <span class="math inline">\(s\rightarrow \text{LCA}\)</span> 一定 <strong>经过</strong> <span class="math inline">\(i\)</span>（可以画一下图感受一下）</p></li>
<li><p>如果 <span class="math inline">\(i\)</span> 的子树中包含了 <span class="math inline">\(s\)</span> 也包含了 <span class="math inline">\(\text{LCA}\)</span>，那么路径 <span class="math inline">\(s\rightarrow \text{LCA}\)</span> 一定 <strong>不经过</strong> <span class="math inline">\(i\)</span> 。</p></li>
<li><p>如果 <span class="math inline">\(i\)</span> 的子树中两者都不包含，那么路径 <span class="math inline">\(s\rightarrow \text{LCA}\)</span> 一定 <strong>不经过</strong> <span class="math inline">\(i\)</span> 。</p></li>
</ul>
<h2 id="解决">解决</h2>
<p>下面我们遍历树上的每一个节点，假设现在遍历到了点 <span class="math inline">\(i\)</span>，<span class="math inline">\(i\)</span> 上的观察者能够观察到几个人。</p>
<p>我将以 <span class="math inline">\(s\rightarrow \text{LCA}\)</span> 的这部分解决方法作为示例</p>
<p>我们使用一个桶 <span class="math inline">\(t_{d}\)</span> 来记录子树中深度为 <span class="math inline">\(d\)</span> 的有多少，那么观察者 <span class="math inline">\(i\)</span> 就会有 <span class="math inline">\(t[dep_{i}+w_{i}]\)</span> 的贡献。</p>
<p>关键在于如何维护桶。</p>
<h2 id="维护-t">维护 <span class="math inline">\(t\)</span></h2>
<p>先递归解决 <span class="math inline">\(i\)</span> 的儿子的问题，解决完毕，回溯到 <span class="math inline">\(i\)</span>。</p>
<p>有一些路径的一个端点在 <span class="math inline">\(i\)</span>，如果是 <span class="math inline">\(s\)</span>，我们就在桶里面加入，即 <code>++t[dep[s]]</code>，因为从此，这条路径开始产生贡献。</p>
<p>接下来统计答案，<code>ans[i]+=t[w[i]+dep[i]]</code> 。</p>
<p>接下来准备回溯到 <span class="math inline">\(i\)</span> 的父亲了，如果有一些路径的 LCA 在 <span class="math inline">\(i\)</span> 的话，我们就要将这条路径的贡献删去，即 <code>--t[dep[x]]</code>。</p>
<p>然后回溯即可！</p>
<h2 id="小问题">小问题</h2>
<p>按照我们的定义，<span class="math inline">\(t_{d}\)</span> 是以 <span class="math inline">\(i\)</span> 为根的子树中，<span class="math inline">\(dep[s]=d\)</span> 的路径数。</p>
<p>假设 <span class="math inline">\(i\)</span> 有两个儿子 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>，我们先递归解决了 <span class="math inline">\(x\)</span>，返回之后桶里面存储的是 <strong>以 <span class="math inline">\(x\)</span> 为根的子树，<span class="math inline">\(dep[s]=d\)</span> 的路径数</strong>。</p>
<p>接下来我们要递归解决 <span class="math inline">\(y\)</span>，但是桶里面有 <strong>以 <span class="math inline">\(x\)</span> 为根的子树</strong>，<span class="math inline">\(dep[s]=d\)</span> 的路径数，但是我们想知道 <strong>以 <span class="math inline">\(y\)</span> 为根的子树</strong>，<span class="math inline">\(dep[s]=d\)</span> 的路径数。</p>
<p>我们要设法消除解决 <span class="math inline">\(x\)</span> 时对 <span class="math inline">\(y\)</span> 产生的影响。</p>
<h3 id="法1">法1</h3>
<p>我们发现，我们只需要知道 <code>t[w[y]+dep[y]]</code> 的值。</p>
<p>那么我们在进入 <span class="math inline">\(y\)</span> 的时候，记录 <code>num1=t[w[y]+dep[y]]</code>，这其中只有以 <span class="math inline">\(x\)</span> 为根的子树的路径数。</p>
<p>当我们遍历完成 <span class="math inline">\(y\)</span> 的子树，记录 <code>num2=t[w[y]+dep[y]]</code>，这其中就有以 <span class="math inline">\(x\)</span> 为根和以 <span class="math inline">\(y\)</span> 为根的子树的路径数。</p>
<p>用 <code>num2-num1</code> 就可以求得以 <span class="math inline">\(y\)</span> 为根的子树的路径数。</p>
<h3 id="法2">法2</h3>
<p>不推荐使用，麻烦，复杂度多一个 <span class="math inline">\(\log\)</span>。</p>
<p>我们定义重儿子为子树大小最大的儿子（若有多个，任选一个），其它均称为轻儿子。</p>
<p>我们用树上启发式合并，先遍历所有轻儿子。每一次在遍历完轻儿子之后就立刻遍历其子树，反向操作（即原本加，现在减），达到删除的目的。</p>
<p>接着遍历重儿子，遍历完成之后不用清空桶（因为此时其它儿子都已经遍历完成了，不会再影响其它儿子）</p>
<p>再将所有轻儿子的子树遍历，将它们加进桶里。</p>
<h2 id="细节">细节</h2>
<p>注意到如果 LCA 能被观察到，那么被拆分出的两条路径都会统计到 LCA 的贡献。我们要减去其中一个。</p>
<p>如果有 <span class="math inline">\(dep_{s}=dep_{lca}+w_{lca}\)</span> 的路径，我们就将 <code>ans[lca]--</code> 。</p>
<h2 id="后记">后记</h2>
<p>注意到这篇题解并没有讨论如何计算转化部分第二条路径的答案，其实是一样的，大家推一推就可以知道了。</p>
]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2020 移球游戏题解</title>
    <url>/posts/NOIP2020-%E7%A7%BB%E7%90%83%E6%B8%B8%E6%88%8F%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>题目链接：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDcxMTU=">Luogu</span> or <span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8zMzg4">LOJ</span></p>
<p>这是一道巧妙的构造题，其中蕴含了将规模较大的问题划归到规模小的问题的思想。</p>
<p>如果想要在比赛的时候做出这道题，那么观察样例绝对是不二法门，因为样例提供了丰富的信息。<del>虽然说笔者做题的时候没有观察过。</del></p>
<span id="more"></span>
<h2 id="从简单的问题出发">从简单的问题出发</h2>
<p>让我们试着解决 <span class="math inline">\(n=2\)</span> 的特殊部分，尽管这只有 10 分的部分分，但是对简单的情形分析，能为拓展到复杂情况提供好的引导。</p>
<p>现在我们有 <span class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>，<span class="math inline">\(z\)</span>，三根柱子，<span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 上有两种颜色的球，让我们称其中一种颜色的球为 <strong>关键球</strong>。</p>
<p>我们希望将所有关键球移动到同一根柱子上。我们先考虑位于 <span class="math inline">\(x\)</span> 柱上的关键球，假设 <span class="math inline">\(x\)</span> 柱上有 <span class="math inline">\(c\)</span> 个关键球。</p>
<ol type="1">
<li>将 <span class="math inline">\(y\)</span> 柱上的前 <span class="math inline">\(c\)</span> 个球移动到 <span class="math inline">\(z\)</span> 柱上。</li>
<li>逐个考虑 <span class="math inline">\(x\)</span> 柱上的球：</li>
</ol>
<ul>
<li>如果这个球是关键球，那么移动其到 <span class="math inline">\(y\)</span> 柱上。</li>
<li>否则，移动其到 <span class="math inline">\(z\)</span> 柱上。</li>
</ul>
<p>注意到第一步，我们实际上是创造了两个空间，一个能容纳 <span class="math inline">\(c\)</span> 个球，另一个能容纳 <span class="math inline">\(m-c\)</span> 个球。</p>
<p>我们将 <span class="math inline">\(x\)</span> 柱上的球，按照其是否为关键球，分别放入这两个空间中，就能够分离 <span class="math inline">\(x\)</span> 上的关键球与非关键球了。</p>
<p>下面我们需要考虑原来 <span class="math inline">\(y\)</span> 柱上的关键球，我们仍然需要为关键球的放置创造空间。</p>
<ol start="3" type="1">
<li>将 <span class="math inline">\(z\)</span> 柱上的前 <span class="math inline">\(m-c\)</span> 个球移回 <span class="math inline">\(x\)</span> 柱。</li>
<li>将 <span class="math inline">\(y\)</span> 柱上的前 <span class="math inline">\(c\)</span> 个球移回 <span class="math inline">\(x\)</span> 柱。</li>
<li>将 <span class="math inline">\(z\)</span> 柱上剩余的 <span class="math inline">\(c\)</span> 个球移回 <span class="math inline">\(y\)</span> 柱。（这些球事实上来源于第一步中，从 <span class="math inline">\(y\)</span> 柱移来）</li>
<li>将 <span class="math inline">\(x\)</span> 柱上前 <span class="math inline">\(c\)</span> 个球移动到 <span class="math inline">\(z\)</span> 柱。</li>
</ol>
<p>我们发现，此时 <span class="math inline">\(x\)</span> 柱上剩下的是非关键球，<span class="math inline">\(z\)</span> 柱上都是关键球，而 <span class="math inline">\(y\)</span> 柱上的球正是它原来的那些球。</p>
<p>下面我们将 <span class="math inline">\(y\)</span> 柱上的球移动：</p>
<p>逐个考虑 <span class="math inline">\(y\)</span> 柱上的球：</p>
<ol start="7" type="1">
<li>如果这个球是关键球，那么移动其到 <span class="math inline">\(z\)</span> 柱上。</li>
<li>否则，移动其到 <span class="math inline">\(x\)</span> 柱上。</li>
</ol>
<p>这样我们就移动完成了，此时 <span class="math inline">\(x\)</span> 柱上都是非关键球，<span class="math inline">\(z\)</span> 柱上都是关键球。</p>
<p>这样子只需要操作 <span class="math inline">\(O(m)\)</span> 步，更具体地，考虑每一步的步数，可以得到： <span class="math display">\[
c+m+(m-c)+c+c+c+m=3m+3c
\]</span></p>
<h2 id="拓展到原问题">拓展到原问题</h2>
<p>如果有 <span class="math inline">\(n\)</span> 个柱子该怎么办呢？一个好的想法是分治。</p>
<p>具体地，我们用 <code>solve(l,r)</code> 解决所有球的颜色都在 <span class="math inline">\([l,r]\)</span> 之间的问题。</p>
<p>我们试图让每一个柱子上都只有 <span class="math inline">\(\le mid\)</span> 的，或是只有 <span class="math inline">\(&gt;mid\)</span> 的颜色。</p>
<p>这样我们就可以在解决完成当前问题后递归解决啦！</p>
<p>我们设 <span class="math inline">\(mid=\lfloor\frac{l+r}{2}\rfloor\)</span>，我们枚举其中的两个柱子 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>，那么：</p>
<ul>
<li>如果 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(y\)</span> 中 <span class="math inline">\(\le mid\)</span> 的个数超过了 <span class="math inline">\(m\)</span> 个，那么我们钦定颜色 <span class="math inline">\(\le mid\)</span> 的为关键球，按照规模为 2 的算法计算即可。</li>
<li>否则，我们钦定颜色 <span class="math inline">\(&gt;mid\)</span> 的为关键球，仍然按照规模为 <span class="math inline">\(2\)</span> 的算法计算。</li>
</ul>
<p>接下来 <code>solve(l,mid)</code> 和 <code>solve(mid+1,r)</code> 即可。</p>
<p>注意到每一次都会让其中一个柱子中的球都为关键球，也就是说，我们最多进行 <span class="math inline">\(O(r-l+1)\)</span> 次这样的操作。</p>
<p>每次操作进行 <span class="math inline">\(O(m)\)</span> 次移动，会递归 <span class="math inline">\(\log n\)</span> 层，也就是 <span class="math inline">\(O(nm\log n)\)</span>，是能够通过的。</p>
]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>GDKOI 2024 游记</title>
    <url>/posts/gdkoi-2024-%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p>一转眼间 KOI2024 已经开始了，但是 KOI2023 仍然历历在目。</p>
<h2 id="省流">省流</h2>
<p>这次比赛发挥比较稳健，没有挂分。</p>
<span id="more"></span>
<h2 id="逆天-textday-x">逆天 / <span class="math inline">\(\text{Day}^{-x}\)</span></h2>
<p>比赛前这几天都在 <del>复习WHK</del> 腐败。</p>
<h2 id="第零天-textday-o">第零天 / <span class="math inline">\(\text{Day o}\)</span></h2>
<p>没有设备该怎么腐败呢？</p>
<p>车上看 LYX 写 NTT，真是太 curly 了。</p>
<p>本来想推一推 FFT 的（虽然说没有用），但是 ky_star 带了笔记本，我们便一起观看我 U 盘里的神秘视频（#include<WC2022 宣传片>，#include<ZSSSX学校宣传片>），真是太好看了，可惜没有声音。本校学长 LZC 友情出镜，但是在镜头下写了一堆 for 套 for，估计是被迫营业。</p>
<p>好容易等到酒店，这酒店可真高级，看起来就是比麦克阿瑟还要多几颗星。</p>
<p>小度：本酒店已安装全屋监控系统。</p>
<p>我：？？？</p>
<p>晚上 【数据删除】 说我们是带着任务来的，不是来享受的。深以为然。</p>
<p>结束之后去逛街，但是我不喜欢逛街，刚跑出去就后悔了，转了半个小时回房间腐败。</p>
<h2 id="第一天-textday-1">第一天 / <span class="math inline">\(\text{Day 1}\)</span></h2>
<h3 id="赛前">赛前</h3>
<p>本着这次比赛是省选组的难度，估计做不出来，决定把部分分尽可能多拿。</p>
<h3 id="赛时">赛时</h3>
<p>第一题的前两档很显然是状压DP，40分很容易可以拿到。当机立断决定把这40分先拿下，实在想不到正解的时候有保底的分数，想到正解可以用来对拍。</p>
<p>第二题题意不是很复杂，感觉是比较可做的题目。分析了一下部分分，第一档是暴力，第二档是输出0，第三档是前缀和优化，都比较简单，总共有60分的部分分。所以直接开始写，写完之后对拍，没有问题。想冲一冲正解（毕竟看起来是最简单的一题），试了几种做法，都不是很可行。就直接做下一题。</p>
<p>第三题的题目看起来就比较复杂，想了一会，想不出什么很好的做法， 就决定先把10分的暴力分给拿到。</p>
<p>最后没有什么进展，就只是把大众分给拿到了。</p>
<h3 id="赛后">赛后</h3>
<p>很多同学都也只是写了这几档分，但是很多同学都写挂了，大众分都没有拿到，所以比较稳健地拿到了110分。</p>
<h3 id="晚上">晚上</h3>
<p>腐败腐了一个晚上。</p>
<p>巴托夫：叭叭叭！叭叭叭叭叭叭叭叭叭↓，叭叭叭叭叭叭叭叭叭叭叭叭↓，叭叭叭叭叭叭叭叭叭叭叭叭↑，叭叭↓</p>
<p>秋秋教我如何使用小度打开浏览器，强强强！</p>
<p>然后使用小度打了 At，切了AB就不想打了。</p>
<p>接着打Gen，比卡扎菲还要卡，Gen不动。</p>
<p>然后和秋秋一起看小约翰，看了一集整活大王，然后又给秋秋看了衣戈，挺有趣的，看完就睡觉了。</p>
<h2 id="第二天-textday-2">第二天 / <span class="math inline">\(\text{Day 2}\)</span></h2>
<h3 id="赛前-1">赛前</h3>
<p>居然忘记拿身份证了，早上行李放在签到处，顺便把身份证也放那了🤣。关键是我还不想提前入场，直到17分才入场，才发现身份证没带。赶紧跑去拿，还好在开考前拿到了。</p>
<h3 id="赛中">赛中</h3>
<p>可能是刚刚运动完的缘故，思维比较迅速，杂念也比较少。在读完T1之后推出了三条性质，依据此快速写了20分的部分分。还担心性质推错了，写了一个非常朴素的暴力，进行对拍，没有出现什么问题。</p>
<p>写完之后一时间没有什么进展，就顺便写了一下第二档的特殊性质，有10分。</p>
<p>写完之后突然发现，这些性质具有单调性，可以进行二分。又把二分给写了，但是性质三不具有单调性，一时间没有想出来该怎么处理。后来发现可以直接主席树维护，就上了主席树。</p>
<p>比较顺利地通过了对拍数据，但是突然发现空间爆了。还好当时怕爆空间，写了一个输出程序静态空间的东西，对拍的时候恍然发现560MIB了（空间限制512）。还好主席树可以开小一点（大约三个数组，每个可以少开1e7的数组），不然就要挂0了。</p>
<p>写完第一题已经十一点了。第二题题目看起来有点复杂，但是实际上也不是很复杂。仔细看了看就看明白了。依据题意模拟写出暴力，发现可以DP将其优化成多项式级别的。顺利写完了30分的档。</p>
<p>本来考虑DP是否可以使用矩阵乘法转移，但是一来比较复杂，二来这样只有10分，我还不如打第三题的20分暴力呢。</p>
<p>然后把第三题20分暴力写完了。还加了一点剪枝，试图通过更多的数据（事实证明不行）。</p>
<p>写完之后，又考虑了一下第二题的矩阵乘法，发现仍然不是很可做，所以就没有写。</p>
<h3 id="赛后-1">赛后</h3>
<p>比赛结束之后听同学说第三题可以高斯消元，确实是！我怎么没有想到呢？</p>
<p>今天仍然没有挂分，稳健地拿到了第一、二、三题的大众分。</p>
<p>凭借两天的稳定发挥，没有挂1分，260分踩线Au。</p>
<h2 id="总结">总结</h2>
<p>其实部分分拿完，至少不会太差。写部分分要快而准，不能犹豫。平时模拟赛总是不想写部分分，总想着多想一会儿正解，最后一无所获。</p>
<p>快速地写完部分分，才能为冲正解留下充足的时间。</p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Kinetic Tournament Tree</title>
    <url>/posts/kinetic-tournament-tree/</url>
    <content><![CDATA[<p>Kinetic Tournament Tree，简称 KTT，是一种动态维护函数最值的线段树。</p>
<span id="more"></span>
<h1 id="p5693-ei-的第六分块"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU2OTM=">P5693 EI 的第六分块</span></h1>
<p>模板题。</p>
<h2 id="题意">题意</h2>
<p>区间加正数，询问区间最大子段和。</p>
<p><span class="math inline">\(1\le n,q\le 10^{5}\)</span></p>
<h2 id="做法">做法</h2>
<p>由一种简单的求区间最值的方法拓展而来。</p>
<p>考虑维护区间的信息：从最左边开始连续一段的最大值 <span class="math inline">\(lmax\)</span>，从最右边连续一段的最大值 <span class="math inline">\(rmax\)</span>，区间的和 <span class="math inline">\(sum\)</span>，区间的答案 <span class="math inline">\(max\)</span>。</p>
<p>那么合并比较容易（假设要合并的两个区间为 <span class="math inline">\(a,b\)</span>）： <span class="math display">\[
\begin{aligned}
lmax&amp;=\max(a.lmax,a.sum+b.lmax)\\
rmax&amp;=\max(b.rmax,a.rmax+b.sum)\\
max&amp;=\max(a.max,b.max,a.rmax+b.lmax)
\end{aligned}
\]</span> 接下来考虑如何动态修改。</p>
<p>我们发现，每一个值的变化是一个一次函数的形式。具体地，当前的某一个值，例如 lmax，我们可以用这样一个函数来刻画它未来的值。 <span class="math inline">\(lmax=kx+b\)</span>，其中 <span class="math inline">\(k\)</span>是区间长度，<span class="math inline">\(b\)</span> 是当前的值，<span class="math inline">\(x\)</span> 是加的值。通过这个式子可以求出 <span class="math inline">\(lmax\)</span> 变化后的值。其它几个值是同理的。</p>
<p>但是，我们注意到 <span class="math inline">\(lmax\)</span> 可能原本取了 <span class="math inline">\(a.lmax\)</span>，但是随着区间加法的进行，<span class="math inline">\(a.sum+b.lmax&gt;a.lmax\)</span>，那么这时它的取值就变成了 <span class="math inline">\(a.sum+b.lmax\)</span>。这时候用上面的式子求出的就是错误的。</p>
<p>这该怎么办呢？我们维护一个 <span class="math inline">\(x\)</span>，表示这种变化是，这个区间的值再加 <span class="math inline">\(x\)</span> 次后，取值会发生上述变化。</p>
<p>那么我们如果发现当前区间加的数超过了 <span class="math inline">\(x\)</span>，我们就暴力重构这个区间，即将满足这个条件的全部重新计算。</p>
<p>这样做的复杂度是正确的，具体证明我也不会，可以参考 <span class="exturl" data-url="aHR0cHM6Ly9lbnRyb3B5aW5jcmVhc2VyLmJsb2cudW9qLmFjL2Jsb2cvNTIxNw==">EI的论文</span> 。</p>
<p>计算 <span class="math inline">\(x\)</span> 只需要将两个子区间的 <span class="math inline">\(x\)</span> 取 min，再看 <span class="math inline">\(lmax\)</span>，<span class="math inline">\(rmax\)</span>，<span class="math inline">\(max\)</span> 的值何时会修改，这个只要求一求一次函数的交点即可。</p>
<details class="note info"><summary><p>代码</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e18</span>,N=<span class="number">4e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span>&#123;</span><br><span class="line">  ll k,b;</span><br><span class="line">  <span class="built_in">Line</span>(ll x,ll y)&#123;k=x;b=y;&#125;</span><br><span class="line">  <span class="built_in">Line</span>(<span class="type">int</span> x)&#123;k=<span class="number">1</span>;b=x;&#125;</span><br><span class="line">  <span class="built_in">Line</span>()&#123;k=<span class="number">0</span>;b=<span class="number">0</span>;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(ll val)</span></span>&#123;</span><br><span class="line">    b+=k*val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Line <span class="keyword">operator</span>+(<span class="type">const</span> Line&amp; a,<span class="type">const</span> Line&amp; b)&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;a.k+b.k,a.b+b.b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  Line l,r,mx,sum;</span><br><span class="line">  ll to;</span><br><span class="line">&#125;tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">ll tag[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">inter</span><span class="params">(<span class="type">const</span> Line&amp; x,<span class="type">const</span> Line&amp; y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x.k==y.k)<span class="keyword">return</span> INF;</span><br><span class="line">  <span class="keyword">if</span>(y.b==x.b)<span class="keyword">return</span> INF;</span><br><span class="line">  ll tmp=(y.b-x.b)/(x.k-y.k);</span><br><span class="line">  <span class="keyword">return</span> tmp&lt;<span class="number">0</span>?INF:tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Line&amp; a,<span class="type">const</span> Line&amp; b)&#123;</span><br><span class="line">  <span class="keyword">return</span> a.b==b.b?a.k&lt;b.k:a.b&lt;b.b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Line <span class="title">max</span><span class="params">(<span class="type">const</span> Line&amp; a,<span class="type">const</span> Line&amp; b,ll&amp; v)</span></span>&#123;</span><br><span class="line">  v=<span class="built_in">min</span>(v,<span class="built_in">inter</span>(a,b));</span><br><span class="line">  <span class="keyword">return</span> a.b==b.b?(a.k&gt;b.k?a:b):(a.b&gt;b.b?a:b);</span><br><span class="line">&#125;</span><br><span class="line">node <span class="keyword">operator</span>+(<span class="type">const</span> node&amp; a,<span class="type">const</span> node&amp; b)&#123;</span><br><span class="line">  node res;</span><br><span class="line">  res.sum=a.sum+b.sum;</span><br><span class="line">  res.to=<span class="built_in">min</span>(a.to,b.to);</span><br><span class="line">  res.l=<span class="built_in">max</span>(a.l,a.sum+b.l,res.to);</span><br><span class="line">  res.r=<span class="built_in">max</span>(b.r,a.r+b.sum,res.to);</span><br><span class="line">  res.mx=<span class="built_in">max</span>(a.r+b.l,<span class="built_in">max</span>(a.mx,b.mx,res.to),res.to);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushUp</span><span class="params">(<span class="type">int</span> x,ll val)</span></span>&#123;</span><br><span class="line">  node&amp; cur=tr[x];</span><br><span class="line">  tag[x]+=val;cur.to-=val;</span><br><span class="line">  cur.l.<span class="built_in">upd</span>(val);cur.r.<span class="built_in">upd</span>(val);cur.mx.<span class="built_in">upd</span>(val);cur.sum.<span class="built_in">upd</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,ll val)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(val&gt;tr[k].to)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> v=val+tag[k];</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">rebuild</span>(l,mid,k&lt;&lt;<span class="number">1</span>,v);<span class="built_in">rebuild</span>(mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,v);</span><br><span class="line">    tr[k]=tr[k&lt;&lt;<span class="number">1</span>]+tr[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];tag[k]=<span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">pushUp</span>(k,val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">downLazy</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="built_in">pushUp</span>(k&lt;&lt;<span class="number">1</span>,tag[k]);</span><br><span class="line">  <span class="built_in">pushUp</span>(k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,tag[k]);</span><br><span class="line">  tag[k]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">    tr[k]=&#123;a[l],a[l],a[l],a[l],INF&#125;;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(l,mid,k&lt;&lt;<span class="number">1</span>);<span class="built_in">build</span>(mid+<span class="number">1</span>,r,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">  tr[k]=tr[k&lt;&lt;<span class="number">1</span>]+tr[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> val,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s&lt;=l&amp;&amp;r&lt;=t)&#123;</span><br><span class="line">    <span class="built_in">rebuild</span>(l,r,k,val);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(tag[k])<span class="built_in">downLazy</span>(k);</span><br><span class="line">  <span class="keyword">if</span>(s&lt;=mid)<span class="built_in">upd</span>(l,mid,s,t,val,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(t&gt;mid)<span class="built_in">upd</span>(mid+<span class="number">1</span>,r,s,t,val,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">  tr[k]=tr[k&lt;&lt;<span class="number">1</span>]+tr[k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">qry</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> s,<span class="type">int</span> t,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(s&lt;=l&amp;&amp;r&lt;=t)&#123;</span><br><span class="line">    <span class="keyword">return</span> tr[k];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(tag[k])<span class="built_in">downLazy</span>(k);</span><br><span class="line">  <span class="keyword">if</span>(t&lt;=mid)<span class="keyword">return</span> <span class="built_in">qry</span>(l,mid,s,t,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(s&gt;mid)<span class="keyword">return</span> <span class="built_in">qry</span>(mid+<span class="number">1</span>,r,s,t,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">qry</span>(l,mid,s,t,k&lt;&lt;<span class="number">1</span>)+<span class="built_in">qry</span>(mid+<span class="number">1</span>,r,s,t,k&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="type">int</span> r=<span class="number">0</span>,neg=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>((c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&amp;&amp;(c!=<span class="string">&#x27;-&#x27;</span>))c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)neg*=<span class="number">-1</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(c&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>)r=(r&lt;&lt;<span class="number">1</span>)+(r&lt;&lt;<span class="number">3</span>)+(c^<span class="number">48</span>),c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">return</span> r*neg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,q;</span><br><span class="line">  n=<span class="built_in">read</span>();q=<span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)a[i]=<span class="built_in">read</span>();</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">    <span class="type">int</span> tp,l,r,x;</span><br><span class="line">    tp=<span class="built_in">read</span>();l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(tp==<span class="number">1</span>)x=<span class="built_in">read</span>(),<span class="built_in">upd</span>(<span class="number">1</span>,n,l,r,x,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(tp==<span class="number">2</span>)&#123;</span><br><span class="line">      node res=<span class="built_in">qry</span>(<span class="number">1</span>,n,l,r,<span class="number">1</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">max</span>(<span class="number">0ll</span>,res.mx.b));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>P定理</title>
    <url>/posts/p%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvU291bGlzdC9zb2x1dGlvbi1wNDk4MA==">主要参考</span></p>
<h1 id="群">群</h1>
<h2 id="定义">定义</h2>
<p>定义集合 <span class="math inline">\(G\)</span> 及一个二元运算 <span class="math inline">\(\cdot\)</span>，如果满足 4 个性质就是一个群，记作 <span class="math inline">\((G,\cdot)\)</span>。</p>
<ol type="1">
<li>封闭性。就是集合中两个元素进行 <span class="math inline">\(\cdot\)</span> 运算之后的结果仍然是在集合中。</li>
<li>结合律。这个小学数学讲过。</li>
<li>单位元 <span class="math inline">\(e\)</span>。单位元只有一个（这我乱证一下，假如有 <span class="math inline">\(e_{1}\)</span> 和 <span class="math inline">\(e_{2}\)</span> 都是单位元，那么 <span class="math inline">\(e_{1}\cdot e_{2}\)</span> 该等于什么呢？）</li>
<li>逆元。也就是对于所有 <span class="math inline">\(a\in G\)</span>，都有 <span class="math inline">\(a&#39;\in G\)</span> 满足 <span class="math inline">\(a\cdot a&#39;=a&#39;\cdot a=e\)</span>。据说逆元是唯一的，但是我太菜，不会证。</li>
</ol>
<p>可以感受一下这些性质。<del>反正我不学数学，不证明</del>。</p>
<h2 id="子群">子群</h2>
<p>可以类比子集理解，群有一个集合 <span class="math inline">\(G\)</span>，子群有集合 <span class="math inline">\(H\)</span>，若 <span class="math inline">\(H\)</span> 是 <span class="math inline">\(G\)</span> 的一个子集，且群 <span class="math inline">\((H,\cdot)\)</span> 也是群，那么 <span class="math inline">\((H,\cdot)\)</span> 是群 <span class="math inline">\((G,\cdot)\)</span> 的一个子群。</p>
<h2 id="陪集">陪集</h2>
<p>对于某一个元素 <span class="math inline">\(g\in G\)</span>，如果有</p>
<ul>
<li><span class="math inline">\(gH=\{g\cdot h\vert h\in H\}\)</span>，那么称 <span class="math inline">\(gH\)</span> 为 <span class="math inline">\(H\)</span> 包含 <span class="math inline">\(g\)</span> 的左陪集。</li>
<li><span class="math inline">\(Hg=\{h\cdot g\vert h\in H\}\)</span>，那么称 <span class="math inline">\(Hg\)</span> 为 <span class="math inline">\(H\)</span> 包含 <span class="math inline">\(g\)</span> 的右陪集。</li>
</ul>
<p>陪集具有若干性质。</p>
<blockquote>
<p>注意，举反例要考虑群的封闭性。</p>
<p>曾经我发现性质是“错误”的，我举出了整数集合的一个子集和整数加法运算构成的“群”，发现其子群的陪集不满足下述性质。我感到很疑惑。最后当我将这个“反例”列出的时候，才发现，这个所谓的“群”不满足封闭性。</p>
</blockquote>
<h3 id="阶">阶</h3>
<p>群 <span class="math inline">\(G\)</span>的阶等于其元素个数，记作 <span class="math inline">\(\vert G\vert\)</span>。</p>
<h3 id="陪集的性质">陪集的性质</h3>
<p>分析时采用右陪集，证明均为非严格证明，因为 <del>反正我不学数学</del> 不是很会证明，如果谁会可以分享一下。</p>
<ol type="1">
<li><p>某一子群的阶等于陪集的阶。</p>
<p>符号表达就是 <span class="math inline">\(\forall g\in G,\vert Hg\vert=\vert H\vert\)</span>。</p>
<p>证明：由定义得到，如果右陪集是一个可重集，那么这个可重集中元素个数恰好为 <span class="math inline">\(\vert H\vert\)</span> 个。只需要证明这个可重集中的元素互不相同。如果有 <span class="math inline">\(h_1,h_2\in H,h_1\not=h_2\)</span>，且 <span class="math inline">\(h_1\cdot g=h_2\cdot g\)</span>，由于 <span class="math inline">\(g\)</span> 的逆元唯一，所以 <span class="math inline">\(h_1\cdot g\cdot g^{-1}=h_2\cdot g\cdot g^{-1}\)</span>，推出 <span class="math inline">\(h_1=h_2\)</span>，导出矛盾。</p></li>
<li><p><span class="math inline">\(\forall g\in G,g\in Hg\)</span>。</p>
<p>注意到 <span class="math inline">\(H\)</span> 是一个群，所以 <span class="math inline">\(H\)</span> 一定具有单位元。</p></li>
<li><p><span class="math inline">\(Hg=H\Longleftrightarrow g\in H\)</span>。</p>
<p>从右向左是简单的，因为群具有封闭性。从左往右我不会证 QAQ。</p></li>
<li><p><span class="math inline">\(Ha=Hb\Longleftrightarrow a\cdot b^{-1}\in H\)</span>。</p>
<p>从左向右：对于 <span class="math inline">\(h_1,h_2\in H\)</span>，有 <span class="math inline">\(h_1\cdot a=h_2\cdot b\)</span>，那么 <span class="math inline">\(h_{2}=h_{1}\cdot a\cdot b^{-1}\)</span>，所以 <span class="math inline">\(H=H(a\cdot b^{-1})\)</span>，根据性质 3，可以得到 <span class="math inline">\(a\cdot b^{-1}\in H\)</span>。</p>
<p>从右向左：我们类似上面的过程，反过来。如果 <span class="math inline">\(a\cdot b^{-1}\in H\)</span>，根据群的封闭性，若 <span class="math inline">\(h_{1}\in H\)</span>，有 $h_2=h_1ab^{-1}$，其中 <span class="math inline">\(h_{2}\in H\)</span>，所以可以得到 <span class="math inline">\(h_{2}\cdot b=h_{1}\cdot a\)</span>，也就是两者的陪集相同。</p></li>
<li><p>如果两个陪集交集非空，那么这两个陪集相等。</p>
<p><span class="math inline">\(Ha\cap Hb\not=\varnothing\Longleftrightarrow Ha=Hb\)</span>。</p>
<p>假如 <span class="math inline">\(c\in Ha \and c\in Hb\)</span>，那么 <span class="math inline">\(c=h_1\cdot a,h_1\in H\)</span> 并且 <span class="math inline">\(c=h_2\cdot a,h_2\in H\)</span>，也就是说 <span class="math inline">\(h_1\cdot a=h_2\cdot b\)</span>，所以 <span class="math inline">\(h_{2}=h_{1}\cdot a\cdot b^{-1}\)</span>。根据性质 4，可以得到 <span class="math inline">\(Ha=Hb\)</span>。</p></li>
<li><p><span class="math inline">\(H\)</span> 的全体右陪集的并为 <span class="math inline">\(G\)</span>。</p>
<p>因为 <span class="math inline">\(H\)</span> 中存在单位元，右陪集中能够取便所有元素。</p></li>
</ol>
<p>其实这些证明大多都是不严谨或者有问题的，大家看一乐呵就好。</p>
<h3 id="符号规定">符号规定</h3>
<p><span class="math inline">\([G:H]\)</span> 表示 <span class="math inline">\(G\)</span> 中 <span class="math inline">\(H\)</span> 的不同的左或右陪集的数量。</p>
<h2 id="拉格朗日定理">拉格朗日定理</h2>
<p><span class="math inline">\(\vert H\vert \times [G:H]=\vert G\vert\)</span>。</p>
<p>也就是说 <span class="math inline">\(H\)</span> 的阶乘上 <span class="math inline">\(G\)</span> 中 <span class="math inline">\(H\)</span> 的左陪集数量等于 <span class="math inline">\(G\)</span> 的阶。</p>
<p>考虑到 <span class="math inline">\(H\)</span> 的所有不同陪集的交为空集，并且每一个陪集的大小都为 <span class="math inline">\(\vert H\vert\)</span>（性质 1）。由性质 6 得到全体陪集的并为 <span class="math inline">\(G\)</span>，得证。</p>
<h1 id="置换">置换</h1>
<p>群的介绍告一段落，下面来说说置换。</p>
<p>参考：</p>
<ol type="1">
<li><span class="exturl" data-url="aHR0cHM6Ly9vaS13aWtpLm9yZy9tYXRoL3Blcm11dGF0aW9uLw==">OI-Wiki - 置换和排列</span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvU291bGlzdC9zb2x1dGlvbi1wNDk4MA==">主要参考</span></li>
</ol>
<h2 id="定义-1">定义</h2>
<p>置换定义为有限集合 <span class="math inline">\(S\)</span> 到自身的一个双射。</p>
<p>集合 <span class="math inline">\(S={a_1,a_2,\cdots,a_n}\)</span> 的一个置换可以表示为： <span class="math display">\[
f=\begin{pmatrix}a_1,a_2,\dots,a_n\\
a_{p_1},a_{p_2},\dots,a_{p_n}
\end{pmatrix}
\]</span> 其中 <span class="math inline">\(p\)</span> 是一个 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的一个排列。我们可以认为置换就是将一个序列按照某一个排列的顺序重新排序。</p>
<h2 id="运算">运算</h2>
<p>置换的运算用符号 <span class="math inline">\(\sigma\)</span> 表示，<span class="math inline">\(\sigma(a)=({a_{\sigma_{1}},a_{\sigma_{2}},\cdots,a_{\sigma_{n}}})\)</span>。</p>
<p>这个运算通过接受一个序列，返回这个序列置换后的结果。</p>
<p>我们称其为置换的“合成”（这里引用的是 <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvU291bGlzdC9zb2x1dGlvbi1wNDk4MA==">参考资料</span> 中的说法，严格的叫法我也不知道）。</p>
<h2 id="置换群">置换群</h2>
<p>如果一个元素为若干个排列，运算是置换的“合成”的“二元组”满足群的定义，我们称其为一个置换群。</p>
<p>容易发现如果元素为 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的全排列，那么这个“二元组”满足群的定义，下面简单验证一下：</p>
<ol type="1">
<li>封闭性，显然，因为“合成”之后仍然是 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 的一个排列。</li>
<li>单位元 <span class="math inline">\(e=(1,2,\cdots,n)\)</span>。</li>
<li>结合律 / 逆元：容易验证存在。</li>
</ol>
<h1 id="轨道-稳定子定理">轨道-稳定子定理</h1>
<h2 id="群作用">群作用</h2>
<p>对于一个群 <span class="math inline">\(G\)</span> 和集合 <span class="math inline">\(M\)</span>，若有一个二元函数 <span class="math inline">\(\varphi(g,m),g\in G,m\in M\)</span> 满足下列要求，则称群 <span class="math inline">\(G\)</span> 作用于集合 <span class="math inline">\(M\)</span>。 <span class="math display">\[
\varphi(e,m)=m
\]</span></p>
<p><span class="math display">\[
\varphi(g_1\cdot g_2,m)=\varphi(g1,\varphi(g_2,m))
\]</span></p>
<h2 id="轨道">轨道</h2>
<p>假如群 <span class="math inline">\(G\)</span> 作用与集合 <span class="math inline">\(X\)</span>，那么称元素 <span class="math inline">\(x\in X\)</span> 通过 <span class="math inline">\(G\)</span> 中的元素能够转移到的元素集合为 <span class="math inline">\(x\)</span> 的轨道，记作 <span class="math inline">\(G(x)\)</span>。很形象吧。</p>
<h2 id="稳定子">稳定子</h2>
<p>使得 <span class="math inline">\(\varphi(g,x)=x\)</span> 的 <span class="math inline">\(g\)</span> 的集合称为 <span class="math inline">\(x\)</span> 的稳定子，记作 <span class="math inline">\(G^{x}\)</span>。</p>
<h2 id="举个离子">举个离子</h2>
<p>想必上述内容过于抽象了，那就举一个 <del>离子</del> 例子来说明一下吧。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/r3qchaw6.png" /></p>
<p>来源：<span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvU291bGlzdC9zb2x1dGlvbi1wNDk4MA==">参考资料</span>，侵权删除。</p>
<h2 id="定理内容">定理内容</h2>
<p>铺垫了这么多，就是想说：</p>
<p>轨道大小和稳定子的大小的乘积恰好为的群 <span class="math inline">\(G\)</span> 的大小。</p>
<p>用符号表示就是 <span class="math inline">\(\vert G(x)\vert\times \vert G^x\vert=\vert G\vert\)</span>。</p>
<h2 id="证明">证明</h2>
<p>首先可以发现 <span class="math inline">\(G^x\)</span> 是 <span class="math inline">\(G\)</span> 的一个子群。</p>
<p>接着发现 <span class="math inline">\([G:G^x]=\vert G(x)\vert\)</span>。</p>
<p>由拉格朗日定理得证！</p>
<p>首先证明 <span class="math inline">\(G^x\)</span> 是 <span class="math inline">\(G\)</span> 的一个子群。</p>
<ol type="1">
<li>由稳定子的定义可以得到 <span class="math inline">\(G^x\)</span> 的元素组成的集合是 <span class="math inline">\(G\)</span> 中元素集合的子集。</li>
<li><span class="math inline">\(G^x\)</span> 满足封闭性，如果有 <span class="math inline">\(f\in G^x,g\in G^x\)</span>，那么 <span class="math inline">\(\varphi(f\cdot g)=\varphi(f,\varphi(g,x))=x\)</span>。</li>
<li><span class="math inline">\(G^x\)</span> 满足结合律，这由 <span class="math inline">\(G\)</span> 满足结合律得到。</li>
<li><span class="math inline">\(G^x\)</span> 具有单位元 <span class="math inline">\(e\)</span>，这是因为 <span class="math inline">\(e\)</span> 必定是 <span class="math inline">\(x\)</span> 的一个稳定子。</li>
<li><span class="math inline">\(G^x\)</span> 中的每一个元素 <span class="math inline">\(g\)</span> 都具有逆元，因为 <span class="math inline">\(\varphi(g^{-1},x)=\varphi(g^{-1},\varphi(g,x))=\varphi(g\cdot g^{-1},x)=\varphi(e,x)=x\)</span>。</li>
</ol>
<p>接下来证明 <span class="math inline">\([G:G^x]=\vert G(x)\vert\)</span>，也就是 <span class="math inline">\(G\)</span> 中 <span class="math inline">\(G^x\)</span> 的陪集数量恰好等于 <span class="math inline">\(x\)</span> 在 <span class="math inline">\(G\)</span> 作用下的轨道大小。</p>
<p>利用构造双射来证明，也就是陪集和轨道一一对应。</p>
<p>先证明相同轨道对应相同陪集。对于 <span class="math inline">\(f,g\in G\)</span>，<span class="math inline">\(x\)</span> 在 <span class="math inline">\(f,g\)</span> 的作用下转移到了 <span class="math inline">\(\varphi(f,x)\)</span> 和 <span class="math inline">\(\varphi(g,x)\)</span>。如果 <span class="math inline">\(\varphi(f,x)=\varphi(g,x)\)</span>，那么 <span class="math inline">\(\varphi(f\cdot g^{-1},x)=\varphi(g^{-1},\varphi(f,x))=\varphi(g^{-1},\varphi(g,x))=\varphi(e,x)=x\)</span>，也就是说 <span class="math inline">\(f\cdot g^{-1}\in G^x\)</span>，由陪集的性质可以得到，<span class="math inline">\(fG=gG\)</span>。</p>
<p>反过来便可以推出相同陪集对应相同轨道。</p>
<p>由此得证！</p>
<h1 id="burnside-引理">Burnside 引理</h1>
<p>推了这么多只是为了引出今天的主角：Burnside 引理和 Pólya 定理。</p>
<h2 id="等价类">等价类</h2>
<p>等价类是对于一个置换群 <span class="math inline">\(G\)</span> 作用于一个集合 <span class="math inline">\(X\)</span> 的情况下定义的。如果 <span class="math inline">\(\varphi(g,x)=y\)</span>，那么我们认为 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 在同一等价类中。</p>
<p>每一个等价类是一个集合，集合中的元素之间能够通过进行若干次这个二元函数后相等。</p>
<p>记 <span class="math inline">\(X/G\)</span> 表示 <span class="math inline">\(G\)</span> 作用在 <span class="math inline">\(X\)</span> 后产生的所有等价类的集合。</p>
<h2 id="内容">内容</h2>
<p><span class="math display">\[
\vert X/G\vert=\vert G\vert\sum_{g\in G}\vert X^g\vert
\]</span></p>
<p>这里 <span class="math inline">\(\vert X^g\vert\)</span> 表示 <span class="math inline">\(X\)</span> 集合中有多少个元素的稳定子包含 <span class="math inline">\(g\)</span>。</p>
<p>用文字描述就是：<span class="math inline">\(G\)</span> 作用于 <span class="math inline">\(X\)</span> 产生的等价类数量等于 <span class="math inline">\(x\)</span> 稳定子包含 <span class="math inline">\(g\)</span> 的数量的算术平均值。</p>
<h2 id="证明-1">证明</h2>
<p>我们用另一种形式表示 <span class="math inline">\(\sum_{g\in G}\vert X^g\vert\)</span>，像这样 <span class="math inline">\(\sum_{x\in X}\vert G^x\vert\)</span>，我们对这个形式进行变换： <span class="math display">\[
\begin{aligned}
\sum_{x\in X}\vert G^x\vert&amp;=\sum_{x\in X}\frac{\vert G\vert}{\vert G(x)\vert}&amp;\text{轨道-稳定子定理}\\
&amp;=\vert G\vert\sum_{x\in X}\frac{1}{\vert G(x)\vert}\\
&amp;=\vert G\vert\sum_{Y\in X/G}\sum_{x\in Y}\frac{1}{\vert G(x)\vert}\\
&amp;=\vert G\vert\sum_{Y\in X/G}\sum_{x\in Y}\frac{1}{\vert Y\vert}\\
&amp;=\vert G\vert\sum_{Y\in X/G}1\\
&amp;=\vert G\vert\vert X/G\vert
\end{aligned}
\]</span> 也就是说我们证明了 <span class="math inline">\(\sum_{g\in G}\vert X^g\vert=\vert G\vert\vert X/G\vert\)</span>。</p>
<p>将 <span class="math inline">\(\vert G\vert\)</span> 除过去得到 Burnside 引理。</p>
<h1 id="模板polya-定理"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQ5ODA=">【模板】Polya 定理</span></h1>
<h2 id="题目大意">题目大意</h2>
<p><span class="math inline">\(n\)</span> 种颜色给 <span class="math inline">\(n\)</span> 个点染色，问多少种本质不同的染色方案。本质不同定义为循环不同构。</p>
<p><span class="math inline">\(n\le 10^{9}\)</span>，多测，<span class="math inline">\(t\le 10^{3}\)</span>。</p>
<h2 id="解法">解法</h2>
<p>设群 <span class="math inline">\(G\)</span> 为旋转 1 次，旋转 2 次，……，旋转 <span class="math inline">\(n\)</span> 次组成置换群。</p>
<p>集合 <span class="math inline">\(X\)</span> 为染色的方案的集合。</p>
<p>群 <span class="math inline">\(G\)</span> 作用于集合 <span class="math inline">\(X\)</span> 上，得到的一个等价类是同一种染色方案。所以我们只需要求等价类的数量即可。</p>
<p>利用 Burnside 引理，我们可以预见到，设 <span class="math inline">\(X^p\)</span> 表示 <span class="math inline">\(X\)</span> 集合中有多少个染色方案在旋转 <span class="math inline">\(p\)</span> 次之后，仍然相同，那么根据 Burnside 引理，我们知道 <span class="math inline">\(\vert X/G\vert=\frac{1}{\vert G\vert}\sum_{p\in G}X^p\)</span>，在这道题中，相当于： <span class="math display">\[
ans=\frac{1}{n}\sum_{i=1}^{n}X^{i}
\]</span> 如果旋转 <span class="math inline">\(i\)</span> 次之后和原来相同，其充要条件就是有长度为 <span class="math inline">\(j\)</span> 的循环节，且 <span class="math inline">\(j\vert i\)</span>。</p>
<p>另外我们知道 <span class="math inline">\(j\)</span> 还得满足 <span class="math inline">\(j\vert n\)</span>，也就是说循环节长度最长为 <span class="math inline">\(\gcd(i,n)\)</span>。所以 <span class="math inline">\(X^i\)</span> 可以转写为 <span class="math inline">\(n^{\gcd(i,n)}\)</span>，因为循环节内部可以任意染色。</p>
<p>也就是 <span class="math display">\[
ans=\frac{1}{n}\sum_{i=1}^{n}n^{\gcd(i,n)}
\]</span> 进行常见的变换 <span class="math display">\[
ans=\frac{1}{n}\sum_{d\vert n}n^{d}\sum_{i=1}^{\frac{n}{d}}[\gcd(i,\frac{n}{d})=1]
\]</span> 第二个 <span class="math inline">\(\Sigma\)</span> 就是欧拉函数，所以： <span class="math display">\[
ans=\frac{1}{n}\sum_{d\vert n}n^{d}\varphi(\frac{n}{d})
\]</span> 在本题中暴力计算欧拉函数是可以通过的，时间复杂度约为 <span class="math inline">\(O(n^{\frac{1}{2}+\epsilon})\)</span>，其中 <span class="math inline">\(\epsilon\)</span> 是一个任意大于 0 的实数（CHD说的）。</p>
<h1 id="pólya-定理">Pólya 定理</h1>
<p>我们发现置换群中，如果是 <span class="math inline">\(i\)</span> 置换到 <span class="math inline">\(p_i\)</span>，那么我们从 <span class="math inline">\(i\)</span> 向 <span class="math inline">\(p_i\)</span> 连一条边，那么一定会形成若干个置换环。将这些环染色，不难发现，如果要满足上面所说的，旋转之后是等价类，那么每一个环的颜色都应当是相同的。所以如果一种置换 <span class="math inline">\(g\in G\)</span> 有 <span class="math inline">\(c_g\)</span> 个环，那么 <span class="math display">\[
\vert X/G\vert=\frac{1}{\vert G\vert}\sum_{g\in G}m^{c_{g}}
\]</span> 其中 <span class="math inline">\(m\)</span> 是不同的颜色个数。</p>
<p>注意到这个定理和 Burnside 定理的不同之处在于 <span class="math inline">\(\Sigma\)</span> 后面的内容。<span class="math inline">\(m^{c_{g}}\)</span> 和 <span class="math inline">\(n^g\)</span>，按照上面的推理，可以发现两者是等价的。</p>
<h1 id="p1446-hnoi2008-cards"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE0NDY=">P1446 [HNOI2008] Cards</span></h1>
<h2 id="题目大意-1">题目大意</h2>
<p>将 <span class="math inline">\(n=r+b+g\)</span> 张牌染色，需要染出 <span class="math inline">\(r\)</span> 张红牌，<span class="math inline">\(b\)</span> 张蓝牌，<span class="math inline">\(g\)</span> 张绿牌。并给定 <span class="math inline">\(m\)</span> 种置换方案，这些置换满足封闭性，具有逆元。</p>
<p>如果两种染色方案通过洗牌能够相同，就认为这两种方案不是同一种方案。求方案数对给定的质数 <span class="math inline">\(p\)</span> 取模的结果。</p>
<p><span class="math inline">\(r,b,g\le 20,m\le60\)</span>。</p>
<h2 id="解法-1">解法</h2>
<p>因为这是例题，第一感觉是题目给出了一个置换群，那么我能不能使用 Polya 定理？那么求出每一种置换的数目之后，利用 Polya 定理就可以快速算出了。我发现这样的时间复杂度是 <span class="math inline">\(O(nm)\)</span> 的。数据范围这么小，不合理。</p>
<p>Polya 定理中，隐含了要求，其对于集合 <span class="math inline">\(X\)</span> 必须是所有可能的集合。也就是说，不能对颜色进行限制。但是这道题限制了每一种颜色的数目。</p>
<p>我继续分析道，仍然按照其思想，形成了若干个环，要想满足置换后相同，每一个环仍然要求具有相同的颜色。能否将 Polya 定理中的 <span class="math inline">\(m^{c_g}\)</span> 修改为将这些环染色，满足染成红色的环的个数和为 <span class="math inline">\(r\)</span> 以此类推。得到的方案数，累加起来，除以 <span class="math inline">\(\vert G\vert\)</span> 是否就可行了呢？</p>
<p>其实到这里就已经不再是 Polya 定理了，而是 Burnside 定理的形式了。我们其实是考虑了每一种置换，与有多少中染色方案满足，这就是 Burnside 定理。</p>
<p>所以使用背包计数即可。</p>
<h1 id="p3307-sdoi2013-项链"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMzMDc=">P3307 [SDOI2013] 项链</span></h1>
<p>黑题果然不简单。</p>
<h2 id="题目大意-2">题目大意</h2>
<p><span class="math inline">\(n\)</span> 个点的一个环中，每一个点需要染 <span class="math inline">\([1,m]\)</span> 之中的三种颜色（同个一个点可以染多种相同的颜色）。</p>
<p>要求：</p>
<ol type="1">
<li>每一个点染的颜色的编号 <span class="math inline">\(\gcd\)</span> 为 1。</li>
<li>相邻两个点的颜色互不相同，这里定义不同是两个点染的颜色形成的可重集不同。</li>
</ol>
<p>现在要求有多少种本质不同的染色方案。两种染色方案相同，当且仅当将这个环旋转若干次之后相同。</p>
<p>多测，<span class="math inline">\(t\le 10,n\le 10^{14},m\le 10^{7}\)</span>。</p>
<h2 id="解法-2">解法</h2>
<p>首先解决这个 <span class="math inline">\(\gcd\)</span>，一眼莫反，直接上 <span class="math inline">\(O(m+tm)\)</span> 的暴力莫反。</p>
<p>然后要解决相邻不能相同的问题。我问 CHD，他说：每一个点不能和它左边的点颜色相同，所以每一个点都有 <span class="math inline">\(m-1\)</span> 种染色方案，总共就是 <span class="math inline">\((m-1)^{n}\)</span>。过不了样例。</p>
<p>我问 wtc，他说：设 <code>f[i][0/1]</code> 表示第 <span class="math inline">\(i\)</span> 个和第 1 个是否相同，然后矩阵优化。</p>
<p>最后解决本质不同，直接上 po 定理即可。时间复杂度我也不知道，因为 phi 函数是暴力求的。</p>
<p>最后 WA 一个点。原来是因为 <span class="math inline">\(n\ge mod\)</span>，所以可能存在 <span class="math inline">\(n\)</span> 是模数的倍数的情况。这时候，就对 <span class="math inline">\(mod^{2}\)</span> 取模。最后，如果 <span class="math inline">\(n\)</span> 是 <span class="math inline">\(mod\)</span> 的倍数，那么 <span class="math inline">\(ans\)</span> 先直接除以 <span class="math inline">\(mod\)</span>，然后求 <span class="math inline">\(\frac{n}{mod}\)</span> 在模 <span class="math inline">\(mod\)</span> 意义下的逆元，相乘即可（我也不知道为什么）。</p>
<p>然后 TLE 了，原来是因为最开始那个 gcd 我不用整除分块来算。</p>
]]></content>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>一种基于DFS序与RMQ的LCA算法</title>
    <url>/posts/%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8EDFS%E5%BA%8F%E4%B8%8ERMQ%E7%9A%84LCA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>[非原创] 本文将介绍一种基于预处理DFS序，做到在线 <span class="math inline">\(O(1)\)</span> 回答询问的 LCA 算法。</p>
<span id="more"></span>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvQWxleFdlaS9sZW5nLW1lbi1rZS1qaS1kZnMteHUtcWl1LWxjYQ==">参考</span></p>
<p>该算法实现简洁，常数小，速度快；但是维护的信息较少，例如：求到 LCA 路径上除 LCA 外深度最小的节点。</p>
<p>算法流程：首先处理出节点的 dfn 序。假设 <span class="math inline">\(dfn[u]&lt;dfn[v]\)</span>，下面分类讨论：</p>
<ol type="1">
<li><p>u 和 v 之间不存在祖先关系。那么必然是先遍历到 LCA，再到 u，最后到 v。</p>
<p>并且在 <span class="math inline">\(dfn[u]\)</span> 到 <span class="math inline">\(dfn[v]\)</span> 这段区间中，深度最小的点就是 LCA 的某一个儿子。只要求该点父亲即可。</p>
<p>考虑遍历的过程，容易发现其正确性。</p></li>
<li><p>u 和 v 之间一个是另一个的祖先。那么显然是 dfn 序较小的那一个。</p>
<p>但是我们不能知道什么时候是第一种情况，什么时候是第二种情况。</p>
<p>我们考虑，如果出现了第二种情况，求 <span class="math inline">\(dfn[u]\)</span> 到 <span class="math inline">\(dfn[v]\)</span> 之间的深度最小的点，当然是 u ，如果我们求 <span class="math inline">\(dfn[u]+1\)</span> 到 <span class="math inline">\(dfn[v]\)</span> 之间的深度最小点，必然是 u 的某个儿子；同时，如果是第一种情况，这样求也是对的。</p></li>
</ol>
<p>唯一注意 <span class="math inline">\(u=v\)</span> 时要特判。</p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>初中化学-上</title>
    <url>/posts/%E5%88%9D%E4%B8%AD%E5%8C%96%E5%AD%A6-%E4%B8%8A/</url>
    <content><![CDATA[<p>大多数内容都是抄书的，没有什么好看的。</p>
<span id="more"></span>
<h1 id="走进化学世界">走进化学世界</h1>
<h2 id="物质的变化与性质">物质的变化与性质</h2>
<ol type="1">
<li>化学，是一门研究物质的结构，组成，性质，变化规律的科学。</li>
<li>物理变化与化学变化：物理变化过程中没有新物质生成，化学变化中有新物质生成。化学变化常常伴随物理变化。</li>
<li>在化学变化中表现出来的是化学性质，物质不需要化学变化就表示出的是物理性质。</li>
</ol>
<h2 id="走进化学实验室">走进化学实验室</h2>
<h3 id="取用药品">取用药品</h3>
<p>总原则：</p>
<ol type="1">
<li>按量取用。如果没有特别说明，固体铺满试管底部，液体1至2毫升即可。取多了不能放回去，不能乱扔，不能带走，要放在指定位置。</li>
<li>“三不”：不能手拿，舌尝，直接鼻闻（应当扇闻）。</li>
</ol>
<h4 id="固体药品">固体药品</h4>
<ol type="1">
<li>固体药品保存在 <strong>广口瓶</strong> 中。</li>
<li>取用固体药品使用 <strong>药匙</strong> 或 <strong>镊子</strong>。用完之后用干净的纸擦拭干净。</li>
<li>放入玻璃容器时：
<ol type="1">
<li>把容器横放。</li>
<li>密度较大的块状药品或金属颗粒：放到 <strong>容器口</strong> ，再慢慢竖起容器。（防止打破容器）</li>
<li>固体粉末：用药匙或纸槽将药品送至 <strong>试管底部</strong>，再竖起试管。（避免药品粘在管口或管壁）</li>
</ol></li>
</ol>
<h4 id="液体药品">液体药品</h4>
<ol type="1">
<li>液体药品存放在 <strong>细口瓶</strong> 中。</li>
<li>用 <strong>倾倒法</strong> 取用。瓶盖要倒放在桌子上（以免药品被污染）；标签朝向手心（以免残留液腐蚀标签）；瓶口要紧靠试管口边缘。</li>
<li>定量取用时使用 <strong>量筒</strong>，注意视线与凹液面最低处水平。</li>
<li>少量取用使用 <strong>滴管</strong>。
<ul>
<li>要先在液体外挤压出滴管内空气（防止污染药品），然后吸取药品。</li>
<li>滴入试剂时，滴管要垂直悬浮于容器上方，不能将滴管伸入容器或接触容器壁（否则容易造成滴管头破裂）。</li>
<li>不能倒放，平放（防止胶头被腐蚀）。</li>
<li>如果不是和细口瓶配套的胶头滴管，用完后，要清洗。否则不能清洗（否则会稀释药品）</li>
</ul></li>
</ol>
<h3 id="加热物质">加热物质</h3>
<p>使用酒精灯加热物质。</p>
<p>酒精灯使用注意事项：</p>
<ol type="1">
<li>不要在点燃的酒精灯里加酒精，不要用酒精灯引燃酒精灯。</li>
<li>酒精灯内酒精不能少于 <strong>四分之一</strong>，不能多于 <strong>三分之二</strong>。（太少时酒精与空气混合物容易爆炸，太多时酒精容易溢出）</li>
<li>用完酒精灯要用灯帽盖灭，然后提起灯帽，再盖灭一次。（第一次目的是熄灭酒精灯的火焰。 第二次目的是使盖子内外气压平衡）</li>
<li>如果酒精灯洒出的酒精不慎燃烧，用湿抹布盖灭。（看同学试过，确实能盖灭）</li>
</ol>
<p>物质加热注意事项：</p>
<ol type="1">
<li>试管内液体不能超过 <strong>三分之一</strong>。（否则沸腾的时候会洒出）</li>
<li>使用试管夹时，应从底部进，底部出。</li>
<li>加热时，先预热，再用外焰固定加热。（防止炸裂）</li>
<li>试管不要对着人。</li>
<li>用完之后，不能立即清洗，要等待冷却。（防止炸裂）</li>
</ol>
<details class="note success"><summary><p>实验1-6</p>
</summary>
<p><span class="math display">\[
\ce{2NaOH + CuSO4-&gt;Na2SO4 + Cu(OH)2 v }
\]</span> 这个反应属于复分解反应，由于硫酸铜溶液是蓝色的，而硫酸钠溶液是无色的，氢氧化铜是所以实验现象描述为：</p>
<p>溶液变为无色，有蓝色沉淀生成。</p>
<p>持续加热时，氢氧化铜是弱碱，受热分解成黑色氧化铜和水，除此外，受温度控制，反应物浓度影响，还可能生成部分砖红色的氧化亚铜。</p>

</details>
<h1 id="空气">空气</h1>
<ol type="1">
<li>空气成分：78% 的氮气，21% 的氧气，0.94% 的稀有气体，0.03% 的二氧化碳，0.03% 的杂质。</li>
<li>氮气用于保护气，液氮低温，稀有气体用于保护气，作电光源。</li>
<li>大气污染物：二氧化硫，一氧化碳，二氧化氮，<span class="math inline">\(\text{PM}_{10}\)</span>，<span class="math inline">\(\text{PM}_{2.5}\)</span>，臭氧。空气质量越小越好。</li>
</ol>
<h2 id="氧气">氧气</h2>
<ol type="1">
<li>无色无味，密度比空气略大，不易溶于水，液体呈淡蓝色，固体呈淡蓝色雪花状。</li>
<li>工业上储存氧气于蓝色钢瓶。</li>
<li>氧气支持燃烧。</li>
<li>硫在空气中燃烧，产生 <strong>淡蓝色</strong> 火焰；在氧气中燃烧，产生 <strong>蓝紫色</strong> 火焰。都产生有刺激性气味的气体，放热。</li>
<li>木炭在空气中燃烧，发出 <strong>红光</strong>，在氧气中燃烧，发出 <strong>白光</strong>。都产生一种能让澄清石灰水变浑浊的气体，放热。</li>
<li>铁在空气中不燃烧，在氧气中剧烈燃烧，火星四射，生成一种黑色固体。</li>
<li>上述三个实验说明：氧气的化学性质比较活泼，物质在空气燃烧实际上是在于其中的氧气发生反应。由于空气中的氧气含量较少，反应没有氧气中那么剧烈。</li>
<li>剧烈氧化：燃烧。缓慢氧化：动植物呼吸，食物腐烂等。</li>
</ol>
<h2 id="制取氧气">制取氧气</h2>
<ol type="1">
<li><p><span class="math display">\[
\ce{2KMnO4-&gt;[\Delta]K2MnO4 + MnO2 + O2 ^}
\]</span></p></li>
<li><p><span class="math display">\[
\ce{2H2O2-&gt;[MnO2]2H2O + O2 ^}
\]</span></p></li>
<li><p><span class="math display">\[
\ce{2KClO3 -&gt;[MnO2][\Delta]2KCl + 3O2 ^}
\]</span></p></li>
</ol>
<h1 id="水">水</h1>
<ol type="1">
<li>淡水占 2.53%，可利用的淡水占其中的 30.4%</li>
<li>爱护水资源：节约用水和防治水体污染。</li>
<li>水体污染来源：工业污染，农业污染，生活污水。</li>
</ol>
<h2 id="水的净化">水的净化</h2>
<details class="note success"><summary><p>实验4-2 过滤水的实验</p>
</summary>
<p><strong>仪器</strong>：玻璃棒（引流，防止液体溅出），滤纸，漏斗，烧杯，带铁圈的铁架台。</p>
<p>操作要点：</p>
<ol type="1">
<li><strong>一贴</strong>：滤纸要紧贴漏斗壁。（防止产生气泡，气泡会减慢液体流速）</li>
<li><strong>二低</strong>：
<ol type="1">
<li>滤纸要低于漏斗边缘。（防止液体从漏斗外流下）</li>
<li>液面低于滤纸边缘。（防止液体从滤纸与漏斗之间流下）</li>
</ol></li>
<li><strong>三靠</strong>：
<ol type="1">
<li>烧杯尖紧靠玻璃棒中部。（防止液体流到漏斗外）</li>
<li>玻璃棒紧靠在三层滤纸的一侧。（滤纸折叠时，会有一块区域有三层。防止戳破滤纸）</li>
<li>漏斗下端紧靠烧杯内壁。（防止滤液漏出）</li>
</ol></li>
</ol>

</details>
<p>上面的操作可以去除水中大部分不溶性杂质。里面可能含有可溶性杂质，例如钙和镁。</p>
<p>不含或少含钙和镁的水叫作软水，含钙和镁较多的水叫作硬水。</p>
<details class="note success"><summary><p>实验4-4 蒸馏水的实验</p>
</summary>
<figure>
<img src="https://bkimg.cdn.bcebos.com/pic/4610b912c8fcc3ce5767c9759345d688d53f20d4?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto" alt="装置图片" /><figcaption aria-hidden="true">装置图片</figcaption>
</figure>
<p>利用水蒸气冷凝来净化水的方式称为蒸馏。</p>
<p>在水沸腾之后，在冷凝管中，有冷水，将沸腾的水蒸气冷却。</p>

</details>
<h2 id="水的组成">水的组成</h2>
<p>水是由氢元素和氧元素组成的，水的化学式是 <span class="math inline">\(\ce{H2O}\)</span>。</p>
<p>点燃氢气要验纯，不纯的氢气会爆炸。</p>
<h1 id="化学方程式">化学方程式</h1>
<h2 id="质量守恒定律">质量守恒定律</h2>
<p>天平的使用方法与化学相同，但是要注意：</p>
<ol type="1">
<li>称量干燥的固体药品要放在干净的纸上称量。</li>
<li>容易潮解（即从空气中吸收水分）的物质要放在玻璃器皿中称量。</li>
</ol>
<details class="note success"><summary><p>实验-方案一 红磷燃烧</p>
</summary>
<ol type="1">
<li>气球的作用：缓冲压强，防止瓶内压强太大，把橡胶塞冲出。</li>
<li>细沙的作用：防止瓶底受热不均炸裂。</li>
<li>玻璃管下端与红磷接触：引燃红磷。</li>
<li>红磷燃烧结束后，应等待锥形瓶冷却至室温再称量，防止浮力影响实验结果。</li>
</ol>

</details>
<details class="note success"><summary><p>实验-方案二 铁与硫酸铜反应</p>
</summary>
<p>现象：铁逐渐溶解，溶液蓝色褪去，有红色固体析出，生成绿色溶液。</p>

</details>
<h1 id="碳">碳</h1>
<h2 id="碳的单质">碳的单质</h2>
<ol type="1">
<li><p>金刚石：无色固体，天然存在最硬的物质。</p></li>
<li><p>石墨：灰黑色细鳞片状固体，有金属光泽，软而滑腻。具有优良的导电性能。</p>
<p>木炭，活性炭：结构与石墨类似，疏松多孔而具有吸附性。</p>
<p>焦炭：结构与石墨类似，用于炼铁。</p></li>
<li><p><span class="math inline">\(\ce{C60}\)</span>，很有潜力的单质。</p></li>
</ol>
<h2 id="碳的反应">碳的反应</h2>
<ol type="1">
<li><p>与氧气反应：</p>
<p>在氧气充分的情况下燃烧： <span class="math display">\[
\ce{C + O2-&gt;[点燃]CO2}
\]</span> 在氧气不充分的情况下燃烧： <span class="math display">\[
\ce{2C + O2-&gt;[点燃]2CO}
\]</span> 都放出热量。</p></li>
<li><p>还原金属氧化物反应</p>
<p>还原氧化铜： <span class="math display">\[
\ce{2CuO + C-&gt;[高温] 2Cu + CO2 ^}
\]</span> 还原氧化铁： <span class="math display">\[
\ce{3C + 2Fe2O3-&gt;[高温] 4Fe + 3CO2}
\]</span> 还原二氧化碳： <span class="math display">\[
\ce{CO2 + C-&gt;[高温]2CO}
\]</span></p></li>
</ol>
<h2 id="二氧化碳">二氧化碳</h2>
<h3 id="制取">制取</h3>
<p>用稀盐酸和大理石制取： <span class="math display">\[
\ce{CaCO3 + 2HCl-&gt;CaCl2 + CO2 ^ + H2O}
\]</span> <details class="note info"><summary><p>关于材料选取</p>
</summary>
<p>不选用浓盐酸，因为浓盐酸会挥发出 <span class="math inline">\(\ce{HCl}\)</span> 气体，使得制得的气体不纯。</p>
<p>不选用稀硫酸，因为反应生成的 <span class="math inline">\(\ce{CaSO4}\)</span> 微溶于水，会附着在大理石上，阻碍反应进行。</p>
<p>不选用粉末，反应速率太快，不利于收集。</p>

</details></p>
<p>工业制取：高温煅烧石灰石 <span class="math display">\[
\ce{CaCO3-&gt;[高温]CaO + CO2 ^}
\]</span> 关于反应装置，有多种，注意启普发生器</p>
<h3 id="性质">性质</h3>
<p>无色无味，极易溶于水，密度比空气大，与水反应生成碳酸。碳酸不稳定，容易分解成二氧化碳和水。</p>
<p>能使澄清石灰水变浑浊。（用于检验二氧化碳）</p>
<p>可以用于灭火，作气体肥料，化工原料，干冰等。</p>
<p>温室气体：二氧化碳，甲烷，氟利代烷等。</p>
<h2 id="一氧化碳">一氧化碳</h2>
<p>无色无味，密度比空气略小，难溶于水。可以燃烧，火焰呈蓝色，生成二氧化碳。</p>
<p>有毒性，可造成人缺氧死亡。</p>
<p>还原性，可以用来还原氧化铜。 <span class="math display">\[
\ce{CuO + CO-&gt;[\Delta] Cu + CO2}
\]</span></p>
<details class="note success"><summary><p>还原氧化铜的实验</p>
</summary>
<ol type="1">
<li>先通入一氧化碳，排出空气，防止加热时爆炸。</li>
<li>结束后先熄灭酒精灯，防止氧气重新氧化 <span class="math inline">\(\ce{Cu}\)</span>，防止石灰水倒吸，炸裂试管。</li>
<li>CO有毒，要处理尾气，可以点燃或者收集。</li>
</ol>

</details>
<h1 id="燃烧">燃烧</h1>
<ol type="1">
<li>条件：可燃物，着火点，氧气。</li>
<li>灭火：破坏条件。</li>
<li>爆炸：可燃物有限空间剧烈燃烧，气体体积迅速膨胀引起。粉尘也能爆炸。</li>
<li>爆炸极限：可燃性气体在空气中达到爆炸极限，遇到明火就会爆炸。</li>
</ol>
<h2 id="化石燃料">化石燃料</h2>
<ol type="1">
<li>煤：主要是碳元素，含有氢元素。</li>
<li>煤气：由煤分解来，主要成分为氢气，甲烷，一氧化碳。</li>
<li>石油：主要含有碳和氢元素。</li>
<li>天然气：主要成分是甲烷。</li>
</ol>
]]></content>
      <tags>
        <tag>化学</tag>
      </tags>
  </entry>
  <entry>
    <title>初中化学-下</title>
    <url>/posts/%E5%88%9D%E4%B8%AD%E5%8C%96%E5%AD%A6-%E4%B8%8B/</url>
    <content><![CDATA[<p>都是抄书上的，没有意思。</p>
<span id="more"></span>
<details class="note info"><summary><p>彩蛋</p>
</summary>
<p>来源：<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlOEMlOTYlRTUlQUQlQTYlRTclODklODglRTMlODAlOEElRTklOUQlOTIlRTglOEElQjElRTclOTMlQjclRTMlODAlOEIvMjcxNTIzNSM1">百度百科</span></p>
<p>广东台山市一化学老师的《化学版青花瓷》歌词</p>
<p>（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/ph5HlsZ7nprvlrZAvNjgxNjMzOD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">金属离子</span>相关）</p>
<p>蓝色絮状的沉淀跃然试管底</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/pk5znprvlrZAvMD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">铜离子</span>遇<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/msKLmsKfmoLkvMD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">氢氧根</span> 再也不分离[Cu2++2OH-=Cu(OH)2↓]</p>
<p>当溶液呈金黄色 因为铁三价</p>
<p>浅绿色二价亚铁把人迷</p>
<p>（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/kuZnngpQvMD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">乙炔</span>相关）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/nlLXnn7MvMzA2MjAzND9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">电石</span>偷偷去游泳 生成<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/kuZnngpQvMTE3NjkyMD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">乙炔</span>气[CaC2+2H2O=Ca(OH)2+C2H2↑]</p>
<p>点燃后变乙炔焰 高温几千几</p>
<p>逸散那<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/kuozmsKfljJbnorMvMzQ5MTQzP2Zyb21Nb2R1bGU9bGVtbWFfaW5saW5r">二氧化碳</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/nn7PngbDmsLQvNzcyMzA3OD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">石灰水</span>点缀白色沉底[CO2+Ca(OH)2=CaCO3↓ + H2O]</p>
<p>（苯相关）</p>
<p>苯遇<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/pq5jplLDphbjpkr4vOTk2NDc/ZnJvbU1vZHVsZT1sZW1tYV9pbmxpbms=">高锰酸钾</span> 变色不容易</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/nlLLoi68vMD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">甲苯</span>上加<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/noZ3ln7ovMD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">硝基</span> 小心<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9UTlQvNjczNjMyP2Zyb21Nb2R1bGU9bGVtbWFfaW5saW5r">TNT</span></p>
<p>在苯中的碘分子紫色多美丽</p>
<p>就为萃取埋下了伏笔</p>
<p>（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/nlLXljJblraYvMTUxODA0P2Zyb21Nb2R1bGU9bGVtbWFfaW5saW5r">电化学</span>相关）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/nlLXop6PmsaAvMD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">电解池</span><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/nlLXop6PotKgvMD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">电解质</span> 通电阴阳极</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/ljJblkIjku7cvMTQ1NTc2Nz9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">化合价</span>有高低 电子来转移</p>
<p>精炼了铜铁锌锰镍铬铝银锡</p>
<p>留下<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/pmLPmnoHms6UvOTMyMzg1OT9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">阳极泥</span></p>
<p>（酸碱有关）</p>
<p>无色<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/phZrphZ4vMTU5NjkyND9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">酚酞</span>面对碱 羞涩脸绯红</p>
<p>紫色<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/nn7PolYovMTk4MTUwNzU/ZnJvbU1vZHVsZT1sZW1tYV9pbmxpbms=">石蕊</span>遇到碱 青蓝慢淡出</p>
<p>酸碱和盐溶入水 离子解离开</p>
<p>酸和氢氧根金属三角恋</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/msKLmsKfljJbpkqAvMTE0NTU2P2Zyb21Nb2R1bGU9bGVtbWFfaW5saW5r">氢氧化钠</span> 易腐蚀 潮解味道涩</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/ngavnorEvMjc1MTYzOD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">火碱</span><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/ng6fnorEvMTQwMDUzOD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">烧碱</span><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/oi5vmgKfpkqAvMzkyNjgxOT9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">苛性钠</span>（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9OYU9ILzYyOTc1MjI/ZnJvbU1vZHVsZT1sZW1tYV9pbmxpbms=">NaOH</span>）俗名遍地找</p>
<p>你用途十分广泛</p>
<p>精炼石油制作<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/lubLnh6XliYIvODI5Nzg5P2Zyb21Nb2R1bGU9bGVtbWFfaW5saW5r">干燥剂</span></p>
<p>（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/mtZPnoavphbgvMTEwMTg5Nz9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">浓硫酸</span>稀释）</p>
<p>稀释那浓硫酸 注酸入水里</p>
<p>沿器壁慢慢倒 搅拌手不离</p>
<p>浓酸沾皮肤立即大量水冲洗</p>
<p>涂抹上<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/norPphbjmsKLpkqAvMjczNTc3Mz9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">碳酸氢钠</span>救急</p>
<p>（生产实际）</p>
<p>甘油滋润皮肤 光滑细又腻</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/nhp/nn7PngbAvNjQ2NDg2Mj9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">熟石灰</span>入土地 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/phbjnorHluqYvNjMzMTkwP2Zyb21Nb2R1bGU9bGVtbWFfaW5saW5r">酸碱度</span>适宜</p>
<p>看酸红碱紫的试纸多么美丽</p>
<p>你眼带笑意</p>
<p>以下内容有些版本内没有</p>
<p>（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/mtZPnm5DphbgvMTAzNDE0OTk/ZnJvbU1vZHVsZT1sZW1tYV9pbmxpbms=">浓盐酸</span>有关）</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/nm5DphbgvMTE0NTE2P2Zyb21Nb2R1bGU9bGVtbWFfaW5saW5r">盐酸</span>似水透明 刺激有酸味</p>
<p>白雾袅袅升起 挥发小液滴</p>
<p>活泼金属及盐和<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/ph5HlsZ7msKfljJbniakvMTg3ODE3OD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">金属氧化物</span></p>
<p>就当我为验证你伏笔</p>
<p>（<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/mtZPnoavphbgvMD9mcm9tTW9kdWxlPWxlbW1hX2lubGluaw==">浓硫酸</span>有关）</p>
<p>硫酸不愿挥发 粘稠把水吸</p>
<p>木棒被打捞起 脱水使碳化</p>
<p>如传世的化尸水腐蚀千万物</p>
<p>你眼带笑意</p>

</details>
<h1 id="金属">金属</h1>
<ol type="1">
<li><p>共性：有金属光泽，有导电性，有延展性。</p></li>
<li><p>特性：</p>
<ol type="1">
<li>大多数金属呈银白色，铜呈红紫色，金呈黄色，铁粉呈黑色。</li>
<li>常温下大多数金属是固体，但是汞是液体。</li>
</ol></li>
<li><p>金属之最：</p>
<ol type="1">
<li>最硬：铬</li>
<li>密度最大：饿</li>
<li>密度最小：锂</li>
<li>导电导热性最好：银</li>
<li>熔点最高：钨</li>
<li>熔点最低：汞</li>
<li>地壳中含量最高：铝</li>
<li>人体中含量最高：钙</li>
<li>年产量最高：铁，铝，铜</li>
</ol></li>
<li><p>金属的活泼性：</p>
<p>K-&gt;Ca-&gt;Na-&gt;Mg-&gt;Al-&gt;Zn-&gt;Fe-&gt;Sn-&gt;Pb-&gt;(H)-&gt;Cu-&gt;Hg-&gt;Ag-&gt;Pt-&gt;Au</p>
<p>前面的能把后面的金属从它们的化合物溶液中置换出来。</p>
<p>但是K、Ca、Na不能，因为它们过于活泼，会先和水反应。</p>
<details class="note success"><summary><p>你知道吗</p>
</summary>
<p>锌粒可以与硫酸铜溶液反应产生氢气，原理如下： <span class="math display">\[
\ce{Zn + CuSO4-&gt;Cu +ZnSO4}
\]</span></p>
<p><span class="math display">\[
\ce{Zn + 2H+ -&gt; Zn^{2-} + H2 ^}
\]</span></p>
<p>这是因为硫酸铜溶液在水中解离呈酸性，锌会与酸发生反应生成氢气。</p>

</details></li>
<li><p>常见金属的矿石：赤铁矿(<span class="math inline">\(\ce{Fe2O3}\)</span>)，磁铁矿(<span class="math inline">\(\ce{Fe3O4}\)</span>)，菱铁矿(<span class="math inline">\(\ce{FeCO3}\)</span>)，铝土矿(<span class="math inline">\(\ce{Al2O3}\)</span>)，黄铜矿(<span class="math inline">\(\ce{CuFeS2}\)</span>)，辉铜矿(<span class="math inline">\(\ce{Cu2S}\)</span>)，孔雀石(<span class="math inline">\(\ce{Cu2(OH)2CO3}\)</span>)</p></li>
</ol>
<h1 id="酸和碱">酸和碱</h1>
<h2 id="酸碱指示剂">酸碱指示剂</h2>
<ol type="1">
<li>石蕊溶液：遇到酸变红，遇到碱变蓝。</li>
<li>无色酚酞溶液：遇到酸不变色，遇碱变红。</li>
</ol>
<h2 id="常见的酸">常见的酸</h2>
<p>将介绍盐酸、硫酸、硝酸。是六大无机强酸中的三个。</p>
<details class="note success"><summary><p>浓盐酸</p>
</summary>
<p>浓盐酸是 <span class="math inline">\(\ce{HCl}\)</span> 的水溶液，密度比水大，常用的浓盐酸浓度在 37% 左右。</p>
<p>无色透明，腐蚀性较强，挥发性极强，盛有浓盐酸的容器打开后，会挥发出 <span class="math inline">\(\ce{HCl}\)</span> 气体，在空气中形成水雾。</p>
<p>人体内胃酸的主要成分是盐酸。除此之外，盐酸还可以给金属除锈。</p>

</details>
<details class="note success"><summary><p>硫酸</p>
</summary>
<p>浓硫酸：</p>
<ul>
<li><p>浓硫酸是 <span class="math inline">\(\ce{H2SO4}\)</span> 的水溶液，密度比水大，常用的浓硫酸浓度在 98% 左右。</p>
<p>无色粘稠，油状液体，腐蚀性强，能够腐蚀大部分金属（常压沸腾情况，能够腐蚀除了铱和钌以外的所有金属）。</p>
<ul>
<li><p>吸水性（物理变化）：浓硫酸能吸收周围空气中的水蒸气，可以作干燥剂。</p></li>
<li><p>脱水性（即腐蚀性，是化学变化）：浓硫酸中含有大量未被电离的硫酸分子，会将有机物中的氢元素和氧元素按照水的形式脱去（即 1:2）。</p>
<p>例如蔗糖(<span class="math inline">\(\ce{C12H22O11}\)</span>)，在浓硫酸的催化作用下脱水，生成碳和水： <span class="math display">\[
\ce{C12H22O11-&gt;[浓H2SO4]C12 + 11H2O}
\]</span> 过程中放出的大量的热让浓硫酸和 <span class="math inline">\(\ce{C}\)</span> 反应： <span class="math display">\[
\ce{C + 2H2SO4-&gt;[\Delta]CO2 ^ + 2SO2 ^ 2H2O}
\]</span></p></li>
</ul></li>
<li><p>如果不慎接触浓硫酸需要立即用大量的水清洗（能够带走反应放出的热），并涂上浓度3%到5%的碳酸氢钠溶液（酸碱中和）。</p></li>
<li><p>硫酸溶解于水的时候会放出大量的热。所以稀释的时候不能将水倒入浓硫酸中，否则因为水的密度小，浮在浓硫酸上面，溶解时放热，使得水沸腾，硫酸液滴就会飞溅，危险！</p></li>
<li><p>正确的溶解应该将浓硫酸缓慢倒入水中，并不断用玻璃棒搅拌（加快热量散失）。</p></li>
<li><p>浓硫酸滴入紫色石蕊溶液先变红（因为呈酸性），一会后变无色（因为浓硫酸有强氧化性）</p></li>
</ul>
<p>稀硫酸：</p>
<ul>
<li>稀硫酸中的 <span class="math inline">\(\ce{H2SO4}\)</span> 被全部电离，所以不具有强氧化性，吸水性，脱水性等性质。</li>
</ul>

</details>
<details class="note success"><summary><p>硝酸</p>
</summary>
<p>纯硝酸无色透明，浓硝酸常常为淡黄色液体（硝酸遇光分解放出二氧化氮 <span class="math inline">\(\ce{4HNO3-&gt;[光照]4NO2 + O2 ^ + H2O}\)</span>，二氧化氮呈淡黄色），有窒息性刺激气味。</p>
<p>浓硝酸容易挥发，和盐酸一样会产生白雾。</p>
<p>稀释时，与硫酸类似，会产生大量的热。</p>

</details>
<p>酸的化学性质：</p>
<ol type="1">
<li><p>与指示剂反应：能使紫色石蕊溶液变红。</p></li>
<li><p>与金属活动性顺序排在氢前面的发生置换反应，生成盐和氢气。（除锈原理）</p>
<p>示例： <span class="math display">\[
\ce{Mg + 2HCl-&gt; MgCl2 + H2 ^}
\]</span></p>
<p><span class="math display">\[
\ce{Zn + H2SO4-&gt; ZnSO4 + H2 ^}
\]</span></p></li>
<li><p>与某些碱性氧化物发生复分解反应，产生水和盐。</p>
<p>示例： <span class="math display">\[
\ce{Fe2O3 + HCl -&gt; 2FeCl3 + 3H2O}
\]</span></p>
<p><span class="math display">\[
\ce{CuO + H2SO4-&gt; CuSO4 + H2O}
\]</span></p></li>
<li><p>与含碳酸根的化合物发生复分解反应产生二氧化碳。</p>
<p>示例： <span class="math display">\[
\ce{CaCO3 + 2HCl -&gt; CaCl2 + H2O + CO2 ^}
\]</span></p>
<p><span class="math display">\[
\ce{Na2CO3 + 2HCl-&gt; 2NaCl + H2O + CO2 ^}
\]</span></p></li>
<li><p>和碱发生中和反应。</p></li>
</ol>
<h2 id="常见的碱">常见的碱</h2>
<details class="note success"><summary><p>氢氧化钠</p>
</summary>
<p>氢氧化钠俗称苛性钠，烧碱，火碱。呈白色结晶粉末状。易溶于水。</p>
<ul>
<li>强烈腐蚀性，如果不慎沾到，也是要用大量的水冲洗，并涂上硼酸溶液（酸碱中和，硼酸是一种一元极弱酸）。</li>
<li>类似于浓硫酸，溶解时会放热。和无机酸中和也会放热。</li>
<li>潮解性：氢氧化钠在空气中会吸收水蒸气，可以用于作气体的干燥剂（不能干燥酸性气体）。</li>
<li>能与油脂反应，生活中用于炉具清洁剂等。</li>
</ul>

</details>
<details class="note success"><summary><p>氢氧化钙</p>
</summary>
<p>氢氧化钙，俗称熟石灰或消石灰。</p>
<ul>
<li>微溶于水。澄清水溶液称为澄清石灰水，乳状悬浮液称为石灰乳。溶解度随着温度的升高而下降（主流解释：氢氧化钙的两种水合物的溶解度较大，而无水氢氧化钙的溶解度较小，随着温度升高，水合物逐渐变成无水氢氧化钙，溶解度降低）。</li>
<li>与二氧化碳反应生成碳酸钙（俗称石灰石），表现为溶液变浑浊。</li>
<li>可用于改良酸性土壤，配置波尔多液（石灰乳，硫酸铜）。</li>
<li>可以在树木上涂含硫磺粉的石灰浆，保护树木，防止冻伤和害虫生卵。</li>
</ul>

</details>
<h2 id="酸碱的本质">酸碱的本质</h2>
<p>酸是在电离出的阳离子都是 <strong>氢离子</strong> 的物质。</p>
<p>碱是在电离出的阴离子都是 <strong>氢氧根离子</strong> 的物质。</p>
<h2 id="杂项">杂项</h2>
<p>中和反应：酸和碱反应生成水和盐，盐是金属离子（或铵根离子）与酸根离子组成的化合物。</p>
<p>pH值：使用pH试纸测定溶液酸碱度，一般是0~14，中性为7，偏蓝为碱，偏红为酸（和紫色石蕊溶液一样）</p>
<p>土壤最好接近中性，pH&lt;4或者pH&gt;8不适于种植农作物。酸雨是pH&lt;5.6的雨。</p>
<h1 id="盐">盐</h1>
<p>盐是一类在水中电离成金属离子和酸根离子的化合物。</p>
<h2 id="常见的盐">常见的盐</h2>
<p>氯化钠：食盐的主要成分。不过多介绍啦。</p>
<p>碳酸钠：又叫纯碱，但是属于盐。也称苏打。用于做玻璃、造纸等。</p>
<p>碳酸氢钠：又叫小苏打，重碳酸钠，酸式碳酸钠。用于做面包。</p>
<p>碳酸钙：即石灰石、大理石的主要成分。用于建筑，还可以治疗胃酸过多（胃酸主要成分是盐酸，可以与碳酸钙反应）</p>
<h2 id="复分解反应">复分解反应</h2>
<p>石灰石与盐酸反应： <span class="math display">\[
\ce{CaCO3 + 2HCl-&gt; CaCl2 + H2CO3}
\]</span> 小苏打和盐酸反应： <span class="math display">\[
\ce{NaHCO3 + HCl-&gt;NaCl + H2CO3}
\]</span> 碳酸钠溶液和澄清石灰水反应： <span class="math display">\[
\ce{NaCO3 + Ca(OH)2-&gt; CaCO3 v + 2NaOH}
\]</span> 这些反应都：</p>
<ol type="1">
<li>发生在一个反应体系中（大部分情况为水溶液）。</li>
<li>两种化合物交换离子。</li>
<li>生成了难电离的沉淀，气体或弱电解质（最常见为水）。</li>
</ol>
<p>老师说：内内外外价不变，很形象地表现了这种反应形式： <span class="math display">\[
\ce{AB + CD -&gt; CB + AD}
\]</span> 这就相当于方程式中，处于”内部“的两个离子结合，”外部“的两个离子结合，生成物中各原子的化合价不变。</p>
<p>中和反应是复分解反应中的一种。</p>
<p>判断复分解反应能否发生要看能否产生沉淀，气体，水。气体和水是好判断的，问题是如何判断沉淀？</p>
<details class="note info"><summary><p>溶解性表</p>
</summary>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">阳离子</th>
<th style="text-align: center;"><span class="math inline">\(\ce{OH-}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\ce{NO3-}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\ce{Cl-}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\ce{SO4^{2-}}\)</span></th>
<th style="text-align: center;"><span class="math inline">\(\ce{CO3^{2-}}\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\ce{H+}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">溶、挥</td>
<td style="text-align: center;">溶、挥</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶、挥</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\ce{NH4+}\)</span></td>
<td style="text-align: center;">溶、挥</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\ce{K+}\)</span></td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\ce{Na+}\)</span></td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\ce{Ba2+}\)</span></td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">不</td>
<td style="text-align: center;">不</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\ce{Ca2+}\)</span></td>
<td style="text-align: center;">微</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">微</td>
<td style="text-align: center;">不</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\ce{Mg2+}\)</span></td>
<td style="text-align: center;">不</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">微</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\ce{Al3+}\)</span></td>
<td style="text-align: center;">不</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\ce{Mn2+}\)</span></td>
<td style="text-align: center;">不</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">不</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\ce{Zn2+}\)</span></td>
<td style="text-align: center;">不</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">不</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\ce{Fe2+}\)</span></td>
<td style="text-align: center;">不</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">不</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\ce{Fe3+}\)</span></td>
<td style="text-align: center;">不</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><span class="math inline">\(\ce{Cu2+}\)</span></td>
<td style="text-align: center;">不</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="even">
<td style="text-align: center;"><span class="math inline">\(\ce{Ag+}\)</span></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">溶</td>
<td style="text-align: center;">不</td>
<td style="text-align: center;">微</td>
<td style="text-align: center;">不</td>
</tr>
</tbody>
</table>
<p>（注：此为20℃的情况。“溶”表示那种物质可溶于水，“不”表示不溶于水，“微”表示微溶于水，“挥”表示挥发性，“-”表示那种物质不存在或遇到水就分解了）</p>
<p>资料来源：<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlQTQlOEQlRTUlODglODYlRTglQTclQTMlRTUlOEYlOEQlRTUlQkElOTQvMTEzMjg2NA==">百度百科</span></p>
<p>常考不溶性物质：</p>
<p>四种碱：<span class="math inline">\(\ce{Mg(OH)2}\)</span>，<span class="math inline">\(\ce{Al(OH)3}\)</span>，<span class="math inline">\(\ce{Cu(OH)2}\)</span>，<span class="math inline">\(\ce{Fe(OH)3}\)</span>。</p>
<p>四种盐：<span class="math inline">\(\ce{CaCO3}\)</span>，<span class="math inline">\(\ce{BaCO3}\)</span>，<span class="math inline">\(\ce{BaSO4}\)</span>，<span class="math inline">\(\ce{AgCl}\)</span>。</p>

</details>
<h2 id="化肥">化肥</h2>
<p>氮磷钾……快用 <span class="math inline">\(\ce{金坷垃 ^}\)</span></p>
<h1 id="化学与生活">化学与生活</h1>
<p>这一章全是知识点，不想再抄书了，看课本吧。</p>
]]></content>
      <tags>
        <tag>化学</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀函数</title>
    <url>/posts/%E5%89%8D%E7%BC%80%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>对前缀函数的简单介绍。</p>
<span id="more"></span>
<p>约定：字符串下标从 1 开始。</p>
<p>前缀函数是是 <span class="math inline">\(\pi\)</span> 数组，<span class="math inline">\(\pi_{i}\)</span> 表示字符串 <span class="math inline">\(s\)</span> 的前缀 <span class="math inline">\(s[1...i]\)</span> 的最长公共 <strong>真</strong> 前后缀（border）长度。</p>
<h1 id="kmp-算法">KMP 算法</h1>
<p>KMP 算法通过预处理前缀函数，加速字符串匹配过程。做到均摊 <span class="math inline">\(O(\lvert S\rvert+\lvert T\rvert)\)</span> 的时间复杂度。</p>
<h1 id="border-的理论">border 的理论</h1>
<p>border 的 border 仍然是 border，正确性显然。</p>
<h2 id="border-与周期">border 与周期</h2>
<p>形式化定义周期：对字符串 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(0 &lt; p \le \lvert S\rvert\)</span> ，有 <span class="math inline">\(s[i]=s[i+p]\)</span> 对所有 <span class="math inline">\(i \in [1,\lvert S\rvert - p]\)</span> 成立，则称 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(S\)</span> 的一个周期。</p>
<p>感性理解：用前 <span class="math inline">\(p\)</span> 个字符向后不断复制，能得到 <span class="math inline">\(s\)</span>，最后一次可以只复制一部分。</p>
<p>如果字符串 <span class="math inline">\(s\)</span> 有长度为 <span class="math inline">\(r\)</span> 的 border ，并且 <span class="math inline">\(r\ge \vert n \rvert /2\)</span> ，那么 <span class="math inline">\(s\)</span> 有周期长度就是 <span class="math inline">\(s-r\)</span> 。这两个条件应该是等价的。</p>
<p>证明：记 <span class="math inline">\(n=\lvert s\rvert\)</span> ，考虑 border ，是由前缀 <span class="math inline">\(s[1...r]\)</span> 和后缀 <span class="math inline">\(s[n-r+1,n]\)</span> 组成的。对于 <span class="math inline">\(i \in [1,r]\)</span> ，都有 <span class="math inline">\(s[i]=s[i+n-r]\)</span> 。由周期的定义可以得证。</p>
<p>最小的周期就是 <span class="math inline">\(s-\pi_{s}\)</span> 。</p>
<hr />
<ol type="1">
<li><p>Periodicity Lemma 周期性引理</p>
<ul>
<li><p>Weak: 若 <span class="math inline">\(p,q\)</span> 为 <span class="math inline">\(s\)</span> 的一个周期，并且 <span class="math inline">\(p+q\le n\)</span> ，那么 <span class="math inline">\(\gcd(p,q)\)</span> 也是一个周期。</p>
<details class="note info"><summary><p>证明</p>
</summary>
<p>证明：假设 <span class="math inline">\(p&gt;q\)</span> ，设 <span class="math inline">\(d=p-q\)</span> ，那么分类讨论：</p>
<ul>
<li><span class="math inline">\(i \le q\)</span> ，此时 <span class="math inline">\(s[i]=s[i+p]=s[i+p-q]=s[i+d]\)</span></li>
<li><span class="math inline">\(i&gt;q\)</span> ，此时 <span class="math inline">\(s[i]=s[i-q]=s[i+p-q]=s[i+d]\)</span></li>
</ul>
<p>注意到两种情况均可以导出 <span class="math inline">\(s[i]=s[i+d]\)</span> ，即 <span class="math inline">\(d\)</span> 也是周期。 更相减损即可得到 <span class="math inline">\(\gcd(p,q)\)</span> 是周期。 <span class="math inline">\(\square\)</span></p>
<p>回顾一下证明过程，之所以要求 <span class="math inline">\(p+q\le n\)</span> ，是在第一类中，<span class="math inline">\(s[i]=s[i+p]\)</span> 一步，如果 <span class="math inline">\(p+q&gt;n\)</span> ，就不满足周期的性质。</p>
<p>证明的核心围绕着周期的定义 <span class="math inline">\(s[i]=s[i+r]\)</span> 进行，目标是导出 <span class="math inline">\(s[i+d]\)</span> ，最后使用更相减损完成证明，巧妙。</p>

</details></li>
<li><p>Strong: 若 <span class="math inline">\(p,q\)</span> 为 <span class="math inline">\(s\)</span> 的一个周期，并且 <span class="math inline">\(p+q\le n+\gcd(p,q)\)</span> ，那么 <span class="math inline">\(\gcd(p,q)\)</span> 也是一个周期。</p>
<details class="note info"><summary><p>证明</p>
</summary>
<p>发现上面的证明此时会出现问题，因为 <span class="math inline">\(s[i+p]\)</span> 可能超过 <span class="math inline">\(n\)</span> 。</p>
<p><del>参考</del> 照搬 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84OTM4NTM2MA==">Periodicity Lemma - 知乎</span></p>
<ol type="1">
<li>按照上面的方法证明对于长度是 <span class="math inline">\(n-q\)</span> 的前缀/后缀均是循环节。因为注意到 <span class="math inline">\(\gcd(p,q)\le q\)</span> ，必然满足上述证明过程。</li>
<li>可以证明 <span class="math inline">\(q\le n-q\)</span> （这是怎么证明的呢？），所以 <span class="math inline">\(s\)</span> 的前 <span class="math inline">\(q\)</span> 个字符中，<span class="math inline">\(\gcd(p,q)\)</span> 仍然是其循环节。因为 <span class="math inline">\(\gcd(p,q)\)</span> 是 <span class="math inline">\(q\)</span> 的约数，所以前缀 <span class="math inline">\(q\)</span> 是由若干个完整的循环节拼成的。</li>
<li>因为可以将 <span class="math inline">\(s\)</span> 拆分成 <span class="math inline">\(q\)</span> 的前缀和 <span class="math inline">\(n-q\)</span> 的后缀，前缀是由若干段完整循环节构成的，而后半段也是周期。所以 <span class="math inline">\(\gcd(p,q)\)</span> 也是一个周期。</li>
</ol>
<p>这个证明过程的严谨推理仍然有待分析。</p>

</details></li>
</ul></li>
<li><p>字符串 <span class="math inline">\(s\)</span> 所有长度超过 <span class="math inline">\(\lvert s\rvert / 2\)</span> 的 border 的长度是等差数列。</p>
<details class="note info"><summary><p>证明</p>
</summary>
<p>假设有一个长度为 <span class="math inline">\(n-p\)</span> 的 border 和一个长度为 <span class="math inline">\(n-q\)</span> 的 border ，其中 <span class="math inline">\(p,q \le n/2\)</span> ，那么根据弱周期性引理，可以得到 <span class="math inline">\(\gcd(p,q)\)</span> 是一个周期，那么 <span class="math inline">\(n-\gcd(p,q)\)</span> 是一个 border。</p>

</details></li>
</ol>
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>多项式科技</title>
    <url>/posts/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%A7%91%E6%8A%80/</url>
    <content><![CDATA[<p>本文介绍了一些多项式算法。</p>
<span id="more"></span>
<h1 id="快速傅里叶变换">快速傅里叶变换</h1>
<h2 id="简单理解">简单理解</h2>
<p>快速解决多项式乘法的算法。</p>
<h2 id="从系数表示到点值表示">从系数表示到点值表示</h2>
<h3 id="系数表示法">系数表示法</h3>
<p>表示一个多项式 F(x) 有两种方法，一种是系数表示，即 <span class="math inline">\(F(x)=\sum_{i=0}^{k}a_{k}\cdot x^{k}\)</span> ，其中的 <span class="math inline">\(a_{i}\)</span> 即为次数为 <span class="math inline">\(i\)</span> 的项的系数。</p>
<p>我们计算多项式乘法， <span class="math inline">\(A(x)\times B(x)\)</span> ，记结果为 <span class="math inline">\(C\)</span> ，那么 <span class="math inline">\(C\)</span> 可以这么算： <span class="math display">\[
C[k]=\sum_{i+j=k}{A[i]B[j]}
\]</span> 其中 <span class="math inline">\(A[i]\)</span> 表示多项式 <span class="math inline">\(A(x)\)</span> 的第 <span class="math inline">\(i\)</span> 项。</p>
<p>这称为加法卷积。</p>
<blockquote>
<p>如果有 <span class="math display">\[
C[k]=\sum_{i\oplus j=k}{A[i]B[j]}
\]</span> 其中 <span class="math inline">\(\oplus\)</span> 为一种运算，那么称这个操作为卷积。</p>
</blockquote>
<p>不难发现，这样运算的复杂度为 <span class="math inline">\(O(n^2)\)</span> 的，其中 <span class="math inline">\(n\)</span> 为多项式的次数。</p>
<h3 id="点值表示法">点值表示法</h3>
<p>我们都知道，两点确定一条直线，所以如果知道两个点的坐标就可以确定一个一次函数，也能确定这个一次函数的系数。</p>
<p>有一个推论：平面上的 <span class="math inline">\(n+1\)</span> 个点可以确定一个 <span class="math inline">\(n\)</span> 次的多项式。</p>
<p>那么我们发现，如果我们给出 <span class="math inline">\(x\)</span> 坐标，那么根据多项式就可以求出 <span class="math inline">\(y\)</span> 坐标了。</p>
<p>如果对于一个多项式，我们得到了一些点值 <span class="math inline">\((x_0,A(x_0)),(x_1,A(x_1)),(x_2,A(x_2)),\cdots\)</span> ，与另一个多项式的点值 <span class="math inline">\((x_0,B(x_0)),(x_1,B(x_1)),(x_2,B(x_2)),\cdots\)</span> ，现在我们想要得到这两个多项式的乘积 <span class="math inline">\(C(x)\)</span> ，就可以知道乘积的点值表示为 <span class="math inline">\((x_0,A(x_0)\times B(x_0)),(x_1,A(x_1)\times B(x_1)),(x_2,A(x_2) \times B(x_2)),\cdots\)</span> 。也就是说，乘积多项式的点值表示可以由这两个多项式相乘得到。</p>
<p>但是有个小问题，乘积多项式最高是 2n 次的，需要 2n+1 个点，那就多带入几个点值就可以了。</p>
<p>这样计算乘法就可以在 <span class="math inline">\(O(n)\)</span> 的时间复杂度内完成。</p>
<h3 id="总结">总结</h3>
<p>如果我们能够知道如何将点值表示快速转换成系数表示，就可以快速完成多项式乘法了。</p>
<h2 id="复数前置知识">复数前置知识</h2>
<p><a href="..%20/数学基础#复数">见数学中复数部分</a></p>
<h2 id="dft">DFT</h2>
<p>将系数表达转换成点值表达。</p>
<p>由于我们可以任意代入 x 的值，为了使得性质更强，我们代入 <span class="math inline">\(\omega_{n}^{k}\)</span> 。</p>
<p>我们要同时计算代入 <span class="math inline">\(n\)</span> 个单位根的值，直接做是 <span class="math inline">\(O(n^2)\)</span> 的。</p>
<p>下面分治计算 <span class="math inline">\(F(\omega_{n}^{k})\)</span> 的值。要求 n 必须为 2 的整数次幂，如果不够就补充系数为 0 的项。</p>
<p>建立两个多项式 <span class="math inline">\(F_{odd}\)</span> 与 <span class="math inline">\(F_{even}\)</span> ，其系数分别为 <span class="math inline">\(F\)</span> 的奇数项与偶数项的系数。（定义第 i 项是第 i-1 次项）</p>
<p>那么容易发现有 <span class="math inline">\(F(x)=F_{odd}(x^2)+xF_{even}(x^2)\)</span> 。</p>
<p>对于多项式的前 n/2 项， <span class="math inline">\(0 \le k &lt; n/2\)</span> ，我们对于第 <span class="math inline">\(k\)</span> 项代入 <span class="math inline">\(x=\omega_{n}^{k}\)</span> ： <span class="math display">\[
F(\omega_{n}^{k})=F_{odd}((\omega_{n}^{k})^2)+\omega_{n}^{k}F_{even}((\omega_{n}^{k})^2)
\]</span> 对于多项式的后 n/2 项， <span class="math inline">\(0 \le k &lt; n/2\)</span> ，我们对于第 <span class="math inline">\(n/2+k\)</span> 项代入 <span class="math inline">\(x=\omega_{n}^{n/2+k}\)</span> ： <span class="math display">\[
F(\omega_{n}^{n/2+k})=F_{odd}((\omega_{n}^{n/2+k})^2)+\omega_{n}^{n/2+k}F_{even}((\omega_{n}^{n/2+k})^2)
\]</span> 这两个式子囊括了式子的所有项。</p>
<p>对于前一个式子，我们有： <span class="math display">\[
\begin{aligned}
F(\omega_{n}^{k})&amp;=F_{odd}((\omega_{n}^{k})^2)+\omega_{n}^{k}F_{even}((\omega_{n}^{k})^2)\\
&amp;=F_{odd}(\omega_{n}^{2k})+\omega_{n}^{k}F_{even}(\omega_{n}^{2k}) \\
&amp;=F_{odd}(\omega_{n/2}^{k})+\omega_{n}^{k}F_{even}(\omega_{n/2}^{k}) \\
\end{aligned}
\]</span> 对于后一个式子，我们有： <span class="math display">\[
\begin{aligned}
F(\omega_{n}^{n/2+k})&amp;=F_{odd}((\omega_{n}^{n/2+k})^2)+\omega_{n}^{n/2+k}F_{even}((\omega_{n}^{n/2+k})^2) \\
&amp;=F_{odd}(\omega_{n}^{n+2k})+\omega_{n}^{n/2+k}F_{even}(\omega_{n}^{n+2k}) \\
&amp;=F_{odd}(\omega_{n}^{2k})+\omega_{n}^{n/2+k}F_{even}(\omega_{n}^{2k})\\
&amp;=F_{odd}(\omega_{n/2}^{k})+\omega_{n}^{n/2+k}F_{even}(\omega_{n/2}^{k})\\
&amp;=F_{odd}(\omega_{n/2}^{k})-\omega_{n}^{k}F_{even}(\omega_{n/2}^{k})
\end{aligned}
\]</span> 由此可以发现两个式子中，<span class="math inline">\(F_{odd}\)</span> 与 <span class="math inline">\(F_{even}\)</span> 需要代入的 x 都是同一个值，只需要求一次。并且对于 <span class="math inline">\(F_{odd}\)</span> 与 <span class="math inline">\(F_{even}\)</span> 来说，计算它们的点值表达的过程与计算 <span class="math inline">\(F\)</span> 的本质相同，所以可以分治计算。</p>
<p>而且当多项式只有一个项时，<span class="math inline">\(\omega_{1}^{0}=1\)</span> 。所以很容易合并。</p>
<h2 id="idft">IDFT</h2>
<p>如果知道了点值表示的序列 <span class="math inline">\(G\)</span> ，如何将其转换为系数表示法。</p>
<p>此章节中 <span class="math inline">\(A(i)\)</span> 表示多项式 <span class="math inline">\(A\)</span> 第 <span class="math inline">\(i\)</span> 项的系数。</p>
<p>结论：如果有 <span class="math display">\[
G(k)=\sum_{i=0}^{n-1}(\omega_{n}^{k})^{i}F(i)
\]</span> 那么 <span class="math display">\[
n\times F(k)=\sum_{i=0}^{n-1}(\omega_{n}^{-i})^{k}G(i)
\]</span> 其实等式右边和 DFT 的过程挺像，只不过是将 <span class="math inline">\(\omega_{n}^{i}\)</span> 换成了 <span class="math inline">\(\omega_{n}^{-i}\)</span> 。</p>
<p>证明： <span class="math display">\[
\begin{aligned}
\sum_{i=0}^{n-1}(\omega_{n}^{-i})^{k}G(i)&amp;=\sum_{i=0}^{n-1}[\sum_{j=0}^{n-1}(\omega_{n}^{i})^jF(j)(\omega_{n}^{-i})^{k}] \\
&amp;=\sum_{i=0}^{n-1}[\sum_{j=0}^{n-1}\omega_{n}^{i(j-k)}F(j)]
\end{aligned}
\]</span> 其中第一步是将 G(i) 直接代入用 F 表达。</p>
<p>考虑化简这个式子。</p>
<p>考虑对于其中一个 <span class="math inline">\(j\)</span> ， <span class="math display">\[
\sum_{i=0}^{n-1}\omega_{n}^{i(j-k)}F(j)=F(j)\sum_{i=0}^{n-1}(\omega_{n}^{j-k})^{i}
\]</span> 我们记 <span class="math inline">\(a=j-k\)</span> ， <span class="math inline">\(t=\omega_{n}^{a}\)</span> ， <span class="math inline">\(s=\sum_{i=0}^{n-1}t^i\)</span></p>
<p>当 <span class="math inline">\(j = k\)</span> 时，容易发现 s=n 。</p>
<p>当 <span class="math inline">\(j \not =k\)</span> 时，有 <span class="math inline">\(ts-s=t^{n}-t^{0}\)</span> （错位相减）。即 <span class="math inline">\(s=\frac{t^{n}-t^{0}}{t-1}\)</span> ，由于 <span class="math inline">\(t^{n}=t^{0}=1\)</span> ，所以 <span class="math inline">\(s=0\)</span> 。</p>
<p>综上所述，整个式子的总和为 <span class="math inline">\(n\times F(k)\)</span> 。</p>
<p>于是，我们完成了证明，类似 DFT 的做法，我们只需要将单位根换一换，就可以完成。</p>
<details class="note info"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> doub=<span class="type">double</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3e6</span>;</span><br><span class="line"><span class="type">const</span> doub PI=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cpl</span>&#123;</span><br><span class="line">  doub x,y;</span><br><span class="line">  <span class="built_in">Cpl</span>(doub _x=<span class="number">0</span>,doub _y=<span class="number">0</span>)&#123;x=_x;y=_y;&#125;</span><br><span class="line">  Cpl <span class="keyword">operator</span>+(Cpl a)&#123;Cpl res;res.x=x+a.x;res.y=y+a.y;<span class="keyword">return</span> res;&#125;</span><br><span class="line">  Cpl <span class="keyword">operator</span>-(Cpl a)&#123;Cpl res;res.x=x-a.x;res.y=y-a.y;<span class="keyword">return</span> res;&#125;</span><br><span class="line">  Cpl <span class="keyword">operator</span>*(Cpl a)&#123;<span class="keyword">return</span> &#123;x*a.x-y*a.y,x*a.y+y*a.x&#125;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> id_all[N],tmp[N]; <span class="comment">//记录编号对应原来的第几位</span></span><br><span class="line">Cpl newg[N]; <span class="comment">//临时数组，记录合并后当前的点值表示</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(<span class="type">int</span>* id,Cpl* f,Cpl* g,<span class="type">int</span> len,<span class="type">bool</span> op)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(len==<span class="number">1</span>)&#123;g[<span class="number">0</span>]=f[id[<span class="number">0</span>]];<span class="keyword">return</span>;&#125;</span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="number">2</span>)tmp[cnt++]=id[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i+=<span class="number">2</span>)tmp[cnt++]=id[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)id[i]=tmp[i];</span><br><span class="line">  <span class="type">int</span> half=len/<span class="number">2</span>;<span class="built_in">FFT</span>(id,f,g,half,op);<span class="built_in">FFT</span>(id+half,f,g+half,half,op);</span><br><span class="line">  Cpl w_mul=&#123;<span class="built_in">cos</span>(<span class="number">2</span>*PI/len),<span class="built_in">sin</span>(<span class="number">2</span>*PI/len)*(op?<span class="number">-1</span>:<span class="number">1</span>)&#125;,w=&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">  Cpl* gl=g;Cpl* gr=g+half;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;half;++i)&#123;</span><br><span class="line">    newg[i]=gl[i]+gr[i]*w;</span><br><span class="line">    newg[i+half]=gl[i]-gr[i]*w;</span><br><span class="line">    w=w*w_mul;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)g[i]=newg[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i+=<span class="number">2</span>)tmp[i]=id[i/<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i+=<span class="number">2</span>)tmp[i]=id[i/<span class="number">2</span>+half];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)id[i]=tmp[i];</span><br><span class="line">&#125;</span><br><span class="line">Cpl G[N]; <span class="comment">//乘积多项式的系数表示</span></span><br><span class="line">Cpl Gs[<span class="number">2</span>][N]; <span class="comment">//两个原多项式的系数表示</span></span><br><span class="line">Cpl f[<span class="number">2</span>][N]; <span class="comment">//多项式的系数</span></span><br><span class="line">Cpl g[N]; <span class="comment">//得到的系数表示 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,m,orin,orim,z;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  ++n;++m;</span><br><span class="line">  orin=n;orim=m;</span><br><span class="line">  <span class="type">int</span> t;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t),f[<span class="number">0</span>][i].x=t;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t),f[<span class="number">1</span>][i].x=t;</span><br><span class="line">  z=<span class="number">1</span>&lt;&lt;(<span class="type">int</span>)(<span class="built_in">log2</span>(n+m<span class="number">-1</span>)+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;z;++i)id_all[i]=i;</span><br><span class="line">  <span class="built_in">FFT</span>(id_all,f[<span class="number">0</span>],g,z,<span class="number">0</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;z;++i)Gs[<span class="number">0</span>][i]=g[i];</span><br><span class="line">  <span class="built_in">FFT</span>(id_all,f[<span class="number">1</span>],g,z,<span class="number">0</span>);<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;z;++i)Gs[<span class="number">1</span>][i]=g[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;z;++i)G[i]=Gs[<span class="number">0</span>][i]*Gs[<span class="number">1</span>][i];</span><br><span class="line">  <span class="built_in">FFT</span>(id_all,G,g,z,<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,y=orin+orim<span class="number">-1</span>;i&lt;y;++i)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,(<span class="type">int</span>)(g[i].x/z+<span class="number">0.5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种简单的实现方式。</p>

</details>
<h2 id="优化">优化</h2>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数学基础</title>
    <url>/posts/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文介绍了OI中的一些数学基础知识。</p>
<span id="more"></span>
<h1 id="向量">向量</h1>
<h2 id="基本概念及定义">基本概念及定义</h2>
<p>见OI-Wiki，此处不再赘述。</p>
<h2 id="向量的线性运算">向量的线性运算</h2>
<h3 id="加减法">加减法</h3>
<p><strong>三角形法则</strong>：若求和的向量首尾顺次连接，那么和就为第一个向量的起点指向第二个向量的终点。</p>
<p><strong>平行四边形法则</strong>：若求和的两个向量共起点，那么和就为以这两个向量为邻边的平行四边形的对角线，起点为两个向量的共起点，方向沿对角线方向。</p>
<p><strong>减法</strong>：考虑减一个向量等价于加这个向量的相反向量。</p>
<h3 id="数乘">数乘</h3>
<p>实数 <span class="math inline">\(\lambda\)</span> 与向量 <span class="math inline">\(\boldsymbol{a}\)</span> 的积为一个向量。记作<span class="math inline">\(\lambda\boldsymbol{a}\)</span>。结果的长度与方向为：</p>
<p>长度：<span class="math inline">\(|\lambda \boldsymbol a|=|\lambda||\boldsymbol a|\)</span>。</p>
<p>方向：当 $&gt; 0 $ 时，<span class="math inline">\(\lambda \boldsymbol a\)</span> 与 <span class="math inline">\(\boldsymbol a\)</span> 同向，当 <span class="math inline">\(\lambda = 0\)</span> 时，<span class="math inline">\(\lambda \boldsymbol a=0\)</span>，当 $&lt; 0 $ 时，<span class="math inline">\(\lambda \boldsymbol a\)</span> 与 <span class="math inline">\(\boldsymbol a\)</span> 方向相反。</p>
<h4 id="判断两向量共线">判断两向量共线</h4>
<p>两个非零向量 <span class="math inline">\(\boldsymbol{a}\)</span> 与 <span class="math inline">\(\boldsymbol{b}\)</span> 共线 <span class="math inline">\(\iff\)</span> 有唯一实数 <span class="math inline">\(\lambda\)</span>， 使得 <span class="math inline">\(b = \lambda\boldsymbol{a}\)</span>。</p>
<h2 id="平面向量的基本定理">平面向量的基本定理</h2>
<p>如果两个向量 <span class="math inline">\(\boldsymbol{e_1},\boldsymbol{e_2}\)</span> 不共线，那么存在唯一实数对 <span class="math inline">\((x,y)\)</span>，使得与 <span class="math inline">\(\boldsymbol{e_1},\boldsymbol{e_2}\)</span> 共面的任意向量 <span class="math inline">\(\boldsymbol{p}\)</span> 满足 <span class="math inline">\(\boldsymbol{p}=x\boldsymbol{e_1}+y\boldsymbol{e_2}\)</span>。</p>
<p>依据这个定理，我们可以用两个<strong>不共线</strong>的向量表示所有平面向量。</p>
<p>那么在同一个平面内的两个不共线的向量称为 <strong>基底</strong> 。</p>
<p>如果基底相互垂直，那么分解的时候就是对向量 <strong>正交分解</strong> 。</p>
<h2 id="平面向量的坐标">平面向量的坐标</h2>
<h3 id="坐标的表示">坐标的表示</h3>
<p>根据平面向量的基本定理，可以得知，平面内每个向量可以被两个不共线向量唯一表示。</p>
<p>那么取与横轴和纵轴方向相同的两个单位向量 <span class="math inline">\(\boldsymbol{i},\boldsymbol{j}\)</span> 作为一组基底，平面上的所有向量与有序实数对 <span class="math inline">\((x,y)\)</span> 一一对应。</p>
<p>有序数对 <span class="math inline">\((x,y)\)</span> 与平面直角坐标系上的点一一对应，那么我们作 <span class="math inline">\(\overrightarrow{OP}=\boldsymbol{p}\)</span>，那么终点 <span class="math inline">\(P(x,y)\)</span> 也唯一确定。于是乎，平面直角坐标系之内，每一个向量都可以用有序实数对唯一表示。</p>
<h3 id="坐标的运算">坐标的运算</h3>
<p>若有向量 <span class="math inline">\(\boldsymbol{a}=(m,n)\)</span>, <span class="math inline">\(\boldsymbol{b}=(p, q)\)</span>，则： <span class="math display">\[
\boldsymbol{a}+\boldsymbol{b}=(m+p,n+q)
\\ \boldsymbol{a}-\boldsymbol{b}=(m-p,n-q)
\\ k\boldsymbol{a}=(km,kn)
\]</span></p>
<h1 id="三角函数">三角函数</h1>
<h2 id="定义">定义</h2>
<p>当平面上三点A, B, C 连成一个直角三角形时. 其中 <span class="math inline">\(∠ACB\)</span> 为直角. 对于 <span class="math inline">\(∠BAC\)</span> 而言, 邻边 AC , 斜边 AB , 对边 BC 有如下定义:</p>
<p><strong>正弦函数(sine)(sin)</strong>: <span class="math inline">\(∠A\)</span> 的对边比斜边. 即 BC/AB</p>
<p><strong>余弦函数(cosine)(cos)</strong>: <span class="math inline">\(∠A\)</span> 的邻边比斜边. 即 AC/AB</p>
<p><strong>正切函数(tangent)(tan)</strong>: <span class="math inline">\(∠A\)</span> 的对边比邻边. 即 BC/AC</p>
<p><strong>余切函数(cotangent)(cot)</strong>: <span class="math inline">\(∠A\)</span> 的邻边比对边. 即 AC/BC</p>
<p><strong>正割函数(secant)(sec)</strong>: <span class="math inline">\(∠A\)</span> 的斜边比邻边. 即 AB/AC</p>
<p><strong>余割函数(cosecant)(csc)</strong>: <span class="math inline">\(∠A\)</span> 的斜边比对边. 即 AB/BC</p>
<h1 id="复数">复数</h1>
<h2 id="引入与定义">引入与定义</h2>
<p>方程 <span class="math inline">\(x^2=-1\)</span> 在实数域没有解，为了让它有根，我们进行了数系扩张，引入了 <strong>虚数单元</strong> <span class="math inline">\(\mathrm{i}\)</span> ，规定 <span class="math inline">\(\mathrm{i}^2=-1\)</span> 。</p>
<p>让这个虚数单元与实数进行运算，得到一系列的数，进行归类，发现它们都可以写成 <span class="math inline">\(a+b\mathrm{i}(a,b\in \mathbf{R})\)</span> 的形式，我们称这些数为复数。</p>
<p>其中的 <span class="math inline">\(a\)</span> 称为实部，<span class="math inline">\(b\)</span> 称为虚部。</p>
<h2 id="性质与运算">性质与运算</h2>
<h3 id="几何意义">几何意义</h3>
<p>我们发现，复数一般形式中的 <span class="math inline">\(a,b\)</span> 可以对应平面直角坐标系中的两个坐标，那么一个复数就可以对应平面直角坐标系上的一个点。我们称表示 <span class="math inline">\(a\)</span> 的数轴为实轴，而 <span class="math inline">\(b\)</span> 对应的数轴为虚轴。</p>
<p>于是复数就与平面上的点一一对应，由于向量也与平面上的点一一对应，我们认为复数 <span class="math inline">\((a,b)\)</span> 与向量 <span class="math inline">\(\overrightarrow{OZ}=(a,b)\)</span> 对应。</p>
<p><strong>复数模长</strong>：一个复数所对应的向量的模长。</p>
<h3 id="运算">运算</h3>
<p><strong>复数相等</strong>：如果两个复数 <span class="math inline">\(a+b\mathrm{i}\)</span> 和 <span class="math inline">\(c+d\mathrm{i}\)</span> 相等，当且仅当 <span class="math inline">\(a=c,b=d\)</span> 。</p>
<p><strong>复数加法</strong>：实部相加，虚部相加。</p>
<p><strong>复数减法</strong>：减法是加法的逆运算，类似于实数的运算法则，减去一个复数等于加上这个复数的相反数。</p>
<p><strong>复数乘法</strong>：直接展开即可。注意到 <span class="math inline">\(\mathrm{i}^2=-1\)</span> 。</p>
<p><strong>共轭复数</strong>：<span class="math inline">\(a+b\mathrm{i}\)</span> 与 <span class="math inline">\(a-b\mathrm{i}\)</span> 互为共轭复数，它们的乘积 <span class="math inline">\((a+b\mathrm{i})(a-b\mathrm{i})=a^2+b^2\)</span> 是一个实数。复数 <span class="math inline">\(z\)</span> 的共轭复数记作 <span class="math inline">\(\overline{z}\)</span></p>
<p><strong>复数除法</strong>：类似于多项式除法的化简，利用共轭复数实现分母实化。例如： <span class="math display">\[
\begin{aligned}
\frac{a+b\mathrm{i}}{c+d\mathrm{i}} &amp; = \frac{(a+b\mathrm{i})(c-d\mathrm{i})}{c^2+d^2} \\
&amp; = \frac{ac+bd+bci-adi}{c^2+d^2} \\
&amp; = \frac{ac+bd}{c^2+d^2}+\frac{bc-ad}{c^2+d^2}
\end{aligned}
\]</span></p>
<h3 id="辐角与单位圆">辐角与单位圆</h3>
<p>规定实数单位 1 作为水平正方向，虚数单位 <span class="math inline">\(\mathrm{i}\)</span> 作为竖直正方向，那么一个非零复数 <span class="math inline">\(z=x+y\mathrm{i}\)</span> 的 <strong>辐角<span class="math inline">\(\theta\)</span></strong> 定义为满足 <span class="math inline">\(\tan{\theta}=\frac{y}{x}\)</span> ，记作 <span class="math inline">\(\operatorname{Arg}z\)</span> 。其中满足 <span class="math inline">\(-\pi&lt;\theta\le\pi\)</span> 的辐角称为 <strong>辐角主值</strong> ，记作 <span class="math inline">\(\operatorname{arg}z\)</span> 。</p>
<p>称模长小于 1 的复数组成的图形为 <strong>单位圆</strong> ，称模等于 1 的复数称为 <strong>单位复数</strong> ，全体单位复数构成的图形称为 <strong>单位圆周</strong> 。</p>
<p>在不引起混淆的情况下单位圆周有时也称为单位圆。</p>
<p>我们可以发现，此时的复数的乘除法有了另一种计算方式。</p>
<p>复数乘法：辐角相加，模长相乘。</p>
<p>复数除法：辐角相减，模长相除。</p>
<blockquote>
<p>证明</p>
<ul>
<li><p>若有两个复数 <span class="math inline">\(z_1=a+b\mathrm{i}\)</span> 和 <span class="math inline">\(z_2=c+d\mathrm{i}\)</span> ，那么相乘的模长： <span class="math display">\[
\begin{aligned}
|z_1|\times |z_2|&amp;=\sqrt{a^2+b^2}\times \sqrt{c^2+d^2}\\
&amp;=\sqrt{(a^2+b^2) (c^2+d^2)}
\end{aligned}
\]</span> 而它们乘积的模长 <span class="math display">\[
\begin{aligned}
|z_1z_2|&amp;=|(ac-bd)+(ad+bc)\mathrm{i}| \\
&amp;=\sqrt{(ac-bd)^2+(ad+bc)^2} \\
&amp;=\sqrt{a^2c^2+b^2d^2+a^2d^2+b^2c^2-2acbd+2adbc} \\
&amp;=\sqrt{a^2c^2+b^2d^2+a^2d^2+b^2c^2} \\
&amp;=\sqrt{(a^2+b^2)(c^2+d^2)}
\end{aligned}
\]</span> 至此我们证明了模长乘积相等。</p></li>
<li><p>下面证明辐角相加相等：</p>
<p>令图中点 (1,0) 为点 <span class="math inline">\(I\)</span>。</p>
<p>考虑证明图中的三角形ABO和三角形CIO相似。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/61434.png" /></p>
<p>由于刚刚证明的模长关系，可以知道 <span class="math inline">\(OA=OB\times OC\)</span> ，可以得到一个等积式。如果能够再得到 <span class="math inline">\(AB:IC=OB:OI\)</span> ，即 <span class="math inline">\(IC^2 \times OB^2=AB^2\)</span> 即可。</p>
<p>一顿展开应该可以证明。</p>
<p>如此，那么 ∠OIC=∠BOA ，故，∠OIC+∠IOB=∠IOA</p></li>
</ul>
</blockquote>
<h2 id="单位根">单位根</h2>
<h3 id="定义-1">定义</h3>
<p><span class="math inline">\(x^{n}=1\)</span> 的复数解。</p>
<p>比较显然，解 <span class="math inline">\(x\)</span> 的模长必定为1.</p>
<p>于是我们在单位圆上考虑单位根。</p>
<p>考虑到复数乘法可以用辐角相加，<span class="math inline">\(x^{n}\)</span> 的辐角就等于 <span class="math inline">\(x\)</span> 的辐角的 <span class="math inline">\(n\)</span> 倍。很显然，只有当 <span class="math inline">\(x\)</span> 辐角为 <span class="math inline">\(\frac{1}{n}\)</span> 圆周的倍数的时候，<span class="math inline">\(x^n\)</span> 的辐角才能落在 <span class="math inline">\(x\)</span> 轴上。</p>
<p>所以 n 次单位根落在 <span class="math inline">\(0,\frac{1}{n},\frac{2}{n},\cdots,,\frac{n-1}{n}\)</span> 圆周上，共有 <span class="math inline">\(n\)</span> 个。</p>
<p>所以 <span class="math inline">\(n\)</span> 次单位根 <span class="math inline">\(n\)</span> 等分单位圆。</p>
<p>按照逆时针顺序将这些单位根，记作 <span class="math inline">\(\omega_{n}^{i}\)</span> ，其中 <span class="math inline">\(i\in [0,n-1],i\in \mathbb{Z}\)</span> 。</p>
<h3 id="性质">性质</h3>
<ol type="1">
<li><span class="math inline">\(\omega_{n}^{k}=(\omega_{n}^{1})^k\)</span> ，显然</li>
<li><span class="math inline">\(\omega_{n}^{j}+\omega_{n}^{k}=\omega_{n}^{j+k}\)</span> ，显然</li>
<li><span class="math inline">\(\omega_{2n}^{2k}=\omega_{n}^{k}\)</span> ，将一个圆等分成 <span class="math inline">\(2n\)</span> 份取第 <span class="math inline">\(2k\)</span> 份，与直接分成 <span class="math inline">\(n\)</span> 份取 <span class="math inline">\(k\)</span> 份，是一样的。</li>
<li>若 <span class="math inline">\(n\)</span> 为偶数，那么 <span class="math inline">\(\omega_{n}^{k+n/2}=-\omega_{n}^{k}\)</span> 。从 <span class="math inline">\(\omega_{n}{k}\)</span> 出发旋转半个圆周，就是关于原点对称，那么坐标互为相反数。</li>
</ol>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数论函数</title>
    <url>/posts/%E6%95%B0%E8%AE%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>本文简单介绍了数论函数与莫比乌斯反演。</p>
<span id="more"></span>
<h1 id="数论函数与积性函数">数论函数与积性函数</h1>
<h2 id="数论函数">数论函数</h2>
<p>定义域为整数集，陪域为复数集的函数。</p>
<h3 id="狄利克雷函数">狄利克雷函数</h3>
<p>定义两个函数 <span class="math inline">\(f(n)\)</span> 和 <span class="math inline">\(g(n)\)</span> 的狄利克雷函数为 <span class="math inline">\((f*g)(n)=\sum_{d\vert n}f(d)g(\frac{n}{d})\)</span> 。</p>
<details class="note info"><summary><p>如何求狄利克雷卷积？</p>
</summary>
<h4 id="最朴素的暴力">最朴素的暴力</h4>
<p>枚举 <span class="math inline">\([1,n]\)</span> 范围内的每一个数，直接判断其是否为 <span class="math inline">\(n\)</span> 的约数。复杂度 <span class="math inline">\(O(n^2)\)</span>。</p>
<h4 id="稍好的暴力">稍好的暴力</h4>
<p>我们知道，枚举约数不是这样枚举的。直接枚举到 <span class="math inline">\(\sqrt{n}\)</span> 即可。复杂度 <span class="math inline">\(O(n\sqrt{n})\)</span>。</p>
<h4 id="优美的做法">优美的做法</h4>
<p>我们考虑换一个角度，枚举 <span class="math inline">\(d\)</span> ，考虑贡献到 <span class="math inline">\(d\)</span> 的倍数。因为调和级数，所以复杂度是 <span class="math inline">\(O(n\ln{n})\)</span> 的。</p>

</details>
<h3 id="其它数论函数">其它数论函数</h3>
<p><span class="math inline">\(I(n)\)</span> 是一个值恒等于 1 的函数，称为恒等函数。</p>
<p><span class="math inline">\(\epsilon(n)\)</span>，也被称作 <span class="math inline">\(e(n)\)</span>，又被称为 <strong>元函数</strong> ，因为它是卷积的单位元，<span class="math inline">\(\epsilon*f=f\)</span> 。</p>
<p><span class="math inline">\(id(n)=n\)</span>，被称作单位函数。</p>
<h2 id="积性函数">积性函数</h2>
<h3 id="定义">定义</h3>
<ul>
<li>积性函数：如果对于所有 <span class="math inline">\(\gcd(a,b)=1\)</span>，有 <span class="math inline">\(f(a)f(b)=f(ab)\)</span> ，那么 <span class="math inline">\(f\)</span> 是积性函数。</li>
<li>完全积性函数：如果有 <span class="math inline">\(f(a)f(b)=f(ab)\)</span> ，那么 <span class="math inline">\(f\)</span> 是完全积性函数。</li>
</ul>
<h3 id="性质">性质</h3>
<ol type="1">
<li><p>对于积性函数 <span class="math inline">\(f\)</span> ，有 <span class="math inline">\(f(1)=1\)</span> 。</p>
<p>略证：<span class="math inline">\(f(1)=f(1)f(1)\)</span> ，得到 <span class="math inline">\(f(1)=1\)</span>。</p></li>
<li><p>若 <span class="math inline">\(x=\prod_{i=1}^{m}p_{i}^{q_{i}}\)</span>，则 <span class="math inline">\(f(x)=\prod_{i=1}^{m}f(p_{i}^{q_{i}})\)</span>。</p>
<p>根据积性函数的定义可以得到。</p></li>
<li><p>两积性函数 <span class="math inline">\(F_{1}(n)\)</span> 与 <span class="math inline">\(F_{2}(n)\)</span> 的狄利克雷卷积 <span class="math inline">\(G(n)=\sum_{d\vert n}F_{1}(n)\times F_{2}(\frac{n}{d})\)</span> 也为积性函数。</p>
<details class="note info"><summary><p>证明</p>
</summary>
<p>假设 <span class="math inline">\(a,b\)</span> 互质， <span class="math display">\[
\begin{aligned}
G(a)*G(b)&amp;=\sum_{d\vert a}F_{1}(d)F_{2}(\frac{a}{d})*\sum_{t\vert b}F_{1}(t)F_{2}(\frac{b}{t}) \\
&amp;=\sum_{d\vert a}\sum_{t\vert b}F_{1}(d)F_{1}(t)F_{2}(\frac{a}{d})F_{2}(\frac{b}{t})
\end{aligned}
\]</span> 由于 <span class="math inline">\(\gcd(a,b)=1\)</span> ，所以它们的约数 <span class="math inline">\(\gcd(d,t)=1\)</span> ，<span class="math inline">\(\gcd(\frac{a}{d},\frac{b}{t})=1\)</span> 。</p>
<p>所以有 <span class="math display">\[
\begin{aligned}
=&amp;\sum_{d\vert a}\sum_{t\vert b}F_{1}(dt)F_{2}(\frac{ab}{dt})\\
=&amp;\sum_{dt\vert ab}F_{1}(dt)F_{2}(\frac{ab}{dt})\\
=&amp;G(ab)
\end{aligned}
\]</span></p>

</details></li>
<li><p>积性函数的逆也是积性函数</p>
<p>还不不知道什么是逆。</p></li>
<li><p><span class="math inline">\(\epsilon=g*f\)</span> 时，<span class="math inline">\(g\)</span> 和 <span class="math inline">\(f\)</span> 互逆。</p>
<p>类比逆元理解。具体证明的话，参见 <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL2Jsb2cvY29tbWFuZC1ibG9jay9tdS1iaS13dS1zaS1mYW4teWFuLWppLWppLXlpbmcteW9uZw==">Command-Block 大佬的博客</span>。</p></li>
</ol>
<h1 id="莫比乌斯反演">莫比乌斯反演</h1>
<p>如果我们知道从 <span class="math inline">\(f\)</span> 到 <span class="math inline">\(g\)</span> 的关系式，这一过程称作变换；从此出发，推出了 <span class="math inline">\(g\)</span> 到 <span class="math inline">\(f\)</span> 的关系式，这一过程就叫作 <strong>反演</strong> ，也叫逆变换。</p>
<h2 id="莫比乌斯函数">莫比乌斯函数</h2>
<p>定义 <span class="math inline">\(\mu\)</span> 为莫比乌斯函数，定义为：</p>
<p>唯一分解 <span class="math inline">\(n\)</span> ，<span class="math inline">\(n=\prod_{i=1}^{k}p_{i}^{q_{i}}\)</span> <span class="math display">\[
\mu(n)=
\begin{cases}
1&amp;n=1\\
(-1)^k&amp;\max(q_{i})=1\\
0&amp;\max(q_{i})&gt;1\\
\end{cases}
\]</span></p>
<details class="note info"><summary><p>起源</p>
</summary>
<p>莫比乌斯函数的本质是 <span class="math inline">\(\mu\)</span>。</p>
<p>假设我们不知道任何关于这个函数的信息，我们考虑如何得到这个函数的表达式。</p>
<blockquote>
<p>小技巧：研究一个积性函数，<strong>先研究其在质数的幂时的表现</strong>。</p>
</blockquote>
<p>考虑当 <span class="math inline">\(n=1\)</span> 时，<span class="math inline">\(e(1)=I(1)\times 1\)</span>，所以 <span class="math inline">\(\mu(1)=1\)</span>。</p>
<p>接下来呢？积性函数在 <span class="math inline">\(n\)</span> 为质数的时候比较特殊，所以我们来研究这个函数在质数时的表现。</p>
<p>假设 <span class="math inline">\(p\)</span> 为一个质数，由于 <span class="math inline">\(e(p)=I(p)\mu(1)+I(1)\mu(p)\)</span>，由于 <span class="math inline">\(I(p)\mu(1)=1\)</span>，<span class="math inline">\(e(p)=0\)</span>，所以 <span class="math inline">\(I(1)\mu(p)\)</span> 为-1，又因为 <span class="math inline">\(I(1)=1\)</span>，所以 <span class="math inline">\(\mu(p)=-1\)</span>。</p>
<p>接下来研究 <span class="math inline">\(n\)</span> 为质数的幂时，这个函数的表现。</p>
<p><span class="math inline">\(e(p^{k})=I(p^{k})\mu(1)+I(p^{k-1})\mu(p)+\cdots+I(1)\mu(p^{k})\)</span>，即</p>
<p><span class="math inline">\(e(p^{k})=\mu(1)+\mu(p)+\cdots+\mu(p^{k})\)</span>，由于刚刚推导出 <span class="math inline">\(\mu(1)=1\)</span>，<span class="math inline">\(\mu(p)=-1\)</span>，且 <span class="math inline">\(e(p^{k})=0\)</span>，所以 <span class="math inline">\(\mu(p^{2})+\mu(p^{3})+\cdots+\mu(p^{k})=0\)</span>。</p>
<p>容易发现并证明 <span class="math inline">\(\mu(p^{k})\)</span> 在 <span class="math inline">\(k\ge 2\)</span> 时都为0。</p>
<p>如果 <span class="math inline">\(n\)</span> 唯一分解后，<span class="math inline">\(n=\prod_{i=1}^{k}p_{i}^{q_{i}}\)</span>，那么 <span class="math inline">\(\mu(n)=\prod_{i=1}^{k}\mu(p_{i}^{q_{i}})\)</span>。</p>
<p>最高的指数大于1，那么就会有一项为 <span class="math inline">\(0\)</span>，乘积就是0。</p>
<p>否则，相当于每一次乘上一个 -1，得到的结果自然就是 <span class="math inline">\((-1)^{k}\)</span> 了。</p>

</details>
<h3 id="性质-1">性质</h3>
<ol type="1">
<li><p>这是一个积性函数。</p>
<details class="note info"><summary><p>证明</p>
</summary>
<p>假设 <span class="math inline">\(\gcd(a,b)=1\)</span> 。</p>
<p>如果 <span class="math inline">\(a,b\)</span> 中的一个为 1，那么显然成立。</p>
<p>如果 <span class="math inline">\(a,b\)</span> 中的一个具有平方因子，那么乘积中必定具有平方因子。</p>
<p>如果 <span class="math inline">\(a,b\)</span> 中两者都不具有平方因子且都不为 1，又因为两者 <span class="math inline">\(\gcd\)</span> 为 1，所以乘积的本质不同质因子个数，等于两者本质不同的质因子个数相加。</p>

</details></li>
<li><p><span class="math display">\[
\sum_{d\mid n}\mu(d)=
\begin{cases}
1&amp;n=1\\
0&amp;n\neq 1\\
\end{cases}
=\epsilon(n)
\]</span></p>
<p>按照刚刚逆的定义，可以发现，<span class="math inline">\(\mu\)</span> 是 <span class="math inline">\(I\)</span> 的逆。</p>
<details class="note info"><summary><p>证明</p>
</summary>
<p>首先 <span class="math inline">\(n=1\)</span> 时根据定义可以得到。</p>
<p><span class="math inline">\(n\not =1\)</span> 时，将 <span class="math inline">\(n\)</span> 进行唯一分解。一个约数 <span class="math inline">\(d\)</span> 相当于在 <span class="math inline">\(n\)</span> 的质因子中选择若干。</p>
<ul>
<li><p>如果选择出的存在次数大于等于2的，<span class="math inline">\(\mu(d)=0\)</span> 。</p></li>
<li><p>否则，选出的次数均为1次。假设总共有 <span class="math inline">\(m\)</span> 个本质不同质因子，选择了 <span class="math inline">\(k\)</span> 个质因子，那么总贡献就是： <span class="math display">\[
\sum_{i=0}^{m}(-1)^{i}\binom{m}{i}
\]</span> 注意到这个式子和二项式定理相似。 <span class="math display">\[
[1+(-1)]^{m}=\sum_{i=1}^{m}1^{(n-i)}(-1)^i\binom{m}{i}
\]</span> Q.E.D.</p></li>
</ul>

</details></li>
<li><p><span class="math display">\[
[\gcd(a,b)=1]=\sum_{d\vert \gcd(a,b)}\mu(d)
\]</span></p>
<p>根据性质2可以得出。</p></li>
</ol>
<h2 id="莫比乌斯变换与反演">莫比乌斯变换与反演</h2>
<p>设 <span class="math inline">\(f\)</span> 与 <span class="math inline">\(g\)</span> 为两个数论函数，如果有： <span class="math display">\[
f(n)=\sum_{d\vert n}g(d)
\]</span> 那么 <span class="math inline">\(g(n)=\sum_{d\vert n}f(\frac{n}{d})\mu(d)\)</span> ，这是一个狄利克雷卷积的形式。</p>
<details class="note info"><summary><p>推理？</p>
</summary>
<p>下面的图片展示了如何手动反演找规律。</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/pfv2639c.png" alt="举例反演过程" /><figcaption aria-hidden="true">举例反演过程</figcaption>
</figure>

</details>
<details class="note info"><summary><p>证明</p>
</summary>
<p>想要证明 <span class="math inline">\(g(n)=\sum_{d\vert n}\mu(d)f(\frac{n}{d})\)</span> 。</p>
<p>按照证明反演的套路，我们将 <span class="math inline">\(f\)</span> 换成 <span class="math inline">\(g\)</span> ，就得到了： <span class="math display">\[
\sum_{d\vert n}\mu(d)\sum_{t\vert \frac{n}{d}}g(t)
\]</span> 观察这个式子，<span class="math inline">\(d\times t\)</span> 仍然是 <span class="math inline">\(n\)</span> 的约数。</p>
<p>这个式子相当于对于每一个质因数，决定是乘入 <span class="math inline">\(d\)</span> ，还是 <span class="math inline">\(t\)</span> ，亦或是两者都不乘。</p>
<p>而且 <span class="math inline">\(\mu\)</span> 的取值只与 <span class="math inline">\(d\)</span> 有关，<span class="math inline">\(g\)</span> 的取值只与 <span class="math inline">\(t\)</span> 有关。</p>
<p>所以我们发现先枚举 <span class="math inline">\(d\)</span> 还是先枚举 <span class="math inline">\(t\)</span> 对枚举的结果没有影响。</p>
<p>所以可以交换求和号。 <span class="math display">\[
\sum_{t\vert n}g(t)\sum_{d\vert \frac{n}{t}}\mu(d)
\]</span> 其中，<span class="math inline">\(\sum_{d\vert \frac{n}{t}}\mu(\frac{n}{d})=[\frac{n}{d}=1]\)</span> ，仅在 <span class="math inline">\(d=n\)</span> 时，该式为 1；</p>
<p>仅当 <span class="math inline">\(t\)</span> 为 <span class="math inline">\(n\)</span> 时，<span class="math inline">\(d\)</span> 能取到 <span class="math inline">\(n\)</span> ，所以该式等于 <span class="math inline">\(g(n)\)</span> 。<span class="math inline">\(\square\)</span></p>

</details>
<p>我们发现 <span class="math inline">\(f\)</span> 函数是 <span class="math inline">\(g\)</span> 函数与 <span class="math inline">\(I\)</span> 的狄利克雷卷积形式，即 <span class="math inline">\(f=gI\)</span>，那么可以得到 <span class="math inline">\(g=fI^{-1}=f\mu\)</span>。所以有了上面的式子。</p>
<h3 id="其它形式">其它形式</h3>
<p>莫比乌斯反演具有几种形式：</p>
<h4 id="约数式">约数式</h4>
<p><span class="math display">\[
g(n)=\sum_{d\vert n}f(d)\Rightarrow f(n)=\sum_{d\vert n}g(d)\mu(\frac{d}{n})
\]</span></p>
<h4 id="倍数式">倍数式</h4>
<p><span class="math display">\[
g(n)=\sum_{n\vert d}f(d)\Rightarrow f(n)=\sum_{n\vert d}\mu(\frac{d}{n})g(d)
\]</span></p>
<h2 id="例题">例题</h2>
<h3 id="p3455-poi2007-zap-queries"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM0NTU=">P3455 [POI2007] ZAP-Queries</span></h3>
<h4 id="题意">题意</h4>
<p><span class="math inline">\(n(1\le n\le 5\times 10^{4})\)</span> 次询问，每次给定 <span class="math inline">\(a,b,c\)</span> 满足 <span class="math inline">\(1\le d\le a,b\le 5\times 10^{4}\)</span>。求满足 <span class="math inline">\(\gcd(x,y)=d\)</span>，其中 <span class="math inline">\(1\le x\le a,1\le y\le b\)</span> 的二元组 <span class="math inline">\((x,y)\)</span> 数量。</p>
<details class="note info"><summary><p>解法</p>
</summary>
<p>首先我们可以将 <span class="math inline">\(d\)</span> 的限制去掉。</p>
<p>具体地，这题相当于是要求 <span class="math inline">\(\gcd(x,y)=1\)</span>，其中 <span class="math inline">\(1\le x\le \frac{a}{d}\)</span> 且 <span class="math inline">\(q\le y\le \frac{b}{d}\)</span> 的个数，因为这样的二元组 <span class="math inline">\((x,y)\)</span> 同时乘上 <span class="math inline">\(d\)</span> 之后得到的二元组 <span class="math inline">\((xd,yd)\)</span> 的 gcd 为 <span class="math inline">\(d\)</span>。</p>
<p>接下来考虑如何解决 <span class="math inline">\(\gcd(x,y)=1\)</span> 的问题。为了方便，我们记 <span class="math inline">\(\gcd(a,b)\)</span> 为 <span class="math inline">\((a,b)\)</span>，记 <span class="math inline">\(a\)</span> 为原来的 <span class="math inline">\(a\)</span> 除以 <span class="math inline">\(d\)</span> 向下取整的结果，<span class="math inline">\(b\)</span> 同理，并令 <span class="math inline">\(a\ge b\)</span>。</p>
<p>由于 <span class="math inline">\([\gcd(x,y)=1]=\sum_{d\vert (x,y)}\mu(x,y)\)</span>，这可以根据 <a href="#性质">上面提到的性质</a> 得到。</p>
<p><span class="math inline">\(\sum_{d\vert (x,y)}\mu(x,y)=\sum_{d\vert x,d\vert y}\mu(x,y)\)</span>，因为 <span class="math inline">\(d\)</span> 是 <span class="math inline">\((x,y)\)</span> 的约数的充要条件是 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(d\)</span> 的倍数且 <span class="math inline">\(y\)</span> 是 <span class="math inline">\(d\)</span> 的倍数。 <span class="math display">\[
\sum_{x=1}^{a}\sum_{y=1}^{b}\sum_{d\vert x,d\vert y}\mu(x,y)
\]</span> 我们发现其实有一些 <span class="math inline">\(x,y\)</span> 的 <span class="math inline">\(\gcd\)</span> 是相同的，我们考虑将它们一起计算。</p>
<p>于是我们交换求和号，用我们 OI 的话来说，就是先枚举 <span class="math inline">\(d\)</span>。那么有多少 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(d\)</span> 的倍数呢？显然是 <span class="math inline">\(\lfloor \frac{a}{d}\rfloor\)</span> 了。那么有多少 <span class="math inline">\(y\)</span> 是 <span class="math inline">\(d\)</span> 的倍数呢？显然是 <span class="math inline">\(\lfloor \frac{b}{d}\rfloor\)</span> 了。那么有多少 <span class="math inline">\(x,y\)</span> 都是 <span class="math inline">\(d\)</span> 的倍数呢？显然是 <span class="math inline">\(\lfloor \frac{a}{d}\rfloor \lfloor \frac{b}{d}\rfloor\)</span> 个了。</p>
<p>于是： <span class="math display">\[
\sum_{d=1}^{b}\mu(d)\lfloor \frac{a}{d}\rfloor \lfloor \frac{b}{d}\rfloor
\]</span> 这样子可以做到 <span class="math inline">\(O(b)\)</span> 计算。</p>
<p>我们可以预处理 <span class="math inline">\(\mu\)</span> 并使用 <a href="..\整除分块">整除分块</a> 技巧来在 <span class="math inline">\(O(\sqrt{b})\)</span> 的复杂度内完成计算。</p>
<details class="note success">
<summary>
<p>
代码
</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> mu[N],sMu[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> pri[N],priTot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">5e4</span>;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[i])&#123;pri[++priTot]=i;mu[i]=<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=priTot;++j)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i*pri[j]&gt;<span class="number">5e4</span>)<span class="keyword">break</span>;</span><br><span class="line">      vis[i*pri[j]]=<span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span>(i%pri[j]==<span class="number">0</span>)&#123;mu[i*pri[j]]=<span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">      mu[i*pri[j]]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5e4</span>;++i)sMu[i]=sMu[i<span class="number">-1</span>]+mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;y)<span class="built_in">swap</span>(x,y);</span><br><span class="line">  <span class="type">int</span> l=<span class="number">1</span>,r;</span><br><span class="line">  <span class="keyword">while</span>(l&lt;=y)&#123;</span><br><span class="line">    r=<span class="built_in">min</span>(x/(x/l),y/(y/l));</span><br><span class="line">    ans+=<span class="number">1ll</span>*(sMu[r]-sMu[l<span class="number">-1</span>])*(x/l)*(y/l);</span><br><span class="line">    l=r+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">init</span>();</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,a,b,d;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">solve</span>(a/d,b/d));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

</details>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>整除分块</title>
    <url>/posts/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<p>整除分块用于解决一类与 <span class="math inline">\(\lfloor \frac{k}{i}\rfloor\)</span> 相关的问题。</p>
<span id="more"></span>
<p>这里面的 <span class="math inline">\(k\)</span> 是常量。往往这一类问题，因为事实上 <span class="math inline">\(\lfloor \frac{k}{i}\rfloor\)</span> 的取值少于 <span class="math inline">\(k\)</span> 个，具体地，取值仅有 <span class="math inline">\(O(\sqrt{k})\)</span> 个！所以我们可以大大缩短我们计算的时间。</p>
<h1 id="一维整除分块">一维整除分块</h1>
<h2 id="简单介绍">简单介绍</h2>
<p>一维整除分块解决这样的问题：<span class="math inline">\(\sum_{i=1}^{n}\lfloor\frac{n}{i}\rfloor\)</span> 的值。</p>
<p>我们可以想到：<span class="math inline">\(\lfloor \frac{n}{i}\rfloor\)</span> 的取值并不会太多，事实上，取值数量不会超过 <span class="math inline">\(O(\sqrt{n})\)</span> 个。</p>
<details class="note info"><summary><p>证明</p>
</summary>
<ol type="1">
<li>当 <span class="math inline">\(i\le \sqrt{n}\)</span> 的时候，显然 <span class="math inline">\(\lfloor \frac{n}{i}\rfloor\)</span> 的取值不会超过 <span class="math inline">\(\sqrt{n}\)</span> 个。</li>
<li>当 <span class="math inline">\(i&gt;\sqrt{n}\)</span> 的时候，有 <span class="math inline">\(\frac{n}{i}\le \sqrt{n}\)</span>，所以 <span class="math inline">\(\lfloor \frac{n}{i}\rfloor\)</span> 的取值也不会超过 <span class="math inline">\(\sqrt{n}\)</span> 个。</li>
</ol>

</details>
<p>所以我们只需要考虑找到这 <span class="math inline">\(O(\sqrt{n})\)</span> 种取值，并确定每一种取值有多少个即可。</p>
<p>如何求每一种取值有多少呢？我们容易发现：取同一个值的 <span class="math inline">\(i\)</span> 必然是连续的。并且取的值必然是递减的。</p>
<p>所以它们事实上形成了一个类似于块状的结构，所以我们考虑求出每一个块的左右端点，就可以知道它们的长度了。</p>
<p>假设左端点为 <span class="math inline">\(i\)</span>，有结论：右端点为 <span class="math inline">\(\lfloor\frac{n}{\lfloor\frac{n}{i}\rfloor}\rfloor\)</span>。</p>
<details class="note info"><summary><p>证明</p>
</summary>
<p>设 <span class="math inline">\(k=\lfloor \frac{n}{i}\rfloor\)</span>，那么显然有 <span class="math inline">\(k\le \frac{n}{i}\)</span>。</p>
<p>于是有 <span class="math inline">\(\lfloor\frac{n}{k}\rfloor\ge \lfloor\frac{n}{\frac{n}{i}}\rfloor=\lfloor i\rfloor=i\)</span>。</p>
<p>当取等号的时候，即 <span class="math inline">\(i\)</span> 等于 <span class="math inline">\(\lfloor \frac{n}{k}\rfloor\)</span> 的时候，<span class="math inline">\(i\)</span> 是可能的最大的 <span class="math inline">\(i\)</span>。</p>

</details>
<p>于是我们就可以按照当前的左端点找到右端点，右端点加一得到下一段的左端点，便可以在 <span class="math inline">\(O(\sqrt{n})\)</span> 的时间内完成这项任务。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly92anVkZ2UubmV0L3Byb2JsZW0vVVZBLTExNTI2">板题</span></p>
<h2 id="数论分块">数论分块</h2>
<p>进一步地，我们可以解决这样的问题： <span class="math display">\[
\sum_{i=1}^{n}f(i)\lfloor\frac{n}{i}\rfloor
\]</span> 我们如果求得了 <span class="math inline">\(f\)</span> 的前缀和，记为 <span class="math inline">\(s\)</span>，我们就可以在 <span class="math inline">\(O(\sqrt{n})\)</span> 的时间内解决这个问题。</p>
<p>具体地，我们发现对于 <span class="math inline">\(\lfloor\frac{n}{i}\rfloor\)</span> 相等的一段区间 <span class="math inline">\([l,r]\)</span>，我们可以得到它们的答案为 <span class="math inline">\((s_r-s_{l-1})\lfloor\frac{n}{i}\rfloor\)</span>。</p>
<h1 id="n维整除分块">n维整除分块</h1>
<p>求 <span class="math inline">\(\sum_{i=1}^{n}\prod_{j=1}^{k}\lfloor\frac{n_{j}}{i}\rfloor\)</span>，也就是将求和的内容换成若干个可以整除分块的东西罢了。</p>
<figure>
<img src="https://oi-wiki.org/math/number-theory/images/n-dimension-sqrt-decomposition.png" alt="高维数论分块的示意图 图源:oi-wiki.org" /><figcaption aria-hidden="true">高维数论分块的示意图 图源:oi-wiki.org</figcaption>
</figure>
<p>不同颜色的线表示每一种颜色分出的段，蓝色线的意义如图所示，所以每一段中的乘积是相同的。</p>
<p>常用的是二维的数论分块，我们只需将 <code>r=n/(n/l)</code> 替换成 <code>r=min(n/(n/l),m/(m/l))</code> 即可。</p>
<p>容易发现，这样最多分出的段数仍然是 <span class="math inline">\(O(\sqrt{n})\)</span> 级别的。</p>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题总结</title>
    <url>/posts/%E6%9D%82%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>做过的一些杂题的总结。</p>
<span id="more"></span>
<h1 id="luogu-p2824-排序"><span class="exturl" data-url="aHR0cHM6Ly92anVkZ2UubmV0L3Byb2JsZW0v5rSb6LC3LVAyODI0">Luogu-P2824 排序</span></h1>
<h2 id="solution">Solution</h2>
<p>观察可以发现我们最后只需要知道位置 q 上的值即可。但是如果暴力做是 n 方级别的。</p>
<p>可以二分最后位置上 q 是多少，那么将排列中小于 q 的值设为 0 ，大于等于 q 的设为 1 。此时就将升序降序排序转换成了区间覆盖问题。</p>
<h1 id="cf149d---coloring-brackets"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vMTQ5L0Q=">CF149D - Coloring Brackets</span></h1>
<h2 id="题意">题意</h2>
<p>给出一个合法括号序列，要求给 <strong>其中一些</strong> 括号染上 <code>Red / Blue</code> 两种颜色之一，满足</p>
<ol type="1">
<li>每一对括号中恰好一个染色了。</li>
<li>相邻的两个括号不能同色，可以都不染色。</li>
</ol>
<p>求染色方案数。<span class="math inline">\(\lvert S \rvert \le 700\)</span> 。</p>
<h2 id="解法">解法</h2>
<p>我太菜了，绿的区间DP都不会了。</p>
<p>可以设 <span class="math inline">\(f[l][r]\)</span> 表示染色在 <span class="math inline">\([l,r]\)</span> 中的括号的方案数，要求 <span class="math inline">\(s[l,r]\)</span> 是合法括号序列。但是由于染色的限制条件，这样设计状态难以转移。</p>
<p>我们发现当合并两个区间时，我们只需要考虑左右两端的颜色。所以可以增加两维，表示左右两端染了什么颜色。</p>
<p>转移时考虑与 <span class="math inline">\(l\)</span> 匹配的右括号在哪。</p>
<p>如果恰好是 <span class="math inline">\(r\)</span> ，那么就可以从 <span class="math inline">\(f[l+1][r-1]\)</span> 转移而来。</p>
<p>否则假如在 <span class="math inline">\(k\)</span> ，那么就可以从 <span class="math inline">\(f[l][k]\times f[k+1][r]\)</span> 转移而来。</p>
<p>使用记忆化搜索会更为方便，能够保证每次搜索的区间合法。</p>
<h2 id="总结">总结</h2>
<p>思考这道题时只是很板地想设 <span class="math inline">\(f[l][r]\)</span> ，于是不知道如何转移颜色。没有想到增加维度的操作。</p>
<p>另外，设计状态时，没有考虑在一个合法的括号序中，当时想的是任意区间。</p>
<h1 id="cf1025d---recovering-bst"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vMTAyNS9E">CF1025D - Recovering BST</span></h1>
<h2 id="tag">Tag</h2>
<p>*2100, DP, 紫</p>
<h2 id="题意-1">题意</h2>
<p>给出一个升序序列，问这个序列能否建出一棵二叉搜索树，满足任意一条边的两个点的值GCD大于一。<span class="math inline">\(n\le 700\)</span> 。</p>
<h2 id="解法-1">解法</h2>
<p>二叉搜索树的中序遍历就是升序序列，所以我们可以将这个问题转换成序列上的问题。一个子树就是一个区间。</p>
<p>可以设 <span class="math inline">\(f[l][r][k]\)</span> 表示区间 <span class="math inline">\([l,r]\)</span> ，根是 <span class="math inline">\(k\)</span> ，能不能建出一棵 BST 。</p>
<p>不难发现这样做是 <span class="math inline">\(O(n^4)\)</span> 的，感觉常数小很可以过。但是没过。</p>
<p>考虑优化。我们发现一个子树的根的父亲节点必定是这个区间 <span class="math inline">\([l,r]\)</span> 的 <span class="math inline">\(l-1\)</span> 或 <span class="math inline">\(r+1\)</span> 。</p>
<blockquote>
<p>为什么？考虑一个区间的一个位置，如果这个位置是根，那么区间左半部分就是左子树，右半部分就是右子树。如果 <span class="math inline">\([l,r]\)</span> 为区间的左半子树，那么父亲节点就是 <span class="math inline">\(r+1\)</span> ，否则就是 <span class="math inline">\(l-1\)</span> 。</p>
</blockquote>
<p>于是我们可以设 <span class="math inline">\(f[l][r][0/1]\)</span> 表示区间 <span class="math inline">\([l,r]\)</span> 能否作为父亲节点的左/右子树，也就是子树 <span class="math inline">\([l,r]\)</span> 的根的父亲节点是 <span class="math inline">\(r+1\)</span> 还是 <span class="math inline">\(l-1\)</span> 。</p>
<p>当我们计算 <span class="math inline">\(f[l][r][0/1]\)</span> 时，枚举 <span class="math inline">\([l,r]\)</span> 的根 <span class="math inline">\(k\)</span> ，那么就有左子树 <span class="math inline">\([l,k-1]\)</span> 和右子树 <span class="math inline">\([k+1,r]\)</span> 。如果 <span class="math inline">\(f[l][k-1][0]\)</span> 为真，并且 <span class="math inline">\(f[k+1][r][1]\)</span> 为真，那么说明 <span class="math inline">\(k\)</span> 可以作为这两棵子树的根，如果同时 <span class="math inline">\(k\)</span> 能够与 <span class="math inline">\(l-1\)</span> 相连，那么说明 <span class="math inline">\(f[l][r][1]\)</span> 为真了。</p>
<p>这样做状态数是 <span class="math inline">\(O(n^2)\)</span> ，转移是线性的。</p>
<h1 id="cf888f---connecting-vertices"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vODg4L0Y=">CF888F - Connecting Vertices</span></h1>
<h2 id="tag-1">Tag</h2>
<p>*2500, DP, 紫</p>
<h2 id="题意-2">题意</h2>
<p>给出一个整数 <span class="math inline">\(n\)</span> ，和一个由 01 构成的矩阵 <span class="math inline">\(a_{i,j}\)</span> 。表示有一个正 <span class="math inline">\(n\)</span> 边形，删去所有边，留下点。每一次需要连接两个点，总共连接 <span class="math inline">\(n-1\)</span> 条边，边不得交叉。使得这些点连通。如果 <span class="math inline">\(a_{i,j}\)</span> 为 1 的两个点不能直接相连，求方案总数。 <span class="math inline">\(n \le 700\)</span></p>
<h2 id="题外话">题外话</h2>
<p>想这道题的时候，把题目记错了，以为不一定要连通，寻思挺多方案，似乎难以 DP 。结果发现是要连成一棵树。</p>
<h2 id="解法-2">解法</h2>
<p>700 ，区间DP。</p>
<p>发现如果点 i 与点 j 直接或间接连接了，那么点 i 到点 j 必定连成了一棵树。</p>
<p>考虑如果没有连成一棵树，说明这或许超过了 n-1 条边，这显然会让最后没法连通。或许没有连通，那么这个点已经没法再连接起来了。</p>
<p>考虑设 <span class="math inline">\(f[i][j]\)</span> 表示点 i 与点 j 之间直接或间接连接，那么可以想到转移：</p>
<ol type="1">
<li><p>如果点 i 与点 j 直接相连，此时要求满足 <span class="math inline">\(a_{i,j}=1\)</span> ，则有： <span class="math display">\[
f[i][j]=\sum_{k=i}^{j-1}f[i][k]\times f[k+1][j]
\]</span> 意即 i 和 j 已经直接相连了，不能在另一条路连接，所以在 k 处断开。</p></li>
<li><p>如果 i 和 j 间接相连，则有： <span class="math display">\[
f[i][j]=\sum_{k=i+1}^{j-1}f[i][k]\times f[k][j]
\]</span> 意即从某一个点 k 将 i, j 连接起来。</p></li>
</ol>
<p>然而这样会算重。</p>
<p>考虑这种情况：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/83lyj5x8.png" /></p>
<p>此时按照 2 的情况转移，在 k 处会被计算一次，在 k' 处会被计算一次，那么就会重复。</p>
<p>如何避免这种情况？我们要求 i 必须与 k 直接相连，那么上述情况就只会在 i+1 处被计算一次，就不会算重了。</p>
<p>所以可以设 <span class="math inline">\(f[i][j][0/1]\)</span> 表示 i 和 j 是直接相连还是间接相连，于是就有： <span class="math display">\[
f[i][j][1]=\sum_{k=i}^{j-1}(f[i][k][0]+f[i][k][1])\times(f[k+1][j][0]+f[k+1][j][1])
\]</span> 与 <span class="math display">\[
f[i][j][0]=\sum_{k=i}^{j-1}f[i][k][1]\times(f[k+1][j][0] + f[k+1][j][1])
\]</span></p>
<h1 id="cf1889c1---doremys-drying-plan"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vMTg4OS9DMQ==">CF1889C1 - Doremy's Drying Plan</span></h1>
<h2 id="题意-3">题意</h2>
<p>给出若干个区间，要求删去这些区间任何 k 个，使得没有任何区间被覆盖的点数最多，求最多点数。</p>
<p>数据范围：点范围、区间数2e5，简单版下k=2</p>
<h2 id="解法-3">解法</h2>
<h3 id="我的解法">我的解法</h3>
<p>考虑到只有被覆盖不超过两次的点可能对答案有贡献，不妨求出这些点被哪些区间覆盖。按覆盖次数讨论：</p>
<p>0次，此时一定会对答案产生贡献。</p>
<p>1次，此时在选中这一个区间时对答案产生贡献。</p>
<p>2次，此时在两个区间都被选中时对答案产生贡献。</p>
<p>考虑将恰好被覆盖两次的点，被哪两个区间覆盖求出（利用线段树），进行双关键字排序，那么最后两个区间都被选中的情况便会相邻，只需要统计连续的点，满足覆盖它们的两个区间都相同的个数即可。再加上这两个区间覆盖1次的点的贡献，与被覆盖0次的点的贡献，取最大值即答案。</p>
<h3 id="题解做法">题解做法</h3>
<p>覆盖0次的点一定会对答案产生贡献，假设是 <span class="math inline">\(A\)</span> ，选定两个区间覆盖的点如果是 <span class="math inline">\(B\)</span> 。那么我们的目标就是求 <span class="math inline">\(A+\max{B}\)</span> 。</p>
<p>考虑两个区间的关系：</p>
<ul>
<li>如果两个区间相离，那么贡献就是被覆盖1次的点的个数。</li>
<li>如果两个区间相交，那么贡献就是被覆盖1次的点的个数减去被覆盖2次的点的个数。枚举每一个被覆盖两次的点，那么就可以得到是哪两个区间相交。即可计算答案。</li>
</ul>
<h1 id="cf1872g---replace-with-product"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9jb250ZXN0LzE4NzIvcHJvYmxlbS9H">CF1872G - Replace With Product</span></h1>
<h2 id="题意-4">题意</h2>
<p>给出一个序列，需要将序列中的一段数字替换成它们的乘积，求操作的区间，使得能得到最后可能的最大和。</p>
<p>序列长度是 2e5，数字范围是 [1,1e9]</p>
<h2 id="做法">做法</h2>
<p>典型的程怀德题。</p>
<p>很显然是如果选择的区间，前缀为一段1，或者后缀为一段1，显然不优，所以可以按照1的位置将这些区间分出来，但是有一些区间是可以跨过中间的1合并的。直接做难以合并。</p>
<p>考虑到数字的乘积可能非常大，写高精度不现实，没法比较两个区间的大小。所以考虑从乘积上面入手。</p>
<p>如果乘积太大了，我们发现此时每当我们乘上假如一个非1的数字，那么最后的和会变大许多，这个情况下，我们就会将所有的数字乘起来，除了前缀1和后缀1。</p>
<p>如何定义“太大了”？如果有所有数字的乘积超过 <span class="math inline">\(2\times n\)</span> ，那么此时如果我们不合并其中某一个非1的数字，答案会变少至少 <span class="math inline">\(n\)</span> ，这比1的贡献加起来要多，因为1的个数不可能超过 <span class="math inline">\(n\)</span> 。</p>
<p>如果乘积没有超过 <span class="math inline">\(2\times n\)</span> ，那么就将所有非1的段弄出来，这最多只有 <span class="math inline">\(O(\log n)\)</span> 个，暴力枚举从哪个段合并到哪个段，造成的贡献谁更大，用一些前缀和，前缀积维护一下就可以了。</p>
<h1 id="cf1900d---small-gcd"><span class="exturl" data-url="aHR0cHM6Ly9jb2RlZm9yY2VzLmNvbS9wcm9ibGVtc2V0L3Byb2JsZW0vMTkwMC9E">CF1900D - Small GCD</span></h1>
<h2 id="题外话-1">题外话</h2>
<p>这题只有2000？</p>
<h2 id="题意-5">题意</h2>
<p>定义函数 <span class="math inline">\(f(a,b,c)\)</span> 的值为 <span class="math inline">\(a,b,c\)</span> 中较小的两个数字的 <span class="math inline">\(\gcd\)</span> ，求对于给定序列，所有三元组的 <span class="math inline">\(f\)</span> 之和。</p>
<p>值域 <span class="math inline">\(10^{5}\)</span> ，<span class="math inline">\(n \le 8\times 10^4\)</span> 。</p>
<h2 id="做法-1">做法</h2>
<p>既然值域这么小那么和值域当然相关了。</p>
<p>我们发现如果我们能够计算出 <span class="math inline">\(cnt_{d}\)</span> ，表示 <span class="math inline">\(f\)</span> 函数值为 <span class="math inline">\(d\)</span> 的有多少个，那么答案就是 <span class="math inline">\(cnt_{d}\times d\)</span> 的和。</p>
<p>但是直接求 <span class="math inline">\(cnt_{d}\)</span> 不好求，这涉及到 gcd 恰好为 <span class="math inline">\(d\)</span> 。考虑转化一下：我们从大到小枚举，求 gcd 为 d 的倍数的有多少个，那么可以将这个数减去 <span class="math inline">\(cnt_{i}\)</span> ，<span class="math inline">\(i\)</span> 是 <span class="math inline">\(d\)</span> 的一个倍数，就可以得到恰好的。这个技巧很好。并且因为调和级数，复杂度是 <span class="math inline">\(O(m \log m)\)</span> 的，其中 <span class="math inline">\(m\)</span> 是值域。</p>
<p>如何求 gcd 为 d 的倍数有多少个？我们可以处理出，哪些 <span class="math inline">\(a_{i}\)</span> 有约数 <span class="math inline">\(d\)</span> ，那么我们只需要枚举三元组中的次大值，可以很快求出最小值能够选择的个数与最大值能够选择的方案数，满足 gcd 一定为 d 的倍数。</p>
<p>由于值域范围内约数最多的数字只有 128 个，不会 T。</p>
<h1 id="j---sushi-atcoder.jp"><span class="exturl" data-url="aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2RwL3Rhc2tzL2RwX2o=">J - Sushi (atcoder.jp)</span></h1>
<h2 id="题意-6">题意</h2>
<p>给定 <span class="math inline">\(n\)</span> 个盘子，每个盘子有 <span class="math inline">\(a_{i}\)</span> 个寿司，如果每一次等概率选择一个盘子，如果有寿司就吃掉，否则重新选择。求期望选择次数，使得所有寿司都被吃完。</p>
<p><span class="math inline">\(n \le 300\)</span> , <span class="math inline">\(1 \le a_{i} \le 3\)</span></p>
<h2 id="做法-2">做法</h2>
<p>既然数据范围这么小，不难想到，可以设状态 <span class="math inline">\(f_{i,j,k}\)</span> 表示盘子中有1个寿司的有 <span class="math inline">\(i\)</span> 个，2个寿司的 <span class="math inline">\(j\)</span> 个，3个寿司的 <span class="math inline">\(k\)</span> 个。</p>
<p>但是如何转移呢？可以从 <span class="math inline">\(f_{i-1,j,k}\)</span> 转移而来， 也可以从 <span class="math inline">\(f_{i+1,j-1,k}\)</span> 转移，还有 <span class="math inline">\(f_{i,j+1,k-1}\)</span> 。</p>
<p>但是似乎期望的和式的项数是无限项，因为可能随到一个空盘子，就需要不停地随机。但是这个过程可以表示为： <span class="math display">\[
f_{i,j,k}=f_{i,j,k}\times \frac{n-i-j-k}{n} +1
\]</span> 解方程可以知道， <span class="math display">\[
f_{i,j,k}=\frac{n}{i+j+k}
\]</span> 其意义就是随机到一个非空盘子的期望步数。</p>
]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>满分！ZS一学生获全国第一！</title>
    <url>/posts/%E6%BB%A1%E5%88%86%EF%BC%81zs%E4%B8%80%E5%AD%A6%E7%94%9F%E8%8E%B7%E5%85%A8%E5%9B%BD%E7%AC%AC%E4%B8%80%EF%BC%81/</url>
    <content><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vQ0RPSS0yNDM3NC9wLzE3MDExMjUyLmh0bWw=">原文出处</span>：原文作者：<span class="exturl" data-url="aHR0cHM6Ly9ob21lLmNuYmxvZ3MuY29tL3UvQ0RPSS0yNDM3NC8=">Jijidawang</span>。</p>
<p>原文遵循「署名-非商业性使用-相同方式共享 4.0 国际」许可协议（CC BY-NC-SA 4.0）进行许可。本博客博文遵循此协议。</p>
<p>满分！中山一学生这项赛事获全国第一！班里有牛娃咋办？没事别跟牛娃比！</p>
<span id="more"></span>
<p>他，是中国计算机学会主办的CSP软件能力认证的全国第一。年仅初二的他，成为全场最夺目的选手之一。</p>
<p>虽然只是初二的选手，但他取得优异成绩后，不少网友并不感到奇异，纷纷留言：</p>
<blockquote>
<p>这不是洛谷上天天爆切神仙题的少先队员们吗？</p>
</blockquote>
<p>没错，虽然他年纪轻轻，但是已经年少有为。俗话说：“有志不在年高”，这句话在他身上得到了很好的体现。</p>
<p>他就是洛谷账号 Follow 数达到 1w 的 OI （信息学奥林匹克竞赛）选手，Daniel QF。这么高的数据放在微博也是妥妥的大 V 了。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8pqfxegp.png" alt="Daniel QF'S LuoGu" style="zoom: 67%;" /></p>
<p>他的首页里面都是他获得的荣誉奖项，因为他为人谦虚谨慎，心地善良，所以只展示了考得最差的几次的成绩。尽管如此，这些成绩还是很耀眼的，一般的高中选手都难以获得，更何况一个初二选手了。</p>
<p>2022国际初中生信息学竞赛（International School in Informatics “Junior”，简称 ISIJ） 一个月前，Daniel QF更是在个人的洛谷博客上发布一篇博客，是 ISIJ 集训队的作业，并且在博客的最后放下豪言“近几年的 IOI 题都是傻逼题”。</p>
<p>一位“不明真相”的网友还评价说，“ISIJ 第一只有 1% 的机会能获得，我愿意以 1:99 的赔率打赌”。</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/y7xe7evp.png" alt="不明真相的网友" /><figcaption aria-hidden="true">不明真相的网友</figcaption>
</figure>
<p>这位网友不知道的是，Daniel QF去年第一次参加 NOI 就获得了 705 分以上的好成绩，吊打了全国所有的选手。</p>
<p>现在该评论已经被Daniel QF删除，不知道这位网友作何感想。</p>
<p>另外，与国内诸多 NOI 金牌学霸一样的是，Daniel QF也收到了名校通知书。</p>
<p>国内有不少 NOI 金牌得主被清华姚班选择，同样Daniel QF也与清华大学成功签约。</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/mbp4tsyb.png" alt="THU录取通知书" /><figcaption aria-hidden="true">THU录取通知书</figcaption>
</figure>
<p>对于仅仅年满 4 岁的他来说，一切都才刚开始。</p>
<p>Daniel QF对编程产生的兴趣起源很早，53 年前就开始在国内顶尖学术网站 UOJ （Universal Online Judge） 注册了一个账号，通过的第一个题目是 <span class="exturl" data-url="aHR0cHM6Ly91b2ouYWMvcHJvYmxlbS82MDc=">UOJ #1024 蚱蜢电话</span>。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/2rcklc2k.png" /></p>
<p>而 UOJ 1024 这道题到现在的通过率都不到 <span class="math inline">\(1%\)</span> ，可见他的天赋是多么过人了。一位不愿透露姓名的集训队队员都直言：这道题，我想一年都未必想得明白。</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/l2xzidt7.png" alt="CF Rating" /><figcaption aria-hidden="true">CF Rating</figcaption>
</figure>
<p>上图是 Codeforces 的 rating 的榜，前几位的选手都是世界排名前几的知名选手，多来自世界顶级大学，例如 Benq 来自就来自美国的顶级学府 MIT。Tourist 更是从小便开始接触信息学，获得过<strong>6次</strong>IOI金牌，但是在面对 danielqf 时，他也直言：</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/5us6nto7.png" alt="T宝的留言" /><figcaption aria-hidden="true">T宝的留言</figcaption>
</figure>
<p><strong>从全国第一逆袭到全球第一</strong></p>
<p>当被问及怎么样才能才能成为一个好的程序员（computer programmer，CP）时，danielqf可能会给出一个建议：</p>
<blockquote>
<p>除非像我一样天赋异禀，否则不可能！</p>
</blockquote>
<p>因为，他本人就是这么天才。</p>
]]></content>
      <tags>
        <tag>膜拜</tag>
      </tags>
  </entry>
  <entry>
    <title>线性基</title>
    <url>/posts/%E7%BA%BF%E6%80%A7%E5%9F%BA/</url>
    <content><![CDATA[<p>线性基是解决OI中异或问题的利器。</p>
<span id="more"></span>
<p>知识点完善程度：初步了解，做题量不足。</p>
<h1 id="介绍">介绍</h1>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGpoMjAwMC1qdW1wL3AvNTg2OTk5MS5odG1s">1</span> <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vVHJvdmVybGQvcC8xNDYyMTQzNC5odG1s">2</span> <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FfZm9yZXZlcl9kcmVhbS9hcnRpY2xlL2RldGFpbHMvODM2NTQzOTc=">3</span></p>
<ol type="1">
<li><p><strong>简单理解</strong>：一个数列 <span class="math inline">\(b_{i}\)</span> 的线性基是一组数字，<span class="math inline">\(a_{1},a_{2},a_{3},\cdots,a_{k}\)</span>，其中 <span class="math inline">\(a_{x}=b_{i}\)</span> 表示 <span class="math inline">\(b_{i}\)</span> 满足 <span class="math inline">\(b_{i}\)</span> 最高位的1是第 <span class="math inline">\(x\)</span> 位。如果存在多个 <span class="math inline">\(b_{i}\)</span> 满足这个条件，任选其中一个。如果没有就为0。</p></li>
<li><p><strong>性质</strong>：</p>
<ol type="1">
<li>一个数列的线性基中的数进行异或能够得到的数，与原数列中的数异或能够得到的数字相同。这个性质的证明可以由下面的构造的得出。</li>
<li>线性基中的任意一些数字异或起来都不为0。这个也能由构造给出。</li>
<li>线性基的大小唯一，并且是 <span class="math inline">\(b_{i}\)</span> 的子集中，能够拥有性质1的最小的。</li>
</ol></li>
<li><p><strong>构造</strong>：对序列 <span class="math inline">\(b_{i}\)</span> 中的数字进行插入。从高到低枚举每一个位置。</p>
<ul>
<li>如果这一位为0，那么跳过。[操作0]</li>
<li>如果这一位为1（假设是第 <span class="math inline">\(x\)</span> 位），考虑两种情况：
<ul>
<li>如果 <span class="math inline">\(a_{x}\)</span> 不为0，那么将这个数字异或上 <span class="math inline">\(a_{x}\)</span>。[操作1]</li>
<li>如果 <span class="math inline">\(a_{x}\)</span> 为0，那么将这个数字放到 <span class="math inline">\(a_{x}\)</span> 上。直接退出即可。[操作2]</li>
</ul></li>
</ul>
<details class="note info"><summary><p>性质1的证明</p>
</summary>
<p>如果插入的这个数字没有进行过操作2：说明通过线性基中的数字可以构造出这个数字。</p>
<p>如果插入的这个数字进行了操作2：进行操作2时，由于操作1的存在，这个数字高于 <span class="math inline">\(x\)</span> 位都为0了，此时插入线性基满足要求。</p>
<p>并且此时可以通过操作1的数字异或出这个数字的高 <span class="math inline">\(x\)</span> 位，再异或上 <span class="math inline">\(a_{x}\)</span> 就可以得到这个数字啦。</p>
<p>既然我们能够用线性基中的数字构造出原来的数列，那么也可以构造出原来数列能够异或出的集合啦。</p>
<p>如果一个数字是原来的序列不能够构造出的，那么线性基必然不能构造出。反证：如果线性基能够构造出，原数列也能构造出。</p>

</details>
<details class="note info"><summary><p>性质2的证明</p>
</summary>
<p>如果有 <span class="math inline">\(a_{p_{1}},a_{p_{2}},a_{p_{3}},\cdots,a_{p_{k}}\)</span> 异或和为0，那么有 <span class="math inline">\(a_{p_{1}},a_{p_{2}},a_{p_{3}},\cdots,a_{p_{k-1}}\)</span> 的异或和为 <span class="math inline">\(a_{p_{k}}\)</span> （由 <span class="math inline">\(a\oplus b=0 \Rightarrow a=b\)</span> 得到）</p>
<p>所以我们可以直接把 <span class="math inline">\(p_{k}\)</span> 从线性基中删掉，这样才能满足性质3。</p>

</details>
<details class="note info"><summary><p>性质3的证明</p>
</summary>
<ul>
<li><p>如果序列 <span class="math inline">\(b\)</span> 中的每一个数字都能插入到线性基中，那么这样一定是最小的。</p></li>
<li><p>如果有一个数字 <span class="math inline">\(b_{i}\)</span> 没能插入线性基，那么必然满足 <span class="math inline">\(c\oplus a_{j}=b_{i}\)</span> ，其中 <span class="math inline">\(c\)</span> 是 <span class="math inline">\(a\)</span> 中某些元素的异或和。</p>
<p>那么可以得到 <span class="math inline">\(c\oplus b_{i}=a_{j}\)</span>，也就是说，如果我们先插入了 <span class="math inline">\(b_{i}\)</span>，再插入 <span class="math inline">\(a_{j}\)</span>，那么 <span class="math inline">\(a_{j}\)</span> 不能被插入，线性基中元素个数不变。</p>
<p>并且如果我们删除线性基中的某一个元素，那么 <span class="math inline">\(b\)</span> 中必然有一些数字无法被表示，于是线性基的大小也是符合条件中最小的。</p></li>
</ul>

</details></li>
<li><p>判断一个数字是否在原数列通过异或，能够构造出的集合中。</p>
<p>我们从高位到低位判断，如果某一位为1，那么就异或上 <span class="math inline">\(a_{x}\)</span> 。如果最后是0，那么不能被构造出，否则能够被构造出。</p></li>
</ol>
<h1 id="应用">应用</h1>
<p>是例题，也是用法。</p>
<h2 id="最大异或和"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM4MTI=">最大异或和</span></h2>
<h3 id="题意">题意</h3>
<p>给定 <span class="math inline">\(n\)</span> 个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。</p>
<p><span class="math inline">\(1\le n\le 50\)</span>， <span class="math inline">\(0\le S_{i}\lt 2^{50}\)</span></p>
<details class="note info"><summary><p>做法</p>
</summary>
<p>直接做是 <span class="math inline">\(2^{n}\)</span> 的，线性基就可以了。</p>
<p>具体地，我们类似01-trie的贪心思想，每一次都异或上 <span class="math inline">\(a_{i}\)</span> 即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">50</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i])x^=a[i];</span><br><span class="line">      <span class="keyword">else</span>&#123;a[i]=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;ll x;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x),<span class="built_in">insert</span>(x);&#125;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">50</span>;i&gt;=<span class="number">0</span>;--i)<span class="keyword">if</span>((res^a[i])&gt;res)res^=a[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="最小异或和">最小异或和</h2>
<p>似乎没有这道题，那我胡一个。</p>
<p>题面类似求最大异或和。</p>
<p>但是做法不同。考虑如果有一个数字插入失败，那么异或和显然为0.</p>
<p>否则最小的 <span class="math inline">\(d_{i}\)</span> 就是答案。</p>
<h2 id="第k大异或和"><span class="exturl" data-url="aHR0cHM6Ly9sb2ouYWMvcC8xMTQ=">第k大异或和</span></h2>
<h3 id="题意-1">题意</h3>
<p>给出一个 <span class="math inline">\(n\)</span> 个数的序列，可以从中任意选出一些，求它们的异或和。</p>
<p>询问 <span class="math inline">\(m\)</span> 次，每次要在得到的不同异或和中，找到第 <span class="math inline">\(k\)</span> <strong>小</strong>（题目名字具有误导性，是要找第 k 小）</p>
<p><span class="math inline">\(1\le n,m \lt 10^{5}\)</span>，<span class="math inline">\(0\le S_{i}\lt 2^{50}\)</span></p>
<details class="note info"><summary><p>做法</p>
</summary>
<p>这次我们要寻找性质更强的线性基。</p>
<p>具体地，一个序列的线性基其实不止一种。当我们将 <span class="math inline">\(a_{i}\)</span> 异或上某一个 <span class="math inline">\(a_{j}\)</span> 后，这个序列仍然是原数列的一组线性基，证明是比较显然的。</p>
<p>那么我们要找出一组最小的线性基。</p>
<p>具体地，我们从小到大枚举每一个 <span class="math inline">\(i\)</span>，对于 <span class="math inline">\(a_{i}\)</span>，从大到小再枚举一个 <span class="math inline">\(j\)</span>。如果 <span class="math inline">\(a_{i}\)</span> 的第 <span class="math inline">\(j\)</span> 位是1，那么 <span class="math inline">\(a_{i}\leftarrow a_{i}\oplus a_{j}\)</span> 。这样我们就能够把 <span class="math inline">\(a_{i}\)</span> 的第 <span class="math inline">\(j\)</span> 位上的1给消去。</p>
<p>并且由于我们是从大到小的枚举的 <span class="math inline">\(j\)</span>，之前消去过的1不会再出现。</p>
<p>这样处理过得一组线性基的有非常好的性质。那就是，当用 <span class="math inline">\(a_{i}\oplus a_{j}\)</span> 时，得到的结果必然比 <span class="math inline">\(a_{i}\)</span> 和 <span class="math inline">\(a_{j}\)</span> 都大，因为得到的结果的第 <span class="math inline">\(i\)</span> 位和第 <span class="math inline">\(j\)</span> 位都变成了1，而原来它们只有其中一个为1。</p>
<p>推广一下，如果我们已经选了若干个 <span class="math inline">\(a_{i}\)</span> ，得到了一个异或和。当我们再加入一个没加入过得 <span class="math inline">\(a_{j}\)</span> 时，结果只会变大。</p>
<p>如果我们用一个二进制数，第 <span class="math inline">\(i\)</span> 位表示 <span class="math inline">\(a_{i}\)</span> 是否被选入参与异或；那么如果有两个二进制数 <span class="math inline">\(S&lt;T\)</span>，那么 <span class="math inline">\(S\)</span> 对应的异或和必然小于 <span class="math inline">\(T\)</span> 对应的异或和。只需要考虑它们选择了 <span class="math inline">\(a_{i}\)</span> ，那么第 <span class="math inline">\(i\)</span> 位异或后为1。</p>
<p>于是我们可以将 <span class="math inline">\(k\)</span> 表示成二进制，如果第 <span class="math inline">\(i\)</span> 位为1，那么异或上第 <span class="math inline">\(i\)</span> 个 <strong>非0</strong> 的 <span class="math inline">\(a\)</span>（而不是 <span class="math inline">\(a_{i}\)</span>）。</p>
<p>还要注意，如果最小异或和为0，我们就要将 <span class="math inline">\(k\)</span> 减去1，因为我们刚刚没有考虑0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K=<span class="number">55</span>;</span><br><span class="line">ll a[K],b[K];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="type">bool</span> flag;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">50</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[i])x^=a[i];</span><br><span class="line">      <span class="keyword">else</span>&#123;a[i]=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  flag=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">preProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">50</span>;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">      <span class="keyword">if</span>((a[i]&gt;&gt;j)&amp;<span class="number">1</span>)a[i]^=a[j];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">50</span>;++i)</span><br><span class="line">    <span class="keyword">if</span>(a[i])b[tot++]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(ll k)</span></span>&#123;</span><br><span class="line">  k-=flag;</span><br><span class="line">  <span class="keyword">if</span>(k&gt;=(<span class="number">1ll</span>&lt;&lt;tot))<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=tot;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>((k&gt;&gt;i)&amp;<span class="number">1</span>)res^=b[i];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;ll x;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;x);<span class="built_in">insert</span>(x);&#125;</span><br><span class="line">  <span class="built_in">preProcess</span>();</span><br><span class="line">  <span class="type">int</span> m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;ll k;<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;k);<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">qry</span>(k));&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="可删除线性基">可删除线性基</h2>
<p>现在要求支持一些操作：插入，删除，求最大异或和。</p>
<p>在线做法比较复杂，离线做法相对简单。</p>
<p>没有找到完全的模版题，自己造了一道，但是还没出好数据。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vVTM5MzUwOA==">模版链接</span></p>
<details class="note info"><summary><p>在线做法</p>
</summary>
<p>这些都是理论分析，还没写代码，可能存在错误。</p>
<p>插入就直接插。</p>
<p>删除的时候，如果删掉的数字在线性基外，直接删了就好，对答案没有影响。</p>
<p>如果删掉的数字在线性基内，这样不好直接删除。</p>
<ul>
<li><p>我们就考虑：当我们插入的时候，有一些没有插入成功的 <span class="math inline">\(x\)</span> ，它能够由线性基中的某些数的异或和表示 <span class="math inline">\(c\oplus a_{i}=x\)</span>，其中 <span class="math inline">\(c\)</span> 是线性基中某些数的异或和。我们变一下形，发现 <span class="math inline">\(c\oplus x=a_{i}\)</span>。</p>
<p>当我们用 <span class="math inline">\(a_{i}\)</span> 表示另一个数时，也可以用 <span class="math inline">\(x\)</span> 表示，<span class="math inline">\(c\oplus a_{i}\oplus y=x\oplus y\)</span>，我们发现 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(a_{i}\)</span> 是等价的。</p>
<p>也就是说，这些没有插入成功的数字可以“代替”在线性基中的一些数。</p>
<p>如果我们删除一个数，我们就把它替换成那个，能够代替的数。</p>
<p>这样不方便，我们不妨把那个代替的数给删掉，让李代桃僵，这样是等效的。</p>
<p>实现时直接维护 <span class="math inline">\(a_{i}\)</span> 有哪些可替代的数即可。</p></li>
<li><p>但是如果 <span class="math inline">\(a_{i}\)</span> 没有能够替代的数呢？</p>
<p>我们就必须要在线性基中消除 <span class="math inline">\(a_{i}\)</span> 的影响。我们考虑在插入的时候维护每一个数异或过哪些数字。</p>
<p>对于那些插入的时候异或过 <span class="math inline">\(a_{i}\)</span> 的数，我们回忆一下，插入的时候，我们将所有第 <span class="math inline">\(i\)</span> 位为1的数都异或上了 <span class="math inline">\(a_{i}\)</span>。删除的时候，我们就将它们全部异或上<span class="math inline">\(a_{i}\)</span>，但是这时候，它们的第 <span class="math inline">\(i\)</span> 位都为1，这在插入过程中显然是不可能出现的。</p>
<p>所以我们寻找一个最小的，异或过 <span class="math inline">\(a_{i}\)</span> 的数字。将它替换成 <span class="math inline">\(a_{i}\)</span>，那么其它数字在插入的时候，就会异或上新的 <span class="math inline">\(a_{i}\)</span>。</p>
<p>于是我们将其它异或过 <span class="math inline">\(a_{i}\)</span> 的数字都异或上新的 <span class="math inline">\(a_{i}\)</span> 即可。</p></li>
</ul>

</details>
<details class="note info"><summary><p>离线做法</p>
</summary>
<p>我们考虑贪心地进行插入的过程。</p>
<p>我们每次插入时，更高的位上，让线性基的删除时间更晚。因为如果时间到了，大的不能选，小的可以选，这不优。</p>
<p>所以我们让高位上的线性基的删除时间尽可能晚。</p>
<details class="note ">
<summary>
<p>
代码
</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> tim,ll x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LEN;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">    <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(tim&gt;dTime[i])<span class="built_in">swap</span>(dTime[i],tim),<span class="built_in">swap</span>(bas[i],x);</span><br><span class="line">      <span class="keyword">if</span>(!tim)<span class="keyword">return</span>;</span><br><span class="line">      x^=bas[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(<span class="type">int</span> tim)</span></span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=LEN;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>(tim&lt;dTime[i]&amp;&amp;((res&gt;&gt;i)&amp;<span class="number">1</span>)==<span class="number">0</span>)res=<span class="built_in">max</span>(res,res^bas[i]);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

</details>
<h2 id="与图论结合">与图论结合</h2>
<h3 id="p4151-wc2011-最大xor和路径"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQxNTE=">P4151 [WC2011] 最大XOR和路径</span></h3>
<h4 id="题意-2">题意</h4>
<p>给出一个 <span class="math inline">\(n(1\le n\le 5\times 10^{4})\)</span> 个点，<span class="math inline">\(m(1\le m\le 10^{5})\)</span>无向图，边有权值，权值范围在 <span class="math inline">\([0,10^{18}]\)</span> 之间。</p>
<p>要求找出一条从1号点到n号点的路径，满足路径的异或和最大。</p>
<details class="note info"><summary><p>做法</p>
</summary>
<p>首先我们考虑从1到n，假设只有一条路径，大概是这样：</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/9rw2ca6s.png" alt="graph1" /><figcaption aria-hidden="true">graph1</figcaption>
</figure>
<p>但是我们发现实际上这个路径上可能有环。</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/e47kryh7.png" alt="graph2" /><figcaption aria-hidden="true">graph2</figcaption>
</figure>
<p>我们考虑加入环之后路径答案的变化。如果原来的异或和为 <span class="math inline">\(dis\)</span> ，那么加入环之后就变为 <span class="math inline">\(dis\oplus k1\oplus c1\oplus k1=dis\oplus c1\)</span>。</p>
<p>如果加入多个环，同理可得，答案变为 <span class="math inline">\(dis\oplus c1\oplus c2\)</span>。</p>
<p>也就是说，我们只需要找到这条路径，并异或上某些环的异或和即可。</p>
<p>但是如果1到n有多条路径呢？</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/wpuke3ed.png" alt="graph3" /><figcaption aria-hidden="true">graph3</figcaption>
</figure>
<p>假设左边路径的异或和为 <span class="math inline">\(dis_{1}\)</span>，右边路径的异或和为 <span class="math inline">\(dis_{2}\)</span>，两条路径构成的环异或和为 <span class="math inline">\(dis_{3}\)</span>，那么我们有： <span class="math display">\[
dis_{2}=dis_{1}\oplus dis_{3}
\]</span> 也就是说，右边的路径可以通过左边的路径异或上一个环得到。</p>
<p>综上所述，我们只需要解决两个任务：</p>
<ol type="1">
<li><p>找到任意一条1到n的路径，并找到图中的所有环。</p></li>
<li><p>答案这条路径异或上若干个环得到。</p></li>
</ol>
<p>找环的部分可以通过一个有趣的结论来解决：所有环可以通过基本环（由一条非树边及其端点在书上路径组成的环）异或得到。所以我们只需要在DFS生成树上找基本环即可。（P.S.当时笔者写这道题的时候是暴力找的环，直接T0了。）</p>
<p>求答案的最大值可以使用线性基多快好省地解决。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span>+<span class="number">5</span>,M=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">  <span class="type">int</span> head[N],nxt[M],to[M],tot;</span><br><span class="line">  ll dis[M];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,ll w)</span></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u];</span><br><span class="line">    dis[tot]=w;</span><br><span class="line">    to[tot]=v;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;G;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line">ll sum[N];</span><br><span class="line">set&lt;ll&gt; cyc;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  vis[x]=<span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=G.head[x];i;i=G.nxt[i])</span><br><span class="line">    <span class="keyword">if</span>(!vis[G.to[i]])sum[G.to[i]]=sum[x]^G.dis[i],<span class="built_in">dfs</span>(G.to[i]);</span><br><span class="line">    <span class="keyword">else</span> cyc.<span class="built_in">insert</span>(sum[x]^sum[G.to[i]]^G.dis[i]);</span><br><span class="line">&#125;</span><br><span class="line">ll bas[<span class="number">64</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">63</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>((x&gt;&gt;i)&amp;<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(bas[i])x^=bas[i];</span><br><span class="line">      <span class="keyword">else</span>&#123;bas[i]=x;<span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qry</span><span class="params">(ll x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">63</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    <span class="keyword">if</span>((x^bas[i])&gt;x)x^=bas[i];</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="type">int</span> u,v;ll w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">    G.<span class="built_in">add</span>(u,v,w);G.<span class="built_in">add</span>(v,u,w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(ll x:cyc)<span class="built_in">insert</span>(x);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">qry</span>(sum[n]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="p3733-haoi2017-八纵八横"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM3MzM=">P3733 [HAOI2017] 八纵八横</span></h3>
<h4 id="题意-3">题意</h4>
<p>给出 <span class="math inline">\(n(1\le n\le 500)\)</span> 个点 <span class="math inline">\(m(1\le 500\le m)\)</span> 条边的无向图。</p>
<p>进行 <span class="math inline">\(Q(1\le Q\le 1000)\)</span> 次操作，操作分为三种：</p>
<ol type="1">
<li><code>Add x y z</code> 表示加入一条连接 <span class="math inline">\(x,y\)</span> 边权为 <span class="math inline">\(z\)</span> 的边。</li>
<li><code>Cancel k</code> 删除第 <span class="math inline">\(k\)</span> 次加入的边。</li>
<li><code>Change k z</code> 将第 <span class="math inline">\(k\)</span> 次加入的边的边权修改为 <span class="math inline">\(z\)</span>。</li>
</ol>
<p>其中所有边权 <span class="math inline">\(z\)</span> 均为非负整数，在二进制下长度不超过 <span class="math inline">\(1000\)</span> 位。</p>
<p>输入的 <span class="math inline">\(z\)</span> 和输出的答案均要在二进制下给出。</p>
<p>定义一条路径的权值为路径上的边的异或和。求经过1的环中的最大权值。</p>
<details class="note info"><summary><p>做法</p>
</summary>
<p>由于异或的性质，我们可以发现，任何环都是可以取到的。</p>
<p>如果一个环不包括1号点，那么我们可以从1号点出发，经过一些路径到这个环，遍历这个环后再原路返回。由于中间的路径被经过两次，贡献为0，只保留了环的共线。</p>
<p>所以我们现在只要维护环的最大答案即可，我们仍然考虑线性基来维护环的信息。</p>
<p>对于修改边的操作可以拆分成一次插入一次删除。</p>
<p>如果记 <span class="math inline">\(dis_{i}\)</span> 为从1到点 <span class="math inline">\(i\)</span> 的任意一条路径的长度，那么我们加入一条连接 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> ，权值为 <span class="math inline">\(z\)</span> 的边时，我们只需要加入 <span class="math inline">\(dis_{u}\oplus z\oplus dis_{v}\)</span> 的一个数字即可，相当于是经过了这条边的一个环。</p>
<p>那么如何处理删除操作呢？</p>
<h4 id="可删线性基做法">可删线性基做法</h4>
<p>按照上方可删线性基的离线/在线做法来做即可。</p>
<details class="note info">
<summary>
<p>
代码
</p>
</summary>
<p>
代码丑得要命，不忍直视。后面想方设法离线，搞得挺混乱，不要学我。
</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1005</span>,Q=<span class="number">2005</span>,LEN=<span class="number">2005</span>,M=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">using</span> bs=bitset&lt;LEN&gt;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(bs&amp; x)</span></span>&#123;</span><br><span class="line">  <span class="type">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">while</span>(c!=<span class="string">&#x27;0&#x27;</span>&amp;&amp;c!=<span class="string">&#x27;1&#x27;</span>)c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>;x.<span class="built_in">reset</span>();</span><br><span class="line">  <span class="keyword">while</span>(c==<span class="string">&#x27;0&#x27;</span>||c==<span class="string">&#x27;1&#x27;</span>)x[cnt++]=c^<span class="number">48</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt/<span class="number">2</span>;++i)&#123;<span class="type">bool</span> tmp=x[i];x[i]=x[cnt-i<span class="number">-1</span>];x[cnt-i<span class="number">-1</span>]=tmp;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> bs&amp; x)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">while</span>(x[i]==<span class="number">0</span>&amp;&amp;i&gt;<span class="number">0</span>)--i;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(x[i]^<span class="number">48</span>);</span><br><span class="line">    --i;</span><br><span class="line">  &#125;<span class="keyword">while</span>(i&gt;=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">  <span class="type">int</span> head[N],nxt[M],to[M],tot;</span><br><span class="line">  bs dis[M];</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,bs w)</span></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u];</span><br><span class="line">    to[tot]=v;</span><br><span class="line">    dis[tot]=w;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;G;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> dTime[N];</span><br><span class="line">bs bas[LEN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> tim,bs x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1000</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(x[i])&#123;</span><br><span class="line">      <span class="keyword">if</span>(tim&gt;dTime[i])<span class="built_in">swap</span>(tim,dTime[i]),<span class="built_in">swap</span>(x,bas[i]);</span><br><span class="line">      <span class="keyword">if</span>(!tim)<span class="keyword">return</span>;</span><br><span class="line">      x^=bas[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bs <span class="title">qry</span><span class="params">(<span class="type">int</span> tim)</span></span>&#123;</span><br><span class="line">  bs res;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1000</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!res[i])</span><br><span class="line">      <span class="keyword">if</span>(dTime[i]&gt;tim)res^=bas[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bs dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  vis[x]=<span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=G.head[x];i;i=G.nxt[i])</span><br><span class="line">    <span class="keyword">if</span>(vis[G.to[i]])<span class="built_in">insert</span>(q+<span class="number">1</span>,dis[x]^dis[G.to[i]]^G.dis[i]);</span><br><span class="line">    <span class="keyword">else</span> dis[G.to[i]]=dis[x]^G.dis[i],<span class="built_in">dfs</span>(G.to[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">bs ins[Q],chgVal[Q];</span><br><span class="line"><span class="type">int</span> tp[Q],cur[Q],del[Q],num[Q],v1[Q],v2[Q];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; chg[Q];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter[Q];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">  <span class="type">int</span> u,v;bs w;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">    <span class="built_in">read</span>(w);</span><br><span class="line">    G.<span class="built_in">add</span>(u,v,w);G.<span class="built_in">add</span>(v,u,w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">qry</span>(<span class="number">0</span>));</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)del[i]=q+<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">      tp[i]=<span class="number">1</span>;++cnt;<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;v1[cnt],&amp;v2[cnt]);<span class="built_in">read</span>(ins[cnt]);ins[cnt]=ins[cnt]^dis[v1[cnt]]^dis[v2[cnt]];cur[cnt]=cnt;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">1</span>]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">      tp[i]=<span class="number">2</span>;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num[i]);del[num[i]]=i;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      tp[i]=<span class="number">3</span>;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num[i]);<span class="built_in">read</span>(chgVal[i]);chg[num[i]].<span class="built_in">push_back</span>(i);chgVal[i]^=dis[v1[num[i]]]^dis[v2[num[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)iter[i]=chg[i].<span class="built_in">begin</span>();</span><br><span class="line">  cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tp[i]==<span class="number">1</span>)&#123;</span><br><span class="line">      ++cnt;</span><br><span class="line">      <span class="built_in">insert</span>(iter[cnt]==chg[cnt].<span class="built_in">end</span>()?del[cnt]:*iter[cnt],ins[cnt]);</span><br><span class="line">      <span class="keyword">if</span>(iter[cnt]!=chg[cnt].<span class="built_in">end</span>())++iter[cnt];</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tp[i]==<span class="number">3</span>)&#123;</span><br><span class="line">      <span class="type">int</span> k=num[i];</span><br><span class="line">      <span class="built_in">insert</span>(iter[k]==chg[k].<span class="built_in">end</span>()?del[k]:*iter[k],chgVal[i]);</span><br><span class="line">      <span class="keyword">if</span>(iter[k]!=chg[k].<span class="built_in">end</span>())++iter[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">qry</span>(i));</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h4 id="线段树分治">
线段树分治
</h4>
<p>
我们可以将信息离线下来之后线段树分治。
</p>
<p>
不是很会做。可以去洛谷看看题解。
</p>

</details>
<h1 id="推广">推广</h1>
<p>其实我们在介绍部分提到的线性基是一种特殊的线性基：异或线性基，是 OI 中较为常用的线性基。</p>
<p>我们先定义线性无关：对于一个集合 <span class="math inline">\(A\)</span>（实际上是线性空间），包含 <span class="math inline">\(m\)</span> 维向量，如果这个集合中的任何元素都不能通过其他元素进行线性运算（例如：数乘，加法等）得到，我们称这个集合线性无关。否则称为线性有关。</p>
<p>在异或线性基中，集合 <span class="math inline">\(A\)</span> 中的元素不能通过其它元素异或得到，就叫做线性无关。</p>
<p>线性基实质上是一个极大的线性无关组。这个基，通过线性运算能够得到的向量称为其张成。我们发现线性基和线性空间的张成是相同的。</p>
<p>推广之后，我们就可以做实数线性基了：</p>
<h2 id="p3265-jloi2015-装备购买"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDMyNjU=">P3265 [JLOI2015] 装备购买</span></h2>
<h3 id="题意-4">题意</h3>
<p>给定 <span class="math inline">\(n(1\le n\le 500)\)</span> 个装备，每个装备有 <span class="math inline">\(m(1\le m\le 500)\)</span> 个属性值 <span class="math inline">\(a_{i}(0\le a_{i}\le 1000)\)</span>，每一个装备有一个代价 <span class="math inline">\(c_{i}\)</span>。</p>
<p>每一个装备的属性值组成了一个 <span class="math inline">\(m\)</span> 维向量 <span class="math inline">\(\mathbf{z}_{i}=(a_{1},\cdots,a_{j},\cdots,a_{m})\)</span>。现在要求找出这些向量的最小代价线性基。</p>
<details class="note info"><summary><p>解法</p>
</summary>
<p>版题，排序之后插入，跟异或线性基差不多。</p>
<p>只不过这里的插入不使用异或来操作，使用类似高斯消元的办法消去第 <span class="math inline">\(i\)</span> 位上的属性值。</p>
<p>注意高斯消元的精度一直很玄学，所以EPS不要开太小，否则会挂分。</p>
<details class="note info">
<summary>
<p>
代码
</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">505</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> EPS=<span class="number">1e-5</span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Abs</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x&lt;<span class="number">0</span>?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Abs</span>(x)&lt;=EPS)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> x&lt;<span class="number">0</span>?<span class="number">-1</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a[N][N],val[N],id[N];</span><br><span class="line"><span class="type">double</span> bas[N][N],tmp[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)tmp[i]=a[x][i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(tmp[i]))&#123;</span><br><span class="line">      <span class="keyword">if</span>(!vis[i])&#123;vis[i]=<span class="literal">true</span>;<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)bas[i][j]=tmp[j];ans+=val[x];++cnt;<span class="keyword">return</span>;&#125;</span><br><span class="line">      <span class="type">double</span> t=tmp[i]/bas[i][i];</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)tmp[j]-=bas[i][j]*t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i]),id[i]=i;</span><br><span class="line">  <span class="built_in">sort</span>(id+<span class="number">1</span>,id+<span class="number">1</span>+n,[](<span class="type">int</span> x,<span class="type">int</span> y)&#123;<span class="keyword">return</span> val[x]&lt;val[y];&#125;);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">insert</span>(id[i]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %lld\n&quot;</span>,cnt,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

</details>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心</title>
    <url>/posts/%E8%B4%AA%E5%BF%83/</url>
    <content><![CDATA[<p>贪心是常见的一种算法，通常能够在较低的复杂度内，通过正确的决策得到答案。</p>
<p>常见的贪心方法有邻项交换法、反悔贪心等。</p>
<span id="more"></span>
<h1 id="邻项交换法">邻项交换法</h1>
<h2 id="noip2012-提高组-国王游戏"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDEwODA=">NOIP2012 提高组 国王游戏</span></h2>
<h3 id="题目大意">题目大意</h3>
<p>有 <span class="math inline">\(n+1\)</span> 个二元组 <span class="math inline">\((a_{i},b_{i})\)</span>，编号为 0 到 n。可以任意重新排列第 1 到 n 个二元组。</p>
<p>定义每个二元组的权值 <span class="math inline">\(c_{i}\)</span> 为： <span class="math display">\[
c_{i}=\frac{\prod_{j=0}^{i-1}a_{j}}{b_{i}}
\]</span> 要求最小化： <span class="math display">\[
\max_{i=1}^{n}(c_{i})
\]</span> <details class="note info"><summary><p>解法</p>
</summary>
<p>考虑邻项交换法，即什么时候，交换相邻的两项能够使得答案更优。</p>
<p>假设第 <span class="math inline">\(i\)</span> 项前 <span class="math inline">\(a\)</span> 的乘积为 <span class="math inline">\(s\)</span>，那么更优的条件是： <span class="math display">\[
\max(\frac{s}{b_{i}},\frac{s\times a_{i}}{b_{i+1}})&lt;\max(\frac{s}{b_{i+1}},\frac{s\times a_{i+1}}{b_{i}})
\]</span> 做一下变换： <span class="math display">\[
\begin{aligned}
\max(\frac{1}{b_{i}},\frac{a_{i}}{b_{i+1}})&amp;&lt;\max(\frac{1}{b_{i+1}},\frac{a_{i+1}}{b_{i}})\\
\max(b_{i+1},a_{i}\times b_{i})&amp;&lt;\max(b_{i},a_{i+1}\times b_{i+1})
\end{aligned}
\]</span> 我们按照这个式子进行排序，接着依照题意模拟即可得出答案。</p>
<hr />
<p>事实上，我们只需要比较 <span class="math inline">\(a_{i}\times b_{i}&lt;a_{i+1}\times b_{i+1}\)</span> 即可。</p>
<p>由于 <span class="math inline">\(a_{i}&gt;0\)</span>，所以有 <span class="math inline">\(b_{i+1}\le a_{i+1}\times b_{i+1}\)</span>，<span class="math inline">\(b_{i}\le a_{i}\times b_{i}\)</span>。</p>
<p>证明只需要分类考虑：</p>
<ul>
<li>左边的最大值取到 <span class="math inline">\(b_{i+1}\)</span> 时，因为 <span class="math inline">\(b_{i+1}\le a_{i+1}\times b_{i+1}\)</span>，此时左边小于右边，如果将左边换成更小的 <span class="math inline">\(a_{i}\times b_{i}\)</span>，左边小于右边仍然成立。</li>
<li>右边的最大值取到 <span class="math inline">\(b_{i}\)</span> 时，因为 <span class="math inline">\(b_{i}\le a_{i}\times b_{i}\)</span>，此时左边一定小于右边，如果将右边换成更小的 <span class="math inline">\(a_{i+1}\times b_{i+1}\)</span>，仍然满足左边小于右边。</li>
</ul>
<p>所以我们发现，如果最大值取到了 <span class="math inline">\(b_{i+1}\)</span> 或是 <span class="math inline">\(b_{i}\)</span> 时，使用另一项是等效的，我们只需要使用另一项比较即可！</p>
<p>为什么我们要拆开这个 <span class="math inline">\(\max\)</span> 呢？因为我们要证明其传递性，也就是如果 <span class="math inline">\(a_{i}\times b_{i}\le a_{j}\times b_{j}\)</span>，<span class="math inline">\(a_{j}\times b_{j}\le a_{k}\times b_{k}\)</span>，那么 <span class="math inline">\(a_{i}\times b_{i}\le a_{k}\times b_{k}\)</span>。如果不拆开 <span class="math inline">\(\max\)</span> 我们就难以证明这一点。如果不能满足传递性，我们排序之后模拟就是错误的。</p>
<details class="note success">
<summary>
<p>
代码
</p>
</summary>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a,b=<span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">ans=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    ans.append([<span class="built_in">int</span>(ii) <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">input</span>().split()])</span><br><span class="line">ans.sort(key=<span class="keyword">lambda</span> x:(x[<span class="number">0</span>]*x[<span class="number">1</span>]))</span><br><span class="line">s=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    s=<span class="built_in">max</span>(s,a//ans[i][<span class="number">1</span>])</span><br><span class="line">    a*=ans[i][<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure>
</details>
</p>

</details>
<h2 id="atcoder-dp-x"><span class="exturl" data-url="aHR0cHM6Ly9hdGNvZGVyLmpwL2NvbnRlc3RzL2RwL3Rhc2tzL2RwX3g=">AtCoder DP X</span></h2>
<p>虽然这道题是 DP，但是其中使用了邻项交换法。</p>
<h3 id="题目大意-1">题目大意</h3>
<p>有 <span class="math inline">\(N(1\le N\le 10^{3})\)</span> 个块，每一个块有质量 <span class="math inline">\(w_{i}\)</span>，坚固度 <span class="math inline">\(s_{i}\)</span>，价值 <span class="math inline">\(v_{i}\)</span>（<span class="math inline">\(1\le w_{i},s_{i}\le 10^{4},1\le v_{i}\le 10^{9}\)</span>）。想要选出若干个块堆叠成一个塔，要求满足某一个块上方的块的 <span class="math inline">\(w\)</span> 之和不超过这一个块的 <span class="math inline">\(s\)</span>。求最大代价和。</p>
<details class="note info"><summary><p>解法</p>
</summary>
<p>看到这到题，容易想到设 <span class="math inline">\(f_{i,j}\)</span> 表示前 <span class="math inline">\(i\)</span> 个块，选择后质量和为 <span class="math inline">\(j\)</span> 的最大价值。转移并不难，是一个 01 背包。</p>
<p>但是转移的顺序该如何确定？也就是说，我们应该按照什么顺序来考虑这些块？</p>
<p>我们考虑如果我们把块 <span class="math inline">\(i\)</span> 放在块 <span class="math inline">\(j\)</span> 的上方，那么还可以放 <span class="math inline">\(s_{j}-w_{i}\)</span>。</p>
<p>反之，如果把 <span class="math inline">\(j\)</span> 放在 <span class="math inline">\(i\)</span> 的上方，那么还可以方 <span class="math inline">\(s_{i}-w_{j}\)</span>。</p>
<p>我们当然是先转移上方的，才能转移下方的，所以 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(j\)</span> 上方就要满足： <span class="math display">\[
s_{j}-w_{i}\ge s_{i}-w_{j}
\]</span> 也就是 <span class="math display">\[
s_{j}+w_{j}\ge s_{i}+w_{i}
\]</span> 所以我们按照 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(w\)</span> 之和从小到大排序，进行转移即可。</p>
<details class="note ">
<summary>
<p>
success代码
</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>,M=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> w,s,v;</span><br><span class="line">&#125;a[N];</span><br><span class="line">ll f[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a[i].w,&amp;a[i].s,&amp;a[i].v);</span><br><span class="line">  <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,[](Node x,Node y)&#123;<span class="keyword">return</span> x.s+x.w&lt;y.s+y.w;&#125;);</span><br><span class="line">  ll ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=a[i].s+a[i].w;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">      <span class="keyword">if</span>(j&lt;a[i].w)<span class="keyword">break</span>;</span><br><span class="line">      f[j]=<span class="built_in">max</span>(f[j],f[j-a[i].w]+a[i].v);</span><br><span class="line">      ans=<span class="built_in">max</span>(ans,f[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

</details>
<h2 id="yloi2019-梅深不见冬"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDU1MjE=">yLOI2019 梅深不见冬</span></h2>
<h3 id="题目大意-2">题目大意</h3>
<p>按照欧拉序遍历一棵 <span class="math inline">\(n(1\le n\le 10^{5}+4)\)</span> 的树，每一个节点有一个需要放置的梅花数量 <span class="math inline">\(w_{i}(1\le w_{i}\le 1000)\)</span>。</p>
<p>规定每一个节点放置梅花的时候必须满足其所有 <strong>儿子</strong> 节点 <span class="math inline">\(v\)</span> 必须放置了恰好 <span class="math inline">\(w_{v}\)</span> 个梅花。</p>
<p>你可以在任何时候任何地点收回梅花，你可以以任意欧拉序遍历这一棵树。</p>
<p>求对于所有 <span class="math inline">\(i\)</span>，要在 <span class="math inline">\(i\)</span> 号点上放置 <span class="math inline">\(w_{i}\)</span> 个棉花至少需要多少个梅花。</p>
<details class="note info"><summary><p>解法</p>
</summary>
<p>考虑求对于某一个 <span class="math inline">\(i\)</span> 的答案，以欧拉序遍历，那么我们只需要考虑 <span class="math inline">\(i\)</span> 的子树即可。</p>
<p>假设点 <span class="math inline">\(i\)</span> 的答案为 <span class="math inline">\(ans_{i}\)</span>，<span class="math inline">\(i\)</span> 遍历儿子的顺序确定了，那么计算答案：</p>
<ul>
<li>遍历一个儿子 <span class="math inline">\(j\)</span> 以前，要将 1 到 j-1 这些儿子全部遍历，也就是说现在 1 到 j-1 这些儿子上都有梅花了，并且遍历节点 <span class="math inline">\(j\)</span> 也需要 <span class="math inline">\(ans_{j}\)</span> 个梅花，总共需要 <span class="math inline">\(ans_{j}+\sum_{k=1}^{j-1}w_{k}\)</span>。</li>
<li>以及遍历完所有儿子，那么 <span class="math inline">\(i\)</span> 也需要放置 <span class="math inline">\(w_{i}\)</span> 个梅花，需要 <span class="math inline">\(w_{i}+\sum_{j\in son_{x}}w_{j}\)</span> 的梅花。</li>
</ul>
<p>上面两个式子中的最大值就是 <span class="math inline">\(ans_{i}\)</span>。</p>
<hr />
<p>那么如何确定遍历儿子的顺序呢？我们发现如果有相邻的 <span class="math inline">\(i,j\)</span> 两个儿子，它们先后顺序对答案的贡献与其它儿子无关，所以可以考虑邻项交换。</p>
<p>如果儿子 <span class="math inline">\(i\)</span> 在儿子 <span class="math inline">\(j\)</span> 以前，就需要满足： <span class="math display">\[
\max(ans_{i},ans_{j}+w_{i})\le \max(ans_{j},ans_{i}+w_{j})
\]</span> 按照国王游戏类似的方法拆开这个 <span class="math inline">\(\max\)</span>，可以得到，上面的式子等价于： <span class="math display">\[
ans_{j}+w_{i}\le ans_{i}+w_{j}
\]</span> 也就是： <span class="math display">\[
w_{i}-ans_{i}\le w_{j}-ans_{j}
\]</span> 所以按照 <span class="math inline">\(ans_{i}-w_{i}\)</span> 从小到大排序后选择就是最优的。</p>
<details class="note success">
<summary>
<p>
代码
</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Created: 2024.01.20 02:51:34 PM +0800</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line">ll ans[N];</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">  <span class="type">int</span> head[N],nxt[N],to[N],tot;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    nxt[++tot]=head[u];</span><br><span class="line">    to[tot]=v;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;G;</span><br><span class="line"><span class="type">int</span> sonId[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=G.head[x];i;i=G.nxt[i])<span class="built_in">dfs</span>(G.to[i]);</span><br><span class="line">  <span class="type">int</span> sonCnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=G.head[x];i;i=G.nxt[i])sonId[++sonCnt]=G.to[i];</span><br><span class="line">  <span class="built_in">sort</span>(sonId+<span class="number">1</span>,sonId+sonCnt+<span class="number">1</span>,[](<span class="type">int</span> _,<span class="type">int</span> __)&#123;<span class="keyword">return</span> w[_]-ans[_]&lt;w[__]-ans[__];&#125;);</span><br><span class="line">  ll sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sonCnt;++i)&#123;</span><br><span class="line">    ans[x]=<span class="built_in">max</span>(ans[x],sum+ans[sonId[i]]);</span><br><span class="line">    sum+=w[sonId[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  ans[x]=<span class="built_in">max</span>(ans[x],sum+w[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;fa[i]),G.<span class="built_in">add</span>(fa[i],i);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

</details>
<h1 id="反悔贪心">反悔贪心</h1>
<h2 id="国家集训队-种树"><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE3OTI=">2011国家集训队 种树</span></h2>
<h3 id="题目大意-3">题目大意</h3>
<p>有 <span class="math inline">\(n(1\le n\le 2\times 10^{5})\)</span> 个数字 <span class="math inline">\(a_{i}\)</span> 围成一圈，选择一个数字之后，其相邻的两个数字就不能选择，求能够选择出的最大数字之和。</p>
<details class="note info"><summary><p>解法</p>
</summary>
<p>很容易可以得到一个 <span class="math inline">\(O(n^2)\)</span> 的 DP，但是时间难以承受。</p>
<p>我们考虑贪心。直接贪心，考虑每一次尽可能选择大的，然后标记左右两边的数字不能选择。</p>
<p>但是这样显然是错误的。例如 <code>10 9 1 9</code>，我们会选择 10，然后选 1。但是显然 9 和 9 会更优秀。</p>
<p>这该怎么办呢？我们反悔，不选择 10 了，改为选择 9 和 9。</p>
<p>具体而言，我们仍然从大向小选择，但是选择之后，我们留一条后路。</p>
<p>加入选择了 <span class="math inline">\(a_{i}\)</span>，那么我们将 <span class="math inline">\(a_{i}\)</span> 替换为 <span class="math inline">\(a_{l_{i}}+a_{r_{i}}-a_{i}\)</span>。这样，当再次选择 <span class="math inline">\(i\)</span> 的时候，就相当于原来没有选择 <span class="math inline">\(a_{i}\)</span>，而是选择了其左右两边的。</p>
<p>使用双向链表维护左右两边的是那些数字即可。</p>
<details class="note success">
<summary>
<p>
题解
</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Created: 2024.01.20 03:39:41 PM +0800</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pi=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> a[N],l[N],r[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  l[r[x]]=l[x];</span><br><span class="line">  r[l[x]]=r[x];</span><br><span class="line">  l[x]=r[x]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pi&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> n,m;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">if</span>(m&gt;n/<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]),q.<span class="built_in">push</span>(&#123;a[i],i&#125;);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)l[i]=i<span class="number">-1</span>,r[i]=i+<span class="number">1</span>;</span><br><span class="line">  l[<span class="number">1</span>]=n;r[n]=<span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(cnt&lt;m)&#123;</span><br><span class="line">    pi tmp=q.<span class="built_in">top</span>();</span><br><span class="line">    <span class="type">int</span> cur=tmp.second;</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(vis[cur])<span class="keyword">continue</span>;</span><br><span class="line">    ans+=tmp.first;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;a[l[cur]]+a[r[cur]]-a[cur],cur&#125;);</span><br><span class="line">    a[cur]=a[l[cur]]+a[r[cur]]-a[cur];</span><br><span class="line">    vis[l[cur]]=<span class="literal">true</span>;vis[r[cur]]=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">remove</span>(l[cur]);<span class="built_in">remove</span>(r[cur]);</span><br><span class="line">    ++cnt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

</details>
]]></content>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title>鲜花 / 序</title>
    <url>/posts/%E9%B2%9C%E8%8A%B1-%E5%BA%8F/</url>
    <content><![CDATA[<p>总是想写些什么，拿起笔，写下三两个字，又停下。</p>
<span id="more"></span>
<p>喜欢一个人发呆，望着落霞的齐飞，望着秋叶的愁容，望着远方的山，从清晰渐渐朦胧，从记忆里渐渐淡去。</p>
<p>在斟满回忆的烟雨中，看，一朵鲜花，她在淅沥中绽放。回眸间，雨凝结了时间，那抹芳香，向晚风中，丝丝缕缕，不知萦绕谁的心间。淡雨装点着她的美，朦胧中，将染山的霞光绚烂，隐约间，把落日的余晖点洒。</p>
<p>记不得你的模样，只剩下想象，无际的想象海洋，该用什么找回印象？彷徨，忧伤，如丁香般的惆怅。</p>
<p>希望，鲜花开遍，仍是春天。</p>
<blockquote>
<p>不是有希望，所以坚持，而是坚持，所以看到希望。</p>
</blockquote>
]]></content>
      <tags>
        <tag>鲜花</tag>
      </tags>
  </entry>
</search>
